<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      MILCHICK: Material Integration Leveraging Creative Human-LLM Intelligence
      Colors Kit
    </title>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />

    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --md-sys-color-primary-light: #6750a4;
        --md-sys-color-on-primary-light: #ffffff;
        --md-sys-color-primary-container-light: #eaddff;
        --md-sys-color-on-primary-container-light: #21005d;
        --md-sys-color-secondary-light: #625b71;
        --md-sys-color-on-secondary-light: #ffffff;
        --md-sys-color-secondary-container-light: #e8def8;
        --md-sys-color-on-secondary-container-light: #1d192b;
        --md-sys-color-tertiary-light: #7d5260;
        --md-sys-color-on-tertiary-light: #ffffff;
        --md-sys-color-tertiary-container-light: #ffd8e4;
        --md-sys-color-on-tertiary-container-light: #31111d;
        --md-sys-color-error-light: #b3261e;
        --md-sys-color-on-error-light: #ffffff;
        --md-sys-color-error-container-light: #f9dedc;
        --md-sys-color-on-error-container-light: #410e0b;
        --md-sys-color-background-light: #fffbfe;
        --md-sys-color-on-background-light: #1c1b1f;
        --md-sys-color-surface-light: #fffbfe;
        --md-sys-color-on-surface-light: #1c1b1f;
        --md-sys-color-surface-variant-light: #e7e0ec;
        --md-sys-color-on-surface-variant-light: #49454f;
        --md-sys-color-outline-light: #79747e;
        --md-sys-color-outline-variant-light: #cac4d0;
        --md-sys-color-shadow-light: #000000;
        --md-sys-color-scrim-light: #000000;
        --md-sys-color-inverse-surface-light: #313033;
        --md-sys-color-inverse-on-surface-light: #f4eff4;
        --md-sys-color-inverse-primary-light: #d0bcff;
        --md-sys-color-primary-dark: #d0bcff;
        --md-sys-color-on-primary-dark: #381e72;
        --md-sys-color-primary-container-dark: #4f378b;
        --md-sys-color-on-primary-container-dark: #eaddff;
        --md-sys-color-secondary-dark: #ccc2dc;
        --md-sys-color-on-secondary-dark: #332d41;
        --md-sys-color-secondary-container-dark: #4a4458;
        --md-sys-color-on-secondary-container-dark: #e8def8;
        --md-sys-color-tertiary-dark: #efb8c8;
        --md-sys-color-on-tertiary-dark: #492532;
        --md-sys-color-tertiary-container-dark: #633b48;
        --md-sys-color-on-tertiary-container-dark: #ffd8e4;
        --md-sys-color-error-dark: #f2b8b5;
        --md-sys-color-on-error-dark: #601410;
        --md-sys-color-error-container-dark: #8c1d18;
        --md-sys-color-on-error-container-dark: #f9dedc;
        --md-sys-color-background-dark: #1c1b1f;
        --md-sys-color-on-background-dark: #e6e1e5;
        --md-sys-color-surface-dark: #1c1b1f;
        --md-sys-color-on-surface-dark: #e6e1e5;
        --md-sys-color-surface-variant-dark: #49454f;
        --md-sys-color-on-surface-variant-dark: #cac4d0;
        --md-sys-color-outline-dark: #938f99;
        --md-sys-color-outline-variant-dark: #49454f;
        --md-sys-color-shadow-dark: #000000;
        --md-sys-color-scrim-dark: #000000;
        --md-sys-color-inverse-surface-dark: #e6e1e5;
        --md-sys-color-inverse-on-surface-dark: #313033;
        --md-sys-color-inverse-primary-dark: #6750a4;

        --comp-font-family: system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
          "Helvetica Neue", sans-serif;
        --comp-border-radius: 4px;

        --radio-chip-bg-light: var(--md-sys-color-surface-variant-light);
        --radio-chip-border-light: var(--md-sys-color-outline-variant-light);
        --radio-chip-text-light: var(--md-sys-color-on-surface-variant-light);
        --radio-chip-hover-bg-light: color-mix(
          in srgb,
          var(--md-sys-color-primary-light) 10%,
          transparent
        );
        --radio-chip-hover-border-light: var(--md-sys-color-primary-light);
        --radio-chip-selected-bg-light: var(--md-sys-color-primary-light);
        --radio-chip-selected-border-light: var(--md-sys-color-primary-light);
        --radio-chip-selected-text-light: var(--md-sys-color-on-primary-light);

        --radio-chip-bg-dark: var(--md-sys-color-surface-variant-dark);
        --radio-chip-border-dark: var(--md-sys-color-outline-variant-dark);
        --radio-chip-text-dark: var(--md-sys-color-on-surface-variant-dark);
        --radio-chip-hover-bg-dark: color-mix(
          in srgb,
          var(--md-sys-color-primary-dark) 10%,
          transparent
        );
        --radio-chip-hover-border-dark: var(--md-sys-color-primary-dark);
        --radio-chip-selected-bg-dark: var(--md-sys-color-primary-dark);
        --radio-chip-selected-border-dark: var(--md-sys-color-primary-dark);
        --radio-chip-selected-text-dark: var(--md-sys-color-on-primary-dark);

        --radio-chip-bg: var(--radio-chip-bg-light);
        --radio-chip-border: var(--radio-chip-border-light);
        --radio-chip-text: var(--radio-chip-text-light);
        --radio-chip-hover-bg: var(--radio-chip-hover-bg-light);
        --radio-chip-hover-border: var(--radio-chip-hover-border-light);
        --radio-chip-selected-bg: var(--radio-chip-selected-bg-light);
        --radio-chip-selected-border: var(--radio-chip-selected-border-light);
        --radio-chip-selected-text: var(--radio-chip-selected-text-light);

        --minimap-tooltip-bg-light: color-mix(
          in srgb,
          var(--md-sys-color-inverse-surface-light) 95%,
          black
        );
        --minimap-tooltip-text-light: var(
          --md-sys-color-inverse-on-surface-light
        );
        --minimap-tooltip-code-bg-light: color-mix(
          in srgb,
          var(--md-sys-color-inverse-on-surface-light) 10%,
          transparent
        );
        --minimap-tooltip-code-text-light: var(
          --md-sys-color-inverse-on-surface-light
        );
        --minimap-tooltip-bg-dark: color-mix(
          in srgb,
          var(--md-sys-color-inverse-surface-dark) 95%,
          white
        );
        --minimap-tooltip-text-dark: var(
          --md-sys-color-inverse-on-surface-dark
        );
        --minimap-tooltip-code-bg-dark: color-mix(
          in srgb,
          var(--md-sys-color-inverse-on-surface-dark) 10%,
          transparent
        );
        --minimap-tooltip-code-text-dark: var(
          --md-sys-color-inverse-on-surface-dark
        );

        --minimap-tooltip-bg: var(--minimap-tooltip-bg-light);
        --minimap-tooltip-text: var(--minimap-tooltip-text-light);
        --minimap-tooltip-code-bg: var(--minimap-tooltip-code-bg-light);
        --minimap-tooltip-code-text: var(--minimap-tooltip-code-text-light);

        --minimap-transition-duration: 0.4s;
      }

      .dark-theme {
        --radio-chip-bg: var(--radio-chip-bg-dark);
        --radio-chip-border: var(--radio-chip-border-dark);
        --radio-chip-text: var(--radio-chip-text-dark);
        --radio-chip-hover-bg: var(--radio-chip-hover-bg-dark);
        --radio-chip-hover-border: var(--radio-chip-hover-border-dark);
        --radio-chip-selected-bg: var(--radio-chip-selected-bg-dark);
        --radio-chip-selected-border: var(--radio-chip-selected-border-dark);
        --radio-chip-selected-text: var(--radio-chip-selected-text-dark);
        --minimap-tooltip-bg: var(--minimap-tooltip-bg-dark);
        --minimap-tooltip-text: var(--minimap-tooltip-text-dark);
        --minimap-tooltip-code-bg: var(--minimap-tooltip-code-bg-dark);
        --minimap-tooltip-code-text: var(--minimap-tooltip-code-text-dark);

        background-color: var(--md-sys-color-background-dark);
        color: var(--md-sys-color-on-background-dark);
      }

      body {
        font-family: var(--comp-font-family);
        line-height: 1.6;
        background-color: var(--md-sys-color-background-light);
        color: var(--md-sys-color-on-background-light);
        padding: 20px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        transition: background-color 0.3s ease, color 0.3s ease;
        position: relative;
      }

      .container {
        max-width: 1300px;
        margin: 0 auto;
      }

      .main-content-grid {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 30px;
        margin-top: 25px;
      }

      .phases-container {
        display: flex;
        flex-direction: column;
        gap: 25px;
      }

      #workflow-minimap {
        grid-column: 2 / 3;
        grid-row: 1 / 2;
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-surface-light) 85%,
          transparent
        );
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid var(--md-sys-color-outline-variant-light);
        border-radius: 8px;
        padding: 10px 0;
        font-size: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-self: start;
        position: sticky;
        top: 20px;
        width: 180px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        overflow-x: hidden;
        z-index: 100;
      }

      .dark-theme #workflow-minimap {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-surface-dark) 85%,
          transparent
        );
        border-color: var(--md-sys-color-outline-variant-dark);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }

      #minimap-title {
        font-weight: 600;
        color: var(--md-sys-color-on-surface-variant-light);
        border-bottom: 1px solid var(--md-sys-color-outline-variant-light);
        padding: 0 12px 6px 12px;
        margin-bottom: 8px;
        position: sticky;
        top: 0;
        background: inherit;
        z-index: 102;
      }

      .dark-theme #minimap-title {
        color: var(--md-sys-color-on-surface-variant-dark);
        border-bottom-color: var(--md-sys-color-outline-variant-dark);
      }

      #minimap-content {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
        padding: 0 12px 10px 12px;
      }

      .minimap-node,
      .minimap-edge {
        position: relative;
        cursor: help;
        opacity: 0;
        transition: opacity var(--minimap-transition-duration) ease-in-out;
        will-change: opacity;
        transform: translateZ(0);
      }

      .minimap-node.visible,
      .minimap-edge.visible {
        opacity: 1;
      }

      .minimap-node {
        padding: 4px 8px;
        border-radius: 3px;
        border: 1px solid;
        line-height: 1.3;
        text-align: center;
      }

      .minimap-edge {
        padding: 3px 5px;
        font-weight: bold;
        color: var(--md-sys-color-outline-light);
        text-align: center;
        height: auto;
        line-height: 1.2;
        border-radius: 3px;
      }

      .dark-theme .minimap-edge {
        color: var(--md-sys-color-outline-dark);
      }

      .minimap-tooltip {
        visibility: hidden;
        opacity: 0;
        position: fixed;
        background-color: var(--minimap-tooltip-bg);
        color: var(--minimap-tooltip-text);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 11px;
        line-height: 1.45;
        z-index: 10000;
        width: max-content;
        max-width: 300px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out,
          transform 0.2s ease-in-out;
        pointer-events: none;
        white-space: normal;
        transform: translateX(0);
      }

      .minimap-tooltip-code {
        display: block;
        background-color: var(--minimap-tooltip-code-bg);
        color: var(--minimap-tooltip-code-text);
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          Courier, monospace;
        font-size: 0.95em;
        padding: 5px 8px;
        border-radius: 4px;
        margin-top: 6px;
        word-break: break-all;
      }

      .minimap-node:hover .minimap-tooltip,
      .minimap-edge:hover .minimap-tooltip,
      .minimap-node:focus .minimap-tooltip,
      .minimap-edge:focus .minimap-tooltip {
        visibility: visible;
        opacity: 1;
        transform: translateX(calc(-100% - 20px));
      }

      .node-start {
        background-color: var(--md-sys-color-tertiary-container-light);
        border-color: var(--md-sys-color-tertiary-light);
        color: var(--md-sys-color-on-tertiary-container-light);
      }
      .dark-theme .node-start {
        background-color: var(--md-sys-color-tertiary-container-dark);
        border-color: var(--md-sys-color-tertiary-dark);
        color: var(--md-sys-color-on-tertiary-container-dark);
      }
      .node-human {
        background-color: var(--md-sys-color-primary-container-light);
        border-color: var(--md-sys-color-primary-light);
        color: var(--md-sys-color-on-primary-container-light);
      }
      .dark-theme .node-human {
        background-color: var(--md-sys-color-primary-container-dark);
        border-color: var(--md-sys-color-primary-dark);
        color: var(--md-sys-color-on-primary-container-dark);
      }
      .node-tool {
        background-color: var(--md-sys-color-secondary-container-light);
        border-color: var(--md-sys-color-secondary-light);
        color: var(--md-sys-color-on-secondary-container-light);
      }
      .dark-theme .node-tool {
        background-color: var(--md-sys-color-secondary-container-dark);
        border-color: var(--md-sys-color-secondary-dark);
        color: var(--md-sys-color-on-secondary-container-dark);
      }
      .node-mcp {
        background-color: #e0f7fa;
        border-color: #0097a7;
        color: #006064;
      }
      .dark-theme .node-mcp {
        background-color: #004d40;
        border-color: #4db6ac;
        color: #e0f2f1;
      }
      .node-llm {
        background-color: #fff3e0;
        border-color: #ffb74d;
        color: #e65100;
      }
      .dark-theme .node-llm {
        background-color: #4e342e;
        border-color: #ffcc80;
        color: #ffe0b2;
      }
      .node-result {
        background-color: #e8f5e9;
        border-color: #81c784;
        color: #1b5e20;
      }
      .dark-theme .node-result {
        background-color: #1b5e20;
        border-color: #a5d6a7;
        color: #c8e6c9;
      }
      .node-error {
        background-color: var(--md-sys-color-error-container-light);
        border-color: var(--md-sys-color-error-light);
        color: var(--md-sys-color-on-error-container-light);
      }
      .dark-theme .node-error {
        background-color: var(--md-sys-color-error-container-dark);
        border-color: var(--md-sys-color-error-dark);
        color: var(--md-sys-color-on-error-container-dark);
      }
      .node-decision {
        background-color: #f3e5f5;
        border-color: #ab47bc;
        color: #4a148c;
      }
      .dark-theme .node-decision {
        background-color: #2c193f;
        border-color: #ce93d8;
        color: #f3e5f5;
      }

      .edge-human {
        color: var(--md-sys-color-primary-light);
      }
      .dark-theme .edge-human {
        color: var(--md-sys-color-primary-dark);
      }
      .edge-tool {
        color: var(--md-sys-color-secondary-light);
      }
      .dark-theme .edge-tool {
        color: var(--md-sys-color-secondary-dark);
      }
      .edge-mcp {
        color: #0097a7;
      }
      .dark-theme .edge-mcp {
        color: #4db6ac;
      }
      .edge-llm {
        color: #ffb74d;
      }
      .dark-theme .edge-llm {
        color: #ffcc80;
      }
      .edge-gemini-bridge {
        color: #ffb74d;
        border: 1px dashed #ffb74d;
        padding: 0 2px;
        border-radius: 2px;
      }
      .dark-theme .edge-gemini-bridge {
        color: #ffcc80;
        border-color: #ffcc80;
      }
      .edge-error {
        color: var(--md-sys-color-error-light);
      }
      .dark-theme .edge-error {
        color: var(--md-sys-color-error-dark);
      }
      .edge-result {
        color: #81c784;
      }
      .dark-theme .edge-result {
        color: #a5d6a7;
      }
      .edge-decision {
        color: #ab47bc;
        border: 1px dotted #ab47bc;
        padding: 0 2px;
        border-radius: 2px;
      }
      .dark-theme .edge-decision {
        color: #ce93d8;
        border-color: #ce93d8;
      }

      .minimap-node.active,
      .minimap-edge.active {
        box-shadow: 0 0 0 2px var(--md-sys-color-primary-light);
        font-weight: bold;
      }
      .dark-theme .minimap-node.active,
      .dark-theme .minimap-edge.active {
        box-shadow: 0 0 0 2px var(--md-sys-color-primary-dark);
      }
      .minimap-edge::after {
        content: "↓";
        font-size: 1.2em;
      }
      .minimap-edge.edge-gemini-bridge::before {
        content: "↑";
        font-size: 1.2em;
        margin-right: 2px;
      }
      .minimap-edge.edge-gemini-bridge::after {
        content: "↓";
        font-size: 1.2em;
        margin-left: 2px;
      }
      .minimap-edge.edge-decision::after {
        content: "?";
        font-size: 1.1em;
        font-weight: bold;
      }

      #theme-toggle {
        position: absolute;
        top: 15px;
        right: 20px;
        background: none;
        border: none;
        cursor: pointer;
        color: var(--md-sys-color-on-surface-variant-light);
        padding: 8px;
        border-radius: 50%;
        z-index: 1001;
      }

      #theme-toggle:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-variant-light) 10%,
          transparent
        );
      }

      .dark-theme #theme-toggle {
        color: var(--md-sys-color-on-surface-variant-dark);
      }

      .dark-theme #theme-toggle:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-variant-dark) 10%,
          transparent
        );
      }

      .phase-card {
        background-color: var(--md-sys-color-surface-light);
        border-radius: 12px;
        border: 1px solid var(--md-sys-color-outline-variant-light);
        padding: 25px;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        position: relative;
      }
      .dark-theme .phase-card {
        background-color: var(--md-sys-color-surface-dark);
        border-color: var(--md-sys-color-outline-variant-dark);
      }
      .phase-card-placeholder {
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--md-sys-color-outline-light);
        font-style: italic;
        border-style: dashed;
      }
      .dark-theme .phase-card-placeholder {
        color: var(--md-sys-color-outline-dark);
      }

      .phase-card.phase-human-decision {
        border-left: 5px solid var(--md-sys-color-primary-light);
      }
      .dark-theme .phase-card.phase-human-decision {
        border-left-color: var(--md-sys-color-primary-dark);
      }
      .phase-card.phase-llm-decision {
        border-left: 5px solid #ffb74d;
      }
      .dark-theme .phase-card.phase-llm-decision {
        border-left-color: #ffcc80;
      }
      .phase-card.phase-mcp-tool {
        border-left: 5px solid var(--md-sys-color-secondary-light);
      }
      .dark-theme .phase-card.phase-mcp-tool {
        border-left-color: var(--md-sys-color-secondary-dark);
      }
      .phase-card.phase-local-tool {
        border-left: 5px solid var(--md-sys-color-tertiary-light);
      }
      .dark-theme .phase-card.phase-local-tool {
        border-left-color: var(--md-sys-color-tertiary-dark);
      }
      .phase-card .back-button-area {
        position: absolute;
        top: 10px;
        right: 10px;
      }
      .phase-card .back-button-area button {
        background-color: transparent;
        color: var(--md-sys-color-outline-variant-light);
        padding: 4px;
        border-radius: 4px;
        font-size: 0.85em;
        border: 1px solid var(--md-sys-color-outline-variant-light);
        cursor: pointer;
      }
      .dark-theme .phase-card .back-button-area button {
        color: var(--md-sys-color-outline-variant-dark);
        border-color: var(--md-sys-color-outline-variant-dark);
      }
      .phase-card .back-button-area button:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-outline-variant-light) 10%,
          transparent
        );
      }
      .dark-theme .phase-card .back-button-area button:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-outline-variant-dark) 10%,
          transparent
        );
      }

      h1,
      h2,
      h3,
      h4,
      h5 {
        margin-bottom: 0.8em;
        color: var(--md-sys-color-on-surface-light);
        font-weight: 600;
      }
      .dark-theme h1,
      .dark-theme h2,
      .dark-theme h3,
      .dark-theme h4,
      .dark-theme h5 {
        color: var(--md-sys-color-on-surface-dark);
      }
      h1 {
        font-size: 1.8em;
        margin-bottom: 1em;
      }
      h2 {
        margin-top: 1.5em;
        font-size: 1.4em;
        padding-bottom: 0.4em;
        border-bottom: 1px solid var(--md-sys-color-outline-variant-light);
      }
      .dark-theme h2 {
        border-bottom-color: var(--md-sys-color-outline-variant-dark);
      }

      h3 {
        margin-top: 1em;
        font-size: 1.15em;
        margin-bottom: 0.6em;
      }

      h4 {
        font-size: 1em;
        margin-bottom: 0.8em;
        color: var(--md-sys-color-on-surface-variant-light);
        font-weight: 500;
      }
      .dark-theme h4 {
        color: var(--md-sys-color-on-surface-variant-dark);
      }
      h5 {
        font-size: 0.95em;
        margin-bottom: 0.5em;
        font-weight: 500;
      }

      p {
        margin-bottom: 1em;
        color: var(--md-sys-color-on-surface-variant-light);
      }
      .dark-theme p {
        color: var(--md-sys-color-on-surface-variant-dark);
      }

      code {
        background-color: #f0f0f0;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          Courier, monospace;
        font-size: 0.9em;
        color: #111;
        border: 1px solid #e0e0e0;
      }
      .dark-theme code {
        background-color: #333;
        color: #eee;
        border-color: #555;
      }

      fieldset {
        border: 1px solid var(--md-sys-color-outline-light);
        border-radius: 8px;
        padding: 15px 20px;
        margin-bottom: 20px;
      }
      .dark-theme fieldset {
        border-color: var(--md-sys-color-outline-dark);
      }
      legend {
        font-weight: 600;
        padding: 0 8px;
        font-size: 1em;
        color: var(--md-sys-color-on-surface-light);
      }
      .dark-theme legend {
        color: var(--md-sys-color-on-surface-dark);
      }

      .input-group {
        margin-bottom: 20px;
      }
      .input-group label,
      .checkbox-label,
      .radio-group-label,
      .selection-group-label {
        display: block;
        font-weight: 500;
        margin-bottom: 6px;
        font-size: 0.9em;
        color: var(--md-sys-color-on-surface-variant-light);
      }
      .dark-theme .input-group label,
      .dark-theme .checkbox-label,
      .dark-theme .radio-group-label,
      .dark-theme .selection-group-label {
        color: var(--md-sys-color-on-surface-variant-dark);
      }

      .input-group input[type="text"],
      .input-group input[type="number"],
      .input-group select,
      .input-group textarea {
        padding: 10px 12px;
        border: 1px solid var(--md-sys-color-outline-light);
        border-radius: 4px;
        width: 100%;
        margin-bottom: 5px;
        background-color: var(--md-sys-color-surface-light);
        color: var(--md-sys-color-on-surface-light);
        font-size: 0.95em;
        transition: border-color 0.2s ease;
      }
      .dark-theme .input-group input[type="text"],
      .dark-theme .input-group input[type="number"],
      .dark-theme .input-group select,
      .dark-theme .input-group textarea {
        background-color: var(--md-sys-color-surface-dark);
        color: var(--md-sys-color-on-surface-dark);
        border-color: var(--md-sys-color-outline-dark);
      }
      #text-prompt-input {
        font-size: 1.05em;
        padding: 12px;
        min-height: 80px;
      }
      .input-group input:focus,
      .input-group select:focus,
      .input-group textarea:focus {
        border-color: var(--md-sys-color-primary-light);
        outline: 1px solid var(--md-sys-color-primary-light);
      }
      .dark-theme .input-group input:focus,
      .dark-theme .input-group select:focus,
      .dark-theme .input-group textarea:focus {
        border-color: var(--md-sys-color-primary-dark);
        outline-color: var(--md-sys-color-primary-dark);
      }

      .input-group input[type="color"] {
        width: 42px;
        height: 42px;
        padding: 2px;
        vertical-align: middle;
        border: 1px solid var(--md-sys-color-outline-light);
        border-radius: 4px;
        cursor: pointer;
        background-color: #fff;
      }
      .dark-theme .input-group input[type="color"] {
        border-color: var(--md-sys-color-outline-dark);
        background-color: #333;
      }
      input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 3px;
      }
      input[type="color"]::-moz-color-swatch {
        border: none;
        border-radius: 3px;
      }

      .input-group .color-input-row {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-right: 15px;
        margin-bottom: 8px;
      }
      .input-group .color-input-row label {
        width: auto;
        margin-bottom: 0;
        margin-right: 4px;
        text-align: right;
        font-size: 0.85em;
        color: var(--md-sys-color-on-surface-variant-light);
      }
      .dark-theme .input-group .color-input-row label {
        color: var(--md-sys-color-on-surface-variant-dark);
      }

      .chip-selection-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .chip-selection-group input[type="radio"] {
        opacity: 0;
        position: absolute;
        width: 1px;
        height: 1px;
      }
      .chip-selection-group label {
        display: inline-block;
        padding: 6px 14px;
        border: 1px solid var(--radio-chip-border);
        background-color: var(--radio-chip-bg);
        color: var(--radio-chip-text);
        border-radius: 20px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.2s ease, border-color 0.2s ease,
          color 0.2s ease;
        user-select: none;
        position: relative;
      }
      .chip-selection-group label:hover {
        background-color: var(--radio-chip-hover-bg);
        border-color: var(--radio-chip-hover-border);
      }
      .chip-selection-group input[type="radio"]:checked + label {
        background-color: var(--radio-chip-selected-bg);
        border-color: var(--radio-chip-selected-border);
        color: var(--radio-chip-selected-text);
        font-weight: 500;
      }
      .chip-selection-group input[type="radio"]:focus-visible + label {
        outline: 2px solid var(--md-sys-color-primary-light);
        outline-offset: 2px;
      }
      .dark-theme
        .chip-selection-group
        input[type="radio"]:focus-visible
        + label {
        outline-color: var(--md-sys-color-primary-dark);
      }
      .chip-selection-group label::before,
      .chip-selection-group label::after {
        display: none;
      }
      .chip-selection-group div {
        line-height: 1;
      }

      .info-tooltip {
        display: inline-block;
        margin-left: 5px;
        cursor: help;
        color: var(--md-sys-color-outline-light);
        position: relative;
      }
      .dark-theme .info-tooltip {
        color: var(--md-sys-color-outline-dark);
      }
      .info-tooltip .material-icons {
        font-size: 1.1em;
        vertical-align: middle;
      }
      .info-tooltip .tooltip-text {
        visibility: hidden;
        opacity: 0;
        width: 250px;
        background-color: var(--minimap-tooltip-bg);
        color: var(--minimap-tooltip-text);
        text-align: left;
        border-radius: 6px;
        padding: 8px 12px;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        margin-left: -125px;
        transition: opacity 0.2s, visibility 0.2s;
        font-size: 0.85em;
        line-height: 1.4;
        font-weight: normal;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      .info-tooltip .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: var(--minimap-tooltip-bg) transparent transparent
          transparent;
      }
      .info-tooltip:hover .tooltip-text,
      .info-tooltip:focus .tooltip-text {
        visibility: visible;
        opacity: 1;
      }

      input[type="checkbox"].custom-styled {
        opacity: 0;
        position: absolute;
        width: 1px;
        height: 1px;
      }
      .checkbox-label {
        margin-left: 0;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        position: relative;
        padding-left: 28px;
        min-height: 20px;
        user-select: none;
        color: var(--md-sys-color-on-surface-light);
      }
      .dark-theme .checkbox-label {
        color: var(--md-sys-color-on-surface-dark);
      }
      .checkbox-label::before {
        content: "";
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 18px;
        height: 18px;
        border: 1px solid var(--md-sys-color-outline-light);
        background-color: var(--md-sys-color-surface-light);
        transition: all 0.2s ease;
        border-radius: 3px;
      }
      .dark-theme .checkbox-label::before {
        border-color: var(--md-sys-color-outline-dark);
        background-color: var(--md-sys-color-surface-dark);
      }
      .checkbox-label:hover::before {
        border-color: var(--md-sys-color-primary-light);
      }
      .dark-theme .checkbox-label:hover::before {
        border-color: var(--md-sys-color-primary-dark);
      }
      input[type="checkbox"].custom-styled:focus-visible
        + .checkbox-label::before {
        outline: 2px solid var(--md-sys-color-primary-light);
        outline-offset: 2px;
      }
      .dark-theme
        input[type="checkbox"].custom-styled:focus-visible
        + .checkbox-label::before {
        outline-color: var(--md-sys-color-primary-dark);
      }
      input[type="checkbox"].custom-styled:checked + .checkbox-label::before {
        border-color: var(--md-sys-color-primary-light);
        background-color: var(--md-sys-color-primary-light);
      }
      .dark-theme
        input[type="checkbox"].custom-styled:checked
        + .checkbox-label::before {
        border-color: var(--md-sys-color-primary-dark);
        background-color: var(--md-sys-color-primary-dark);
      }
      input[type="checkbox"].custom-styled:checked + .checkbox-label::after {
        content: "";
        position: absolute;
        left: 6px;
        top: 50%;
        width: 3px;
        height: 8px;
        border: solid var(--md-sys-color-on-primary-light);
        border-width: 0 2px 2px 0;
        transform: translateY(-60%) rotate(45deg);
      }
      .dark-theme
        input[type="checkbox"].custom-styled:checked
        + .checkbox-label::after {
        border-color: var(--md-sys-color-on-primary-dark);
      }

      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .radio-option label {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        font-weight: normal;
        margin-bottom: 0;
      }
      .radio-option input[type="radio"] {
        margin-right: 8px;
        accent-color: var(--md-sys-color-primary-light);
      }
      .dark-theme .radio-option input[type="radio"] {
        accent-color: var(--md-sys-color-primary-dark);
      }

      .sub-options {
        margin-left: 20px;
        padding-left: 15px;
        border-left: 1px dashed var(--md-sys-color-outline-variant-light);
        margin-top: 10px;
        margin-bottom: 15px;
      }
      .dark-theme .sub-options {
        border-left-color: var(--md-sys-color-outline-variant-dark);
      }

      button:not([id^="md-"], .back-button-area button) {
        padding: 10px 18px;
        background-color: var(--md-sys-color-primary-light);
        color: var(--md-sys-color-on-primary-light);
        border: none;
        border-radius: 20px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 500;
        transition: background-color 0.2s ease, opacity 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        vertical-align: middle;
      }
      .dark-theme button:not([id^="md-"], .back-button-area button) {
        background-color: var(--md-sys-color-primary-dark);
        color: var(--md-sys-color-on-primary-dark);
      }
      button:not([id^="md-"], .back-button-area button):hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-primary-light) 90%,
          black
        );
      }
      .dark-theme button:not([id^="md-"], .back-button-area button):hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-primary-dark) 90%,
          white
        );
      }
      button:not([id^="md-"], .back-button-area button):disabled {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-light) 30%,
          transparent
        );
        color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-light) 50%,
          transparent
        );
        cursor: not-allowed;
        opacity: 0.7;
      }
      .dark-theme button:not([id^="md-"], .back-button-area button):disabled {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-dark) 30%,
          transparent
        );
        color: color-mix(
          in srgb,
          var(--md-sys-color-on-surface-dark) 50%,
          transparent
        );
      }

      .action-button-container {
        position: relative;
        margin-top: 15px;
      }
      .action-button-container button {
        width: 100%;
        font-size: 1.1em;
        justify-content: center;
      }
      .action-button-container .status-indicator {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.9em;
        display: flex;
        align-items: center;
        gap: 5px;
        color: var(--md-sys-color-outline-light);
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }
      .dark-theme .action-button-container .status-indicator {
        color: var(--md-sys-color-outline-dark);
      }
      .action-button-container.status-active .status-indicator {
        opacity: 1;
      }
      .action-button-container .status-indicator .material-icons {
        font-size: 1.2em;
      }

      #suggest-colors-button {
        margin-top: 5px;
      }
      #generate-mwc-components-button,
      #generate-gemini-components-button {
        margin-top: 5px;
        background-color: var(--md-sys-color-secondary-light);
        color: var(--md-sys-color-on-secondary-light);
        font-size: 0.95em;
      }
      .dark-theme #generate-mwc-components-button,
      .dark-theme #generate-gemini-components-button {
        background-color: var(--md-sys-color-secondary-dark);
        color: var(--md-sys-color-on-secondary-dark);
      }
      #generate-mwc-components-button:hover,
      #generate-gemini-components-button:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-secondary-light) 90%,
          black
        );
      }
      .dark-theme #generate-mwc-components-button:hover,
      .dark-theme #generate-gemini-components-button:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-secondary-dark) 90%,
          white
        );
      }

      #drop-area {
        border: 2px dashed var(--md-sys-color-outline-light);
        border-radius: 4px;
        padding: 25px;
        text-align: center;
        cursor: pointer;
        background-color: var(--md-sys-color-surface-variant-light);
        transition: background-color 0.2s ease, border-color 0.2s ease;
        position: relative;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .dark-theme #drop-area {
        border-color: var(--md-sys-color-outline-dark);
        background-color: var(--md-sys-color-surface-variant-dark);
      }
      #drop-area.drag-over {
        background-color: var(--md-sys-color-secondary-container-light);
        border-color: var(--md-sys-color-primary-light);
      }
      .dark-theme #drop-area.drag-over {
        background-color: var(--md-sys-color-secondary-container-dark);
        border-color: var(--md-sys-color-primary-dark);
      }
      #drop-area p {
        margin: 0;
        color: var(--md-sys-color-on-surface-variant-light);
        font-size: 0.95em;
      }
      .dark-theme #drop-area p {
        color: var(--md-sys-color-on-surface-variant-dark);
      }

      #image-preview {
        max-width: 100%;
        max-height: 150px;
        margin-top: 15px;
        border-radius: 4px;
        object-fit: contain;
        border: 1px solid var(--md-sys-color-outline-variant-light);
      }
      .dark-theme #image-preview {
        border-color: var(--md-sys-color-outline-variant-dark);
      }
      .image-options {
        margin-top: 15px;
        border-top: 1px solid var(--md-sys-color-outline-variant-light);
        padding-top: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .dark-theme .image-options {
        border-top-color: var(--md-sys-color-outline-variant-dark);
      }
      .image-options label {
        font-size: 0.85em;
        color: var(--md-sys-color-on-surface-variant-light);
      }
      .dark-theme .image-options label {
        color: var(--md-sys-color-on-surface-variant-dark);
      }
      .image-options input {
        max-width: 70px;
      }

      .output-section {
        min-height: 300px;
      }
      .output-section .placeholder {
        color: var(--md-sys-color-outline-light);
        text-align: center;
        margin-top: 60px;
        font-style: italic;
        font-size: 0.95em;
      }
      .dark-theme .output-section .placeholder {
        color: var(--md-sys-color-outline-dark);
      }
      .color-group {
        margin-bottom: 30px;
      }
      .swatch-container {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }
      .swatch {
        width: 110px;
        height: 110px;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        padding: 8px;
        font-size: 0.8em;
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(0, 0, 0, 0.08);
      }
      .swatch span {
        display: block;
        line-height: 1.3;
      }
      .swatch .swatch-name {
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .swatch .swatch-hex {
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          Courier, monospace;
        font-size: 0.9em;
        opacity: 0.9;
      }
      #seed-colors-display .swatch {
        width: 70px;
        height: 70px;
        font-size: 0.75em;
        padding: 5px;
      }
      #seed-colors-display h3 {
        border-bottom: none;
        margin-bottom: 0.5em;
      }
      .palette-section {
        margin-bottom: 20px;
      }
      .scheme-swatches {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .hidden {
        display: none !important;
      }
      .error {
        color: var(--md-sys-color-error-light);
        background-color: var(--md-sys-color-error-container-light);
        border: 1px solid
          color-mix(in srgb, var(--md-sys-color-error-light) 30%, transparent);
        padding: 12px 15px;
        border-radius: 4px;
        margin-top: 15px;
        font-size: 0.9em;
      }
      .dark-theme .error {
        color: var(--md-sys-color-error-dark);
        background-color: var(--md-sys-color-error-container-dark);
        border-color: color-mix(
          in srgb,
          var(--md-sys-color-error-dark) 30%,
          transparent
        );
      }
      #loading-indicator,
      #suggestion-loading-indicator,
      #gemini-component-loading {
        text-align: center;
        padding: 15px 10px;
        color: var(--md-sys-color-outline-light);
        font-style: italic;
        font-size: 0.95em;
      }
      .dark-theme #loading-indicator,
      .dark-theme #suggestion-loading-indicator,
      .dark-theme #gemini-component-loading {
        color: var(--md-sys-color-outline-dark);
      }

      #text-prompt-options {
        margin: 10px 0 5px 0;
        font-size: 0.85em;
      }
      #text-prompt-suggestions,
      #image-prompt-suggestions {
        margin-top: 20px;
        border-top: 1px solid var(--md-sys-color-outline-variant-light);
        padding-top: 20px;
      }
      .dark-theme #text-prompt-suggestions,
      .dark-theme #image-prompt-suggestions {
        border-top-color: var(--md-sys-color-outline-variant-dark);
      }
      #text-prompt-suggestions > .selection-group-label,
      #image-prompt-suggestions > .selection-group-label {
        display: block;
        margin-bottom: 12px;
        font-weight: 500;
        font-size: 0.9em;
        color: var(--md-sys-color-on-surface-variant-light);
      }
      .dark-theme #text-prompt-suggestions > .selection-group-label,
      .dark-theme #image-prompt-suggestions > .selection-group-label {
        color: var(--md-sys-color-on-surface-variant-dark);
      }
      .suggestion-option {
        padding: 10px 12px;
        border: 1px solid var(--md-sys-color-outline-light);
        border-radius: 4px;
        margin-bottom: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background-color 0.2s ease, border-color 0.2s ease;
        background-color: var(--md-sys-color-surface-light);
      }
      .dark-theme .suggestion-option {
        border-color: var(--md-sys-color-outline-dark);
        background-color: var(--md-sys-color-surface-dark);
      }
      .suggestion-option:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-primary-light) 8%,
          transparent
        );
        border-color: var(--md-sys-color-primary-light);
      }
      .dark-theme .suggestion-option:hover {
        background-color: color-mix(
          in srgb,
          var(--md-sys-color-primary-dark) 8%,
          transparent
        );
        border-color: var(--md-sys-color-primary-dark);
      }
      .suggestion-option.selected {
        border-color: var(--md-sys-color-primary-light);
        background-color: var(--md-sys-color-primary-container-light);
        outline: 1px solid var(--md-sys-color-primary-light);
      }
      .dark-theme .suggestion-option.selected {
        border-color: var(--md-sys-color-primary-dark);
        background-color: var(--md-sys-color-primary-container-dark);
        outline-color: var(--md-sys-color-primary-dark);
      }
      .suggestion-option.selected span:not(.suggestion-swatch) {
        font-weight: 600;
        color: var(--md-sys-color-on-primary-container-light);
      }
      .dark-theme .suggestion-option.selected span:not(.suggestion-swatch) {
        color: var(--md-sys-color-on-primary-container-dark);
      }
      .suggestion-option input[type="radio"] {
        opacity: 0;
        width: 1px;
        height: 1px;
        position: absolute;
      }
      .suggestion-option label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        width: 100%;
        margin: 0;
        font-weight: normal;
        color: var(--md-sys-color-on-surface-light);
      }
      .dark-theme .suggestion-option label {
        color: var(--md-sys-color-on-surface-dark);
      }
      .suggestion-swatch {
        width: 22px;
        height: 22px;
        border-radius: 3px;
        border: 1px solid var(--md-sys-color-outline-variant-light);
        display: inline-block;
        flex-shrink: 0;
      }
      .dark-theme .suggestion-swatch {
        border-color: var(--md-sys-color-outline-variant-dark);
      }

      #component-examples {
        margin-top: 30px;
        border-top: 1px solid var(--md-sys-color-outline-variant-light);
        padding-top: 25px;
      }
      .dark-theme #component-examples {
        border-top-color: var(--md-sys-color-outline-variant-dark);
      }

      #component-examples h3 {
        border-bottom: none;
        margin-bottom: 15px;
      }
      .component-generation-options {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 15px;
      }
      .component-generation-options .input-group {
        margin-bottom: 0;
        width: 100%;
      }
      .component-buttons-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
      }
      .component-preview-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      .component-preview-area {
        display: flex;
        flex-direction: column;
        gap: 15px;
        padding: 25px;
        border-radius: 8px;
        border: 1px solid var(--md-sys-color-outline-variant-light);
        background-color: var(--md-sys-color-background-light);
        color: var(--md-sys-color-on-background-light);
        transition: background-color 0.3s ease, color 0.3s ease,
          border-color 0.3s ease;
        min-height: 300px;
        background-color: var(
          --local-sys-color-background,
          var(--md-sys-color-background-light)
        );
        color: var(
          --local-sys-color-on-background,
          var(--md-sys-color-on-background-light)
        );
        border-color: var(
          --local-sys-color-outline-variant,
          var(--md-sys-color-outline-variant-light)
        );
      }
      .component-preview-area.dark-theme {
        background-color: var(
          --local-sys-color-background,
          var(--md-sys-color-background-dark)
        );
        color: var(
          --local-sys-color-on-background,
          var(--md-sys-color-on-background-dark)
        );
        border-color: var(
          --local-sys-color-outline-variant,
          var(--md-sys-color-outline-variant-dark)
        );
      }
      .component-preview-area h4 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-light)
        );
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.2em;
      }
      .dark-theme .component-preview-area h4 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-dark)
        );
      }
      .component-preview-area h5 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-light)
        );
        margin-bottom: 10px;
        font-size: 1em;
      }
      .dark-theme .component-preview-area h5 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-dark)
        );
      }

      #mwc-component-preview md-filled-button,
      #mwc-component-preview md-outlined-button,
      #mwc-component-preview md-fab,
      #mwc-component-preview md-chip-set md-assist-chip,
      #mwc-component-preview md-chip-set md-filter-chip,
      #mwc-component-preview md-chip-set md-suggestion-chip,
      #mwc-component-preview md-slider,
      #mwc-component-preview md-card {
        --md-sys-color-primary: var(--local-sys-color-primary);
        --md-sys-color-on-primary: var(--local-sys-color-on-primary);
        --md-sys-color-primary-container: var(
          --local-sys-color-primary-container
        );
        --md-sys-color-on-primary-container: var(
          --local-sys-color-on-primary-container
        );
        --md-sys-color-secondary: var(--local-sys-color-secondary);
        --md-sys-color-on-secondary: var(--local-sys-color-on-secondary);
        --md-sys-color-secondary-container: var(
          --local-sys-color-secondary-container
        );
        --md-sys-color-on-secondary-container: var(
          --local-sys-color-on-secondary-container
        );
        --md-sys-color-tertiary: var(--local-sys-color-tertiary);
        --md-sys-color-on-tertiary: var(--local-sys-color-on-tertiary);
        --md-sys-color-tertiary-container: var(
          --local-sys-color-tertiary-container
        );
        --md-sys-color-on-tertiary-container: var(
          --local-sys-color-on-tertiary-container
        );
        --md-sys-color-error: var(--local-sys-color-error);
        --md-sys-color-on-error: var(--local-sys-color-on-error);
        --md-sys-color-error-container: var(--local-sys-color-error-container);
        --md-sys-color-on-error-container: var(
          --local-sys-color-on-error-container
        );
        --md-sys-color-surface: var(--local-sys-color-surface);
        --md-sys-color-on-surface: var(--local-sys-color-on-surface);
        --md-sys-color-surface-variant: var(--local-sys-color-surface-variant);
        --md-sys-color-on-surface-variant: var(
          --local-sys-color-on-surface-variant
        );
        --md-sys-color-outline: var(--local-sys-color-outline);
        --md-sys-color-outline-variant: var(--local-sys-color-outline-variant);
        --md-sys-color-inverse-surface: var(--local-sys-color-inverse-surface);
        --md-sys-color-inverse-on-surface: var(
          --local-sys-color-inverse-on-surface
        );
        --md-sys-color-inverse-primary: var(--local-sys-color-inverse-primary);
        --md-sys-color-background: var(--local-sys-color-background);
        --md-sys-color-on-background: var(--local-sys-color-on-background);
      }

      #mwc-component-preview md-card p {
        color: var(
          --local-sys-color-on-surface-variant,
          var(--md-sys-color-on-surface-variant-light)
        );
      }
      .dark-theme #mwc-component-preview md-card p {
        color: var(
          --local-sys-color-on-surface-variant,
          var(--md-sys-color-on-surface-variant-dark)
        );
      }

      #gemini-component-preview {
        font-family: var(--comp-font-family);
        line-height: 1.6;
        color: var(
          --local-sys-color-on-background,
          var(--md-sys-color-on-background-light)
        );
      }
      .dark-theme #gemini-component-preview {
        color: var(
          --local-sys-color-on-background,
          var(--md-sys-color-on-background-dark)
        );
      }

      #gemini-component-preview h1,
      #gemini-component-preview h2,
      #gemini-component-preview h3,
      #gemini-component-preview h4,
      #gemini-component-preview h5 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-light)
        );
        margin-bottom: 0.8em;
        font-weight: 600;
      }
      .dark-theme #gemini-component-preview h1,
      .dark-theme #gemini-component-preview h2,
      .dark-theme #gemini-component-preview h3,
      .dark-theme #gemini-component-preview h4,
      .dark-theme #gemini-component-preview h5 {
        color: var(
          --local-sys-color-on-surface,
          var(--md-sys-color-on-surface-dark)
        );
      }
      #gemini-component-preview p,
      #gemini-component-preview li {
        color: var(
          --local-sys-color-on-surface-variant,
          var(--md-sys-color-on-surface-variant-light)
        );
        margin-bottom: 1em;
      }
      .dark-theme #gemini-component-preview p,
      .dark-theme #gemini-component-preview li {
        color: var(
          --local-sys-color-on-surface-variant,
          var(--md-sys-color-on-surface-variant-dark)
        );
      }
      #gemini-component-preview code {
        background-color: #f0f0f0;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          Courier, monospace;
        font-size: 0.9em;
        color: #111;
        border: 1px solid #e0e0e0;
      }
      .dark-theme #gemini-component-preview code {
        background-color: #333;
        color: #eee;
        border-color: #555;
      }
      #gemini-component-preview a {
        color: var(
          --local-sys-color-primary,
          var(--md-sys-color-primary-light)
        );
        text-decoration: none;
      }
      .dark-theme #gemini-component-preview a {
        color: var(--local-sys-color-primary, var(--md-sys-color-primary-dark));
      }
      #gemini-component-preview a:hover {
        text-decoration: underline;
      }

      #dynamic-theme-styles {
        display: none;
      }

      @media (max-width: 960px) {
        .main-content-grid {
          grid-template-columns: 1fr;
        }
        #workflow-minimap {
          grid-row: auto;
          grid-column: auto;
          width: auto;
          max-width: calc(100vw - 40px);
          font-size: 9px;
          padding: 6px 8px;
          margin-top: 20px;
        }
        #theme-toggle {
          top: 10px;
          right: 15px;
        }
        .minimap-tooltip {
          max-width: 220px;
          font-size: 10px;
          transform: translateX(0);
        }
        .minimap-node:hover .minimap-tooltip,
        .minimap-edge:hover .minimap-tooltip,
        .minimap-node:focus .minimap-tooltip,
        .minimap-edge:focus .minimap-tooltip {
          transform: translateY(calc(100% + 8px));
        }
      }
      @media (max-width: 1124px) {
        .component-preview-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <button id="theme-toggle" title="Toggle Light/Dark Mode">
      <span class="material-icons"></span>
    </button>

    <div class="container">
      <h1>
        MILCHICK: Material Integration Leveraging Creative Human-LLM
        Intelligence Colors Kit
      </h1>
      <p>
        Generate Material Design 3 color palettes from colors, images, or text
        prompts. Uses a pure js fork of
        <a
          href="https://github.com/material-foundation/material-color-utilities/tree/main/typescript"
          target="_blank"
          rel="noopener"
          >material-color-utilities</a
        >
        via <code>dream.js</code>.
      </p>

      <div class="main-content-grid">
        <div class="phases-container">
          <div
            class="phase-card input-section phase-human-decision"
            id="phase-1-card"
          >
            <div class="back-button-area hidden">
              <button id="back-button" type="button">Back</button>
            </div>
            <h2>Phase 1: Input & Configuration</h2>

            <fieldset>
              <legend>Input Source</legend>
              <div
                class="chip-selection-group"
                id="input-source-selection"
                data-name="inputSource"
              >
                <div>
                  <input
                    type="radio"
                    id="sourceText"
                    name="inputSource"
                    value="text"
                    checked
                  />
                  <label for="sourceText" title="Use a text prompt"
                    >Text Prompt</label
                  >
                </div>
                <div>
                  <input
                    type="radio"
                    id="sourceColor"
                    name="inputSource"
                    value="color"
                  />
                  <label for="sourceColor" title="Use color pickers"
                    >Color Picker</label
                  >
                </div>
                <div id="sourceImage-container">
                  <input
                    type="radio"
                    id="sourceImage"
                    name="inputSource"
                    value="image"
                  />
                  <label for="sourceImage" title="Use an image"
                    >Image Upload</label
                  >
                </div>
              </div>
            </fieldset>

            <div id="text-options-group" class="input-group">
              <fieldset>
                <legend>Text Prompt Options</legend>
                <div class="input-group">
                  <label for="text-prompt-input">Describe your theme:</label>
                  <textarea
                    id="text-prompt-input"
                    rows="3"
                    placeholder="e.g., calm ocean sunset, vibrant forest floor..."
                  ></textarea>
                </div>
                <div class="input-group">
                  <span class="selection-group-label"
                    >Seed Count:
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text"
                        >Choose whether to generate one seed color or three
                        distinct seed colors from your text prompt.</span
                      >
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="text-seed-count-selection"
                    data-name="textSeedCount"
                  >
                    <div>
                      <input
                        type="radio"
                        id="textSeedCountSingle"
                        name="textSeedCount"
                        value="single"
                        checked
                      />
                      <label for="textSeedCountSingle">Single Seed</label>
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="textSeedCountMulti"
                        name="textSeedCount"
                        value="multi"
                      />
                      <label for="textSeedCountMulti">Multiple Seeds (3)</label>
                    </div>
                  </div>
                </div>
                <div class="input-group">
                  <span class="selection-group-label"
                    >Selection Method:
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text">
                        <b>Gemini Suggests, User Selects:</b> Gemini proposes
                        color sets, you choose one. Requires clicking 'Process
                        Prompt'.<br />
                        <b>Gemini Suggests, Gemini Selects:</b> Gemini proposes
                        and automatically chooses the best set. Requires
                        clicking 'Generate'.<br />
                        <b>Gemini Selects & Dream.js (MCP):</b> Gemini proposes,
                        selects, and triggers Dream.js generation automatically
                        via MCP. Requires clicking 'Generate'.
                      </span>
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="text-selection-method-selection"
                    data-name="textSelectionMethod"
                  >
                    <div>
                      <input
                        type="radio"
                        id="textSelectUser"
                        name="textSelectionMethod"
                        value="user"
                        checked
                      />
                      <label for="textSelectUser"
                        >Gemini Suggests, User Selects</label
                      >
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="textSelectGemini"
                        name="textSelectionMethod"
                        value="gemini"
                      />
                      <label for="textSelectGemini"
                        >Gemini Suggests, Gemini Selects</label
                      >
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="textSelectGeminiMCP"
                        name="textSelectionMethod"
                        value="gemini_mcp"
                      />
                      <label for="textSelectGeminiMCP"
                        >Gemini Selects & Dream.js (MCP)</label
                      >
                    </div>
                  </div>
                </div>
                <div id="text-prompt-suggestions" class="hidden sub-options">
                  <span class="selection-group-label"
                    >Select a suggested color set:</span
                  >
                  <p
                    style="
                      font-size: 0.8em;
                      color: var(--md-sys-color-outline-light);
                      margin-top: -5px;
                      margin-bottom: 10px;
                    "
                  >
                    Suggestions appear after clicking "Process Prompt".
                  </p>
                  <div id="suggestions-list"></div>
                  <div id="suggestion-loading-indicator" class="hidden">
                    Getting suggestions...
                  </div>
                </div>
                <div id="text-prompt-actions">
                  <button type="button" id="process-text-button" class="hidden">
                    Process Prompt
                  </button>
                  <div
                    id="text-prompt-sim-option"
                    style="margin-top: 10px; display: inline-flex"
                  >
                    <input
                      type="checkbox"
                      id="use-gemini-simulation"
                      class="custom-styled"
                    />
                    <label for="use-gemini-simulation" class="checkbox-label"
                      >Use Simulation (Offline)</label
                    >
                  </div>
                </div>
              </fieldset>
            </div>

            <div id="color-options-group" class="input-group hidden">
              <fieldset>
                <legend>Color Picker Options</legend>
                <div class="input-group">
                  <span class="selection-group-label"
                    >Seed Count:
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text"
                        >Choose whether to use one source color or multiple
                        colors for generation.</span
                      >
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="color-seed-count-selection"
                    data-name="colorSeedCount"
                  >
                    <div>
                      <input
                        type="radio"
                        id="colorSeedCountSingle"
                        name="colorSeedCount"
                        value="single"
                        checked
                      />
                      <label for="colorSeedCountSingle"
                        >Single Source Color</label
                      >
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="colorSeedCountMulti"
                        name="colorSeedCount"
                        value="multi"
                      />
                      <label for="colorSeedCountMulti"
                        >Multiple Source Colors (Max 3)</label
                      >
                    </div>
                  </div>
                </div>
                <div id="source-color-area" class="input-group">
                  <label id="source-color-label">Source Color:</label>
                  <div id="source-color-inputs"></div>
                </div>
                <div id="multi-source-options" class="input-group hidden">
                  <label for="harmonyStrategy"
                    >Multi-Color Strategy (Dream.js):
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text">
                        <b>Direct:</b> Uses the selected colors directly as
                        Primary/Secondary/Tertiary seeds.<br />
                        <b>Harmonized:</b> Adjusts the secondary/tertiary colors
                        to harmonize better with the primary seed.
                      </span>
                    </span>
                  </label>
                  <select id="harmonyStrategy">
                    <option value="direct" selected>Direct</option>
                    <option value="harmonized">Harmonized</option>
                  </select>
                </div>
              </fieldset>
            </div>

            <div id="image-options-group" class="input-group hidden">
              <fieldset>
                <legend>Image Upload Options</legend>
                <div class="input-group">
                  <label>Upload or Drop Image:</label>
                  <div id="drop-area">
                    <p>Drag & Drop or click</p>
                    <input
                      type="file"
                      id="image-input"
                      accept="image/*"
                      hidden
                    />
                    <img
                      id="image-preview"
                      src="#"
                      alt="Preview"
                      class="hidden"
                    />
                  </div>
                </div>
                <div class="input-group">
                  <span class="selection-group-label"
                    >Extraction Method:
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text">
                        <b>Dream.js Extraction:</b> Uses the local library to
                        extract prominent colors from the image.<br />
                        <b>Gemini Extraction:</b> Uses the Gemini API to analyze
                        the image and suggest colors.
                      </span>
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="image-extraction-method-selection"
                    data-name="imageExtractionMethod"
                  >
                    <div>
                      <input
                        type="radio"
                        id="imageExtractDream"
                        name="imageExtractionMethod"
                        value="dream"
                        checked
                      />
                      <label for="imageExtractDream">Dream.js Extraction</label>
                    </div>
                    <div id="imageExtractGemini-container">
                      <input
                        type="radio"
                        id="imageExtractGemini"
                        name="imageExtractionMethod"
                        value="gemini"
                      />
                      <label for="imageExtractGemini">Gemini Extraction</label>
                    </div>
                  </div>
                </div>
                <div class="input-group">
                  <span class="selection-group-label"
                    >Seed Count:
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text"
                        >Choose whether to extract/suggest one seed color or
                        multiple seed colors from the image.</span
                      >
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="image-seed-count-selection"
                    data-name="imageSeedCount"
                  >
                    <div>
                      <input
                        type="radio"
                        id="imageSeedCountSingle"
                        name="imageSeedCount"
                        value="single"
                        checked
                      />
                      <label for="imageSeedCountSingle">Single Seed</label>
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="imageSeedCountMulti"
                        name="imageSeedCount"
                        value="multi"
                      />
                      <label for="imageSeedCountMulti"
                        >Multiple Seeds (Max 3)</label
                      >
                    </div>
                  </div>
                </div>
                <div id="image-dream-options" class="sub-options">
                  <label for="numSources">Max Colors (Dream.js):</label>
                  <input
                    type="number"
                    id="numSources"
                    value="3"
                    min="1"
                    max="5"
                    style="max-width: 70px"
                  />
                  <label for="extractQuality" style="margin-left: 10px"
                    >Quality (1=Best, Dream.js):</label
                  >
                  <input
                    type="number"
                    id="extractQuality"
                    value="10"
                    min="1"
                    max="50"
                    style="max-width: 70px"
                  />
                </div>
                <div id="image-gemini-options" class="sub-options hidden">
                  <span class="selection-group-label"
                    >Selection Method (Gemini):
                    <span class="info-tooltip" tabindex="0">
                      <span class="material-icons">info_outline</span>
                      <span class="tooltip-text">
                        <b>Gemini Suggests, User Selects:</b> Gemini proposes
                        color sets, you choose one. Requires clicking 'Process
                        Image'.<br />
                        <b>Gemini Suggests, Gemini Selects:</b> Gemini proposes
                        and automatically chooses the best set. Requires
                        clicking 'Generate'.<br />
                        <b>Gemini Selects & Dream.js (MCP):</b> Gemini proposes,
                        selects, and triggers Dream.js generation automatically
                        via MCP. Requires clicking 'Generate'.
                      </span>
                    </span>
                  </span>
                  <div
                    class="chip-selection-group"
                    id="image-selection-method-selection"
                    data-name="imageSelectionMethod"
                  >
                    <div>
                      <input
                        type="radio"
                        id="imageSelectUser"
                        name="imageSelectionMethod"
                        value="user"
                        checked
                      />
                      <label for="imageSelectUser"
                        >Gemini Suggests, User Selects</label
                      >
                    </div>
                    <div>
                      <input
                        type="radio"
                        id="imageSelectGemini"
                        name="imageSelectionMethod"
                        value="gemini"
                      />
                      <label for="imageSelectGemini"
                        >Gemini Suggests, Gemini Selects</label
                      >
                    </div>
                    <div id="imageSelectGeminiMCP-container">
                      <input
                        type="radio"
                        id="imageSelectGeminiMCP"
                        name="imageSelectionMethod"
                        value="gemini_mcp"
                      />
                      <label for="imageSelectGeminiMCP"
                        >Gemini Selects & Dream.js (MCP)</label
                      >
                    </div>
                  </div>
                  <div id="image-prompt-suggestions" class="hidden sub-options">
                    <span class="selection-group-label"
                      >Select a suggested color set:</span
                    >
                    <p
                      style="
                        font-size: 0.8em;
                        color: var(--md-sys-color-outline-light);
                        margin-top: -5px;
                        margin-bottom: 10px;
                      "
                    >
                      Suggestions appear after processing image with Gemini.
                    </p>
                    <div id="image-suggestions-list"></div>
                    <div id="image-suggestion-loading-indicator" class="hidden">
                      Getting suggestions...
                    </div>
                  </div>
                  <button
                    type="button"
                    id="process-image-gemini-button"
                    style="margin-top: 10px"
                    class="hidden"
                  >
                    Process Image with Gemini
                  </button>
                </div>
              </fieldset>
            </div>

            <div class="input-group">
              <span class="selection-group-label"
                >Palette Generation Method:
                <span class="info-tooltip" tabindex="0">
                  <span class="material-icons">info_outline</span>
                  <span class="tooltip-text">
                    <b>Invoke Dream.js:</b> Generate the palette using the local
                    Dream.js library based on the selected/input seeds. (Human
                    triggers tool)<br />
                    <b>Gemini Invoke Dream.js (MCP):</b> Gemini selects seeds
                    (if applicable) and instructs the system (via MCP) to use
                    Dream.js for generation. (LLM triggers tool)<br />
                    <b>Manual MCP (Simulate Fail):</b> Simulate the MCP flow
                    triggering Dream.js, but introduce a chance of simulated
                    failure. Useful for testing error handling.<br />
                    <b>Gemini Only (No Dream.js):</b> Request Gemini to generate
                    the entire color palette JSON directly based on
                    seeds/context, bypassing Dream.js. (LLM generates result
                    directly)
                  </span>
                </span>
              </span>
              <div
                class="chip-selection-group"
                id="palette-generation-method-selection"
                data-name="paletteGenerationMethod"
              >
                <div>
                  <input
                    type="radio"
                    id="genMethodDreamJS"
                    name="paletteGenerationMethod"
                    value="dreamjs"
                    checked
                  />
                  <label for="genMethodDreamJS">Invoke Dream.js</label>
                </div>
                <div>
                  <input
                    type="radio"
                    id="genMethodGeminiMCP"
                    name="paletteGenerationMethod"
                    value="gemini_mcp"
                  />
                  <label for="genMethodGeminiMCP"
                    >Gemini Invoke Dream.js (MCP)</label
                  >
                </div>
                <div>
                  <input
                    type="radio"
                    id="genMethodManualMCP"
                    name="paletteGenerationMethod"
                    value="manual_mcp"
                  />
                  <label for="genMethodManualMCP"
                    >Manual MCP (Simulate Fail)</label
                  >
                </div>
                <div>
                  <input
                    type="radio"
                    id="genMethodGeminiOnly"
                    name="paletteGenerationMethod"
                    value="gemini_only"
                  />
                  <label for="genMethodGeminiOnly"
                    >Gemini Only (No Dream.js)</label
                  >
                </div>
              </div>
            </div>

            <div id="generate-button-container" class="action-button-container">
              <button type="button" id="generate-button">Generate Theme</button>
              <span class="status-indicator">
                <span class="material-icons" title="Action performed by Gemini"
                  >smart_toy</span
                >
                <span>Auto</span>
              </span>
            </div>
            <div id="loading-indicator" class="hidden">Generating theme...</div>
            <div id="error-message" class="error hidden"></div>
          </div>

          <div
            class="phase-card output-section phase-local-tool"
            id="phase-2-card"
          >
            <h2>Generated Theme</h2>
            <div id="seed-colors-display" class="color-group">
              <h3>Seed Color(s) Used</h3>
              <div class="swatch-container">
                <p class="placeholder">Seeds appear here.</p>
              </div>
            </div>
            <hr
              style="
                border: none;
                border-top: 1px solid var(--md-sys-color-outline-variant-light);
                margin: 25px 0;
              "
              class="theme-divider"
            />
            <div id="palette-display">
              <p class="placeholder">
                Configure inputs and click Generate/Process.
              </p>
            </div>

            <div id="component-examples" class="hidden">
              <hr
                style="
                  border: none;
                  border-top: 1px solid
                    var(--md-sys-color-outline-variant-light);
                  margin: 25px 0;
                "
                class="theme-divider"
              />
              <h3>Component Examples</h3>
              <span class="selection-group-label"
                >Component Generation Options:
                <span class="info-tooltip" tabindex="0">
                  <span class="material-icons">info_outline</span>
                  <span class="tooltip-text">
                    <b>Generate Deterministic:</b> Renders standard Material Web
                    Components using the generated theme.<br />
                    <b>Generate Gemini Created:</b> Asks Gemini to generate
                    styled HTML components based on the theme and an optional
                    style prompt. Uses local colors, can incorporate M3
                    Guidance.
                  </span>
                </span>
              </span>
              <div class="component-generation-options">
                <div class="input-group">
                  <label for="component-style-prompt"
                    >Optional Gemini Style Prompt:</label
                  >
                  <input
                    type="text"
                    id="component-style-prompt"
                    placeholder="e.g., modern and clean, playful, brutalist..."
                  />
                </div>
                <div class="component-buttons-container">
                  <button
                    type="button"
                    id="generate-mwc-components-button"
                    title="Apply theme to standard Material Web Components"
                  >
                    Generate deterministic component set
                  </button>
                  <button
                    type="button"
                    id="generate-gemini-components-button"
                    title="Use Gemini to generate styled HTML based on the theme and your style prompt"
                  >
                    Generate gemini created component set
                  </button>
                  <div id="m3-guidance-option-container">
                    <input
                      type="checkbox"
                      id="use-m3-guidance-checkbox"
                      class="custom-styled"
                      checked
                    />
                    <label
                      for="use-m3-guidance-checkbox"
                      class="checkbox-label"
                    >
                      Use M3 Guidance for Gemini Components
                    </label>
                  </div>
                </div>
              </div>
              <div id="gemini-component-loading" class="hidden">
                Generating Gemini components...
              </div>

              <div class="component-preview-grid">
                <div class="component-preview-area" id="mwc-component-preview">
                  <h4>MWC Preview</h4>
                  <p class="placeholder">
                    Click "Gen Deterministic" to preview.
                  </p>
                </div>
                <div
                  class="component-preview-area"
                  id="gemini-component-preview"
                >
                  <h4>Gemini Preview</h4>
                  <p class="placeholder">Click "Gen Gemini Comp" to preview.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="phase-card phase-card-placeholder">
            Phase 3: Generate mini app placeholder
          </div>
          <div class="phase-card phase-card-placeholder">
            Phase 4: Adapt mini app as to laser / hologram / projection
            placeholder
          </div>
        </div>

        <div id="workflow-minimap">
          <div id="minimap-title">Workflow Path</div>
          <div id="minimap-content"></div>
        </div>
      </div>
    </div>

    <style id="dynamic-theme-styles"></style>
    <script src="config.js" defer></script>
    <script src="dream.js" defer></script>
    <script
      type="module"
      src="https://cdn.skypack.dev/@material/web/all.js"
      defer
    ></script>
    <script type="module" defer>
      const $ = (selector) => document.querySelector(selector);
      const $$ = (selector) => document.querySelectorAll(selector);
      const getEl = (id) => document.getElementById(id);
      const createEl = (tag) => document.createElement(tag);
      const toggleClass = (el, className, force) =>
        el?.classList.toggle(className, force);
      const setAttr = (el, attr, value) => el?.setAttribute(attr, value);
      const removeAttr = (el, attr) => el?.removeAttribute(attr);
      const setText = (el, text) => {
        if (el) el.textContent = text;
      };
      const setHtml = (el, html) => {
        if (el) el.innerHTML = html;
      };
      const disableEl = (el, disabled) => {
        if (el) el.disabled = disabled;
      };
      const hideEl = (el, hide = true) => toggleClass(el, "hidden", hide);

      const config = {
        API_KEY: null,
        GEMINI_MODEL: null,
        GEMINI_MODEL_COLOR_PICKER: null,
        GEMINI_MODEL_COMPONENT_GENERATOR: null,
        USE_M3_TXT_SYS_PROMPT: false,
        ENABLE_IMAGES: true,
        isApiConfigValid: false,
        geminiApiEndpointBase: "",
        geminiApiEndpointColorPicker: "",
        geminiApiEndpointComponentGenerator: "",
        defaultInputSource: "text",
        ENABLE_AUTO_MODES: true,
        MINIMAP_STEP_DELAY: 1000,
        MINIMAP_ANIMATION_DURATION: 400,
      };

      const state = {
        currentImageFile: null,
        currentInputSource: config.defaultInputSource,
        lastGeneratedTheme: null,
        isDarkMode: false,
        m3ContentCache: null,
        currentMinimapSteps: [],
        minimapUpdateQueue: [],
        isMinimapUpdating: false,
        lastSuggestions: { text: null, image: null },
        selectedSuggestion: { text: null, image: null },
        generationMethod: "dreamjs",
        history: [],
        currentPhaseCardId: null,
      };

      const dom = {
        inputSourceRadios: $$('input[name="inputSource"]'),
        inputSourceSelection: getEl("input-source-selection"),
        textOptionsGroup: getEl("text-options-group"),
        colorOptionsGroup: getEl("color-options-group"),
        imageOptionsGroup: getEl("image-options-group"),
        textPromptInput: getEl("text-prompt-input"),
        textSeedCountSelection: getEl("text-seed-count-selection"),
        textSelectionMethodSelection: getEl("text-selection-method-selection"),
        processTextButton: getEl("process-text-button"),
        textPromptSuggestions: getEl("text-prompt-suggestions"),
        suggestionsList: getEl("suggestions-list"),
        suggestionLoadingIndicator: getEl("suggestion-loading-indicator"),
        useSimulationCheckbox: getEl("use-gemini-simulation"),
        textSelectGeminiMCPInput: getEl("textSelectGeminiMCP"),
        textPromptSimOption: getEl("text-prompt-sim-option"),
        colorSeedCountSelection: getEl("color-seed-count-selection"),
        sourceColorArea: getEl("source-color-area"),
        sourceColorLabel: getEl("source-color-label"),
        sourceColorInputsContainer: getEl("source-color-inputs"),
        multiSourceOptionsArea: getEl("multi-source-options"),
        harmonyStrategySelect: getEl("harmonyStrategy"),
        sourceImageContainer: getEl("sourceImage-container"),
        imageInput: getEl("image-input"),
        dropArea: getEl("drop-area"),
        imagePreview: getEl("image-preview"),
        imageExtractionMethodSelection: getEl(
          "image-extraction-method-selection"
        ),
        imageSeedCountSelection: getEl("image-seed-count-selection"),
        imageDreamOptions: getEl("image-dream-options"),
        imageGeminiOptions: getEl("image-gemini-options"),
        imageSelectGeminiMCPContainer: getEl("imageSelectGeminiMCP-container"),
        imagePromptSuggestions: getEl("image-prompt-suggestions"),
        imageSuggestionsList: getEl("image-suggestions-list"),
        imageSuggestionLoadingIndicator: getEl(
          "image-suggestion-loading-indicator"
        ),
        processImageGeminiButton: getEl("process-image-gemini-button"),
        imageExtractGeminiContainer: getEl("imageExtractGemini-container"),
        numSourcesInput: getEl("numSources"),
        extractQualityInput: getEl("extractQuality"),
        generateButton: getEl("generate-button"),
        generateButtonContainer: getEl("generate-button-container"),
        loadingIndicator: getEl("loading-indicator"),
        errorMessageDiv: getEl("error-message"),
        seedColorsDisplayContainer: getEl("seed-colors-display").querySelector(
          ".swatch-container"
        ),
        paletteDisplay: getEl("palette-display"),
        componentExamplesDiv: getEl("component-examples"),
        generateMwcComponentsButton: getEl("generate-mwc-components-button"),
        generateGeminiComponentsButton: getEl(
          "generate-gemini-components-button"
        ),
        componentStylePromptInput: getEl("component-style-prompt"),
        geminiComponentLoadingIndicator: getEl("gemini-component-loading"),
        mwcComponentPreview: getEl("mwc-component-preview"),
        geminiComponentPreview: getEl("gemini-component-preview"),
        dynamicThemeStyles: getEl("dynamic-theme-styles"),
        bodyElement: document.body,
        themeToggleButton: getEl("theme-toggle"),
        themeToggleIcon: getEl("theme-toggle").querySelector(".material-icons"),
        minimapContent: getEl("minimap-content"),
        useM3GuidanceCheckbox: getEl("use-m3-guidance-checkbox"),
        m3GuidanceOptionContainer: getEl("m3-guidance-option-container"),
        paletteGenerationMethodSelection: getEl(
          "palette-generation-method-selection"
        ),
        backButton: getEl("back-button"),
        backButtonArea: $(".back-button-area"),
        phase1Card: getEl("phase-1-card"),
        phase2Card: getEl("phase-2-card"),
      };

      const placeholders = {
        palette:
          '<p class="placeholder">Configure inputs and click Generate/Process.</p>',
        seeds: '<p class="placeholder">Seeds appear here.</p>',
        noPalettes: '<p class="placeholder error">Invalid theme generated.</p>',
        noSuggestions:
          '<p style="color: var(--md-sys-color-outline-light); font-size: 0.9em;">No valid suggestions generated.</p>',
        noValidSuggestions:
          '<p style="color: var(--md-sys-color-outline-light);">No valid suggestions could be displayed.</p>',
        suggestionsLabelText:
          "<span class='selection-group-label'>Select a suggested color set:</span>",
        suggestionsLabelImage:
          "<span class='selection-group-label'>Select a suggested color set:</span>",
        suggestionsApiError:
          '<p class="error">API not configured or suggestion failed.</p>',
        suggestionsLoadError:
          '<p class="error">Failed to load suggestions.</p>',
        mwcPreview:
          '<h4>MWC Preview</h4><p class="placeholder">Click "Gen Deterministic" to preview.</p>',
        geminiPreview:
          '<h4>Gemini Preview</h4><p class="placeholder">Click "Gen Gemini Comp" to preview.</p>',
        geminiPreviewError:
          '<h4 class="error">Gemini Preview</h4><p class="error">Failed to generate components via Gemini.</p>',
        generating: '<p class="placeholder">Generating theme...</p>',
        paletteError:
          '<p class="placeholder error">Error generating theme.</p>',
        seedUnavailable:
          '<p style="font-size:0.9em;color:var(--md-sys-color-outline-light);">Seed colors unavailable.</p>',
      };

      const workflowSteps = {
        START: {
          id: "start",
          label: "Start",
          type: "start",
          description: "Workflow begins.",
          code: "initializeApp()",
          stepNo: 1,
        },
        SELECT_SOURCE: {
          id: "select_source",
          label: "Select Source",
          type: "human",
          description: "User chooses input source (Text, Color, Image).",
          code: "handleInputSourceChange()",
          stepNo: 2,
        },
        INPUT_TEXT: {
          id: "input_text",
          label: "Input Text",
          type: "human",
          description: "User types a theme description.",
          code: "dom.textPromptInput.value",
          stepNo: 3,
        },
        SELECT_TEXT_SEED_COUNT: {
          id: "select_text_seed",
          label: "Select Text Seed #",
          type: "human",
          description: "User chooses single/multi seed for text.",
          code: "handleOptionChange()",
          stepNo: 4,
        },
        SELECT_TEXT_METHOD: {
          id: "select_text_method",
          label: "Select Text Method",
          type: "human",
          description: "User chooses suggestion/selection method.",
          code: "handleOptionChange()",
          stepNo: 5,
        },
        CLICK_PROCESS_TEXT: {
          id: "click_process_text",
          label: "Process Text",
          type: "human",
          description: "User clicks button to get text suggestions.",
          code: "handleProcessTextClick()",
          stepNo: 6,
        },
        INPUT_COLOR: {
          id: "input_color",
          label: "Input Color(s)",
          type: "human",
          description: "User selects seed color(s) via pickers.",
          code: "dom.sourceColorInputsContainer inputs",
          stepNo: 3,
        },
        SELECT_COLOR_SEED_COUNT: {
          id: "select_color_seed",
          label: "Select Color Seed #",
          type: "human",
          description: "User chooses single/multi color inputs.",
          code: "handleOptionChange()",
          stepNo: 4,
        },
        INPUT_IMAGE: {
          id: "input_image",
          label: "Input Image",
          type: "human",
          description: "User uploads or drops an image file.",
          code: "handleImageFile(file)",
          stepNo: 3,
        },
        SELECT_IMAGE_EXTRACTOR: {
          id: "select_image_extractor",
          label: "Select Img Extractor",
          type: "human",
          description: "User chooses Dream.js/Gemini for image.",
          code: "handleOptionChange()",
          stepNo: 4,
        },
        SELECT_IMAGE_SEED_COUNT: {
          id: "select_image_seed",
          label: "Select Img Seed #",
          type: "human",
          description: "User chooses single/multi seed for image.",
          code: "handleOptionChange()",
          stepNo: 5,
        },
        SELECT_IMAGE_METHOD: {
          id: "select_image_method",
          label: "Select Img Method",
          type: "human",
          description:
            "User chooses suggestion/selection method for Gemini image.",
          code: "handleOptionChange()",
          stepNo: 6,
        },
        CLICK_PROCESS_IMAGE: {
          id: "click_process_image",
          label: "Process Image (Gemini)",
          type: "human",
          description: "User clicks button for Gemini image processing.",
          code: "handleProcessImageGeminiClick()",
          stepNo: 7,
        },
        SELECT_PALETTE_GEN_METHOD: {
          id: "select_palette_gen_method",
          label: "Select Gen Method",
          type: "human",
          description: "User selects palette generation method.",
          code: "handleOptionChange()",
          stepNo: 8,
        },
        CLICK_GENERATE: {
          id: "click_generate",
          label: "Generate Theme",
          type: "human",
          description:
            "User clicks button to generate theme from current inputs.",
          code: "handleGenerateClick()",
          stepNo: 9,
        },
        CLICK_GEN_MWC: {
          id: "click_gen_mwc",
          label: "Gen Deterministic",
          type: "human",
          description:
            "User clicks button to render Material Web Components preview.",
          code: "handleGenerateMwcComponents()",
          stepNo: 11,
        },
        CLICK_GEN_GEMINI: {
          id: "click_gen_gemini",
          label: "Gen Gemini Comp",
          type: "human",
          description:
            "User clicks button to generate LLM-styled HTML components.",
          code: "handleGenerateGeminiComponents()",
          stepNo: 12,
        },
        MCP_WRAP_SUGGEST: {
          id: "mcp_wrap_suggest",
          label: "MCP: SuggestColors",
          type: "mcp",
          description: "System wraps LLM request for color suggestions.",
          code: "getGeminiSuggestions(prompt)",
          stepNo: 6.1,
        },
        MCP_WRAP_SELECT: {
          id: "mcp_wrap_select",
          label: "MCP: SelectBest",
          type: "mcp",
          description:
            "System wraps LLM request to select the best suggestion.",
          code: "getGeminiBestSuggestion(suggestions, prompt)",
          stepNo: 7.1,
        },
        MCP_WRAP_GENERATE: {
          id: "mcp_wrap_generate",
          label: "MCP: Prep Theme Gen",
          type: "mcp",
          description:
            "System prepares parameters for the color utility library.",
          code: "Prepare call to generateThemeInternal()",
          stepNo: 9.1,
        },
        MCP_WRAP_IMG_EXTRACT: {
          id: "mcp_wrap_img_extract",
          label: "MCP: Img Extract",
          type: "mcp",
          description: "System wraps LLM request for image color extraction.",
          code: "getGeminiImageSuggestions(image)",
          stepNo: 7.1,
        },
        MCP_INVOKE_TOOL: {
          id: "mcp_invoke_tool",
          label: "MCP: Invoke Tool",
          type: "mcp",
          description: "System (or LLM via MCP) invokes the Dream.js tool.",
          code: "generateThemeInternal() or simulateDreamJSTheme()",
          stepNo: 9.2,
        },
        MCP_WRAP_GEN_COMP: {
          id: "mcp_wrap_gen_comp",
          label: "MCP: GenerateComponents",
          type: "mcp",
          description: "System wraps LLM request for component generation.",
          code: "getGeminiContent(...)",
          stepNo: 12.1,
        },
        LLM_SUGGEST: {
          id: "llm_suggest",
          label: "LLM: Suggest",
          type: "llm",
          description:
            "LLM processes prompt/image and returns color suggestions.",
          code: "fetch(geminiApiEndpointColorPicker, ...)",
          stepNo: 6.2,
        },
        LLM_SELECT_BEST: {
          id: "llm_select_best",
          label: "LLM: Select Best",
          type: "llm",
          description: "LLM analyzes suggestions and selects the best fit.",
          code: "fetch(geminiApiEndpointColorPicker, ...)",
          stepNo: 7.2,
        },
        LLM_INVOKE_TOOL: {
          id: "llm_invoke_tool",
          label: "LLM: Invoke Tool",
          type: "llm",
          description: "LLM decides to call the generation tool (via MCP).",
          code: "(Function Call -> MCP)",
          stepNo: 9.3,
        },
        LLM_GEN_PALETTE: {
          id: "llm_gen_palette",
          label: "LLM: Generate Palette",
          type: "llm",
          description: "LLM generates the full palette JSON directly.",
          code: "fetch(geminiApiEndpointComponentGenerator, ...)",
          stepNo: 9.5,
        },
        LLM_GEN_COMP: {
          id: "llm_gen_comp",
          label: "LLM: Generate Comp",
          type: "llm",
          description: "LLM generates HTML/CSS components.",
          code: "fetch(geminiApiEndpointComponentGenerator, ...)",
          stepNo: 12.2,
        },
        TOOL_IMAGE_PROC_DREAM: {
          id: "tool_image_proc_dream",
          label: "Tool: Img Proc (Dream)",
          type: "tool",
          description: "Dream.js extracts color(s) from image data.",
          code: "sourceColor(s)FromImage(img, ...)",
          stepNo: 7.3,
        },
        TOOL_COLOR_MATH: {
          id: "tool_color_math",
          label: "Tool: Color Math",
          type: "tool",
          description: "Dream.js calculates the full theme palette.",
          code: "themeFromSourceColor(s)(...)",
          stepNo: 9.4,
        },
        TOOL_RENDER_MWC: {
          id: "tool_render_mwc",
          label: "Tool: Render MWC",
          type: "tool",
          description: "System renders standard Material Web Components.",
          code: "dom.mwcComponentPreview.innerHTML = ...",
          stepNo: 11.1,
        },
        SELECT_SUGGESTION: {
          id: "select_suggestion",
          label: "Select Suggestion",
          type: "human",
          description: "User clicks on one of the suggested color sets.",
          code: "handleSuggestionSelection()",
          stepNo: 8,
        },
        APPLY_LLM_SELECTION: {
          id: "apply_llm_selection",
          label: "Apply LLM Selection",
          type: "decision",
          description: "System automatically applies the LLM-selected colors.",
          code: "applySuggestionToUI(bestSuggestion)",
          stepNo: 8.1,
        },
        DISPLAY_SUGGESTIONS: {
          id: "display_suggestions",
          label: "Display Suggestions",
          type: "result",
          description: "Color suggestions are rendered for user selection.",
          code: "displaySuggestions(data, type)",
          stepNo: 7.4,
        },
        DISPLAY_THEME: {
          id: "display_theme",
          label: "Display Theme",
          type: "result",
          description: "Generated color palette swatches are displayed.",
          code: "displayTheme(theme)",
          stepNo: 10,
        },
        DISPLAY_COMPONENTS: {
          id: "display_components",
          label: "Display Components",
          type: "result",
          description: "MWC or LLM component previews are displayed.",
          code: "dom.mwcComponentPreview / dom.geminiComponentPreview",
          stepNo: 13,
        },
        ERROR: {
          id: "error",
          label: "Error",
          type: "error",
          description: "An error occurred during the process.",
          code: "showError(message)",
          stepNo: 99,
        },
        GO_BACK: {
          id: "go_back",
          label: "Go Back",
          type: "decision",
          description: "User navigates back to a previous step.",
          code: "handleBackButtonClick()",
          stepNo: 98,
        },
      };

      const audio = {
        context: null,
        mainGain: null,
        isInitialized: false,
        isPlayingIntro: false,
        stepNotes: ["C4", "E4", "G4", "C5", "E5", "G5"],
        errorNote: "C3",
        transitionChord: ["C4", "G4", "C5"],
        noteFrequencies: {
          C3: 130.81,
          D3: 146.83,
          E3: 164.81,
          F3: 174.61,
          G3: 196.0,
          A3: 220.0,
          B3: 246.94,
          C4: 261.63,
          D4: 293.66,
          E4: 329.63,
          F4: 349.23,
          G4: 392.0,
          A4: 440.0,
          B4: 493.88,
          C5: 523.25,
          D5: 587.33,
          E5: 659.25,
          F5: 698.46,
          G5: 783.99,
          A5: 880.0,
          B5: 987.77,
        },
        nextNoteIndex: 0,
        tooltipTimeout: null,
        activeTooltip: null,
        introSequenceIndex: 0,
      };

      const severanceSequenceNotes = [
        "E4",
        "G4",
        "E4",
        "C4",
        ["E3", "G3", "C4"],
        "G4",
        "B4",
        "C5",
        ["C4", "E4", "G4"],
        "E5",
      ];
      const severanceSequenceEdges = [
        workflowSteps.SELECT_SOURCE,
        workflowSteps.INPUT_TEXT,
        workflowSteps.CLICK_PROCESS_TEXT,
        workflowSteps.MCP_WRAP_SUGGEST,
        workflowSteps.LLM_SUGGEST,
        workflowSteps.DISPLAY_SUGGESTIONS,
        workflowSteps.SELECT_SUGGESTION,
        workflowSteps.CLICK_GENERATE,
        workflowSteps.MCP_WRAP_GENERATE,
        workflowSteps.DISPLAY_THEME,
      ];
      const severanceSequenceTypes = [
        "note",
        "note",
        "note",
        "chord",
        "note",
        "note",
        "note",
        "chord",
        "note",
      ];

      const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      const sanitizeHtml = (str) => {
        const temp = createEl("div");
        setText(temp, str);
        return temp.innerHTML;
      };
      const kebabCase = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase();
      const sanitizeForCssVariable = (str) =>
        (str || "custom")
          .replace(/[^a-zA-Z0-9_-]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-+|-+$/g, "");
      function hexToArgbInt(hex) {
        if (!hex) return 0;
        hex = hex.replace("#", "");
        if (hex.length === 3)
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        if (hex.length !== 6) return 0;
        return (parseInt(`ff${hex}`, 16) | 0) >>> 0;
      }
      function argbIntToHex(argb) {
        if (typeof argb !== "number" || isNaN(argb) || argb < 0)
          argb = argb >>> 0;
        const r = (argb >> 16) & 0xff;
        const g = (argb >> 8) & 0xff;
        const b = argb & 0xff;
        return `#${[r, g, b]
          .map((c) => c.toString(16).padStart(2, "0"))
          .join("")}`;
      }
      function getContrastColor(hex) {
        if (!hex || hex.length < 4) return "#000000";
        hex = hex.replace("#", "");
        if (hex.length === 3)
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        if (hex.length !== 6) return "#000000";
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;
        const rLinear =
          r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        const gLinear =
          g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
        const bLinear =
          b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
        const lum = 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
        const contrastWithWhite = (1 + 0.05) / (lum + 0.05);
        const contrastWithBlack = (lum + 0.05) / (0 + 0.05);
        return contrastWithBlack >= 4.5 || contrastWithBlack > contrastWithWhite
          ? "#000000"
          : "#FFFFFF";
      }
      function createSwatchHtml(name, colorInt, extraClass = "") {
        const hex = argbIntToHex(colorInt);
        const contrast = getContrastColor(hex);
        const safeName = sanitizeHtml(name || "");
        return `<div class="swatch ${extraClass}" style="background-color: ${hex}; color: ${contrast};" title="${safeName} - ${hex}"><span class="swatch-name">${safeName}</span><span class="swatch-hex">${hex}</span></div>`;
      }
      function showError(msg) {
        setText(dom.errorMessageDiv, msg);
        hideEl(dom.errorMessageDiv, false);
        addStepToMinimapQueue(workflowSteps.ERROR, "error");
        toggleBackButton(true);
      }
      function hideError() {
        hideEl(dom.errorMessageDiv, true);
        setText(dom.errorMessageDiv, "");
      }
      function setUILoading(isLoading, source = "") {
        setText(
          dom.loadingIndicator,
          isLoading ? `Generating theme (${source})...` : ""
        );
        hideEl(dom.loadingIndicator, !isLoading);
        disableEl(dom.generateButton, isLoading);
        toggleClass(
          dom.generateButtonContainer,
          "status-active",
          isLoading && !isUserActionRequired(state.currentInputSource)
        );
      }
      function setSuggestionLoading(isLoading, type = "text") {
        const indicator =
          type === "image"
            ? dom.imageSuggestionLoadingIndicator
            : dom.suggestionLoadingIndicator;
        const button =
          type === "image"
            ? dom.processImageGeminiButton
            : dom.processTextButton;
        hideEl(indicator, !isLoading);
        disableEl(button, isLoading);
        if (type === "text") disableEl(dom.textPromptInput, isLoading);
      }
      function setGeminiComponentLoading(isLoading) {
        hideEl(dom.geminiComponentLoadingIndicator, !isLoading);
        disableEl(dom.generateGeminiComponentsButton, isLoading);
        disableEl(dom.generateMwcComponentsButton, isLoading);
      }

      function initializeAudio() {
        if (audio.isInitialized || !window.AudioContext) return;
        try {
          audio.context = new AudioContext();
          audio.mainGain = audio.context.createGain();
          audio.mainGain.gain.setValueAtTime(0.15, audio.context.currentTime);
          audio.mainGain.connect(audio.context.destination);
          audio.isInitialized = true;
        } catch (e) {
          audio.isInitialized = false;
        }
      }
      function getNoteFrequency(note) {
        return audio.noteFrequencies[note] || 440;
      }
      function playNote(note, duration = 0.15, delay = 0) {
        if (
          !audio.isInitialized ||
          !audio.context ||
          audio.context.state === "suspended"
        )
          return;
        const oscillator = audio.context.createOscillator();
        const noteGain = audio.context.createGain();
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(
          getNoteFrequency(note),
          audio.context.currentTime + delay
        );
        noteGain.gain.setValueAtTime(0, audio.context.currentTime + delay);
        noteGain.gain.linearRampToValueAtTime(
          1,
          audio.context.currentTime + delay + 0.01
        );
        noteGain.gain.exponentialRampToValueAtTime(
          0.0001,
          audio.context.currentTime + delay + duration
        );
        oscillator.connect(noteGain);
        noteGain.connect(audio.mainGain);
        oscillator.start(audio.context.currentTime + delay);
        oscillator.stop(audio.context.currentTime + delay + duration);
      }
      function playChord(notes, duration = 0.3, delay = 0, stagger = 0.03) {
        if (!audio.isInitialized) return;
        notes.forEach((note, index) =>
          playNote(note, duration, delay + index * stagger)
        );
      }
      function playWorkflowStepSound(stepType) {
        if (!audio.isInitialized) return;
        if (stepType === "error") {
          playNote(audio.errorNote, 0.25);
        } else if (!audio.isPlayingIntro) {
          const note =
            audio.stepNotes[audio.nextNoteIndex % audio.stepNotes.length];
          playNote(note, 0.15);
          audio.nextNoteIndex++;
        }
      }

      function positionTooltip(targetElement, tooltipElement) {
        if (!targetElement || !tooltipElement) return;
        const targetRect = targetElement.getBoundingClientRect();
        tooltipElement.style.position = "fixed";
        tooltipElement.style.left = `${
          targetRect.left - tooltipElement.offsetWidth - 10
        }px`;
        tooltipElement.style.top = `${
          targetRect.top +
          targetRect.height / 2 -
          tooltipElement.offsetHeight / 2
        }px`;

        const tooltipRect = tooltipElement.getBoundingClientRect();
        if (tooltipRect.left < 0) {
          tooltipElement.style.left = `${targetRect.right + 10}px`;
          tooltipElement.style.top = `${
            targetRect.top +
            targetRect.height / 2 -
            tooltipElement.offsetHeight / 2
          }px`;
        }
        if (tooltipRect.top < 0) {
          tooltipElement.style.top = "5px";
        }
        if (tooltipRect.bottom > window.innerHeight) {
          tooltipElement.style.top = `${
            window.innerHeight - tooltipElement.offsetHeight - 5
          }px`;
        }
      }
      function showTooltip(targetElement) {
        if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
        hideTooltip();
        const tooltip = targetElement.querySelector(".minimap-tooltip");
        if (!tooltip) return;
        audio.activeTooltip = tooltip;
        tooltip.style.visibility = "visible";
        tooltip.style.opacity = "1";
        positionTooltip(targetElement, tooltip);
      }
      function hideTooltip() {
        if (audio.activeTooltip) {
          audio.activeTooltip.style.opacity = "0";
          audio.activeTooltip.style.visibility = "hidden";
          audio.activeTooltip = null;
        }
        if (audio.tooltipTimeout) {
          clearTimeout(audio.tooltipTimeout);
          audio.tooltipTimeout = null;
        }
      }
      function setupTooltipListeners(element) {
        element.addEventListener("mouseenter", (e) => {
          if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
          audio.tooltipTimeout = setTimeout(
            () => showTooltip(e.currentTarget),
            150
          );
        });
        element.addEventListener("mouseleave", () => {
          if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
          audio.tooltipTimeout = setTimeout(hideTooltip, 100);
        });
        element.addEventListener("focus", (e) => {
          if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
          showTooltip(e.currentTarget);
        });
        element.addEventListener("blur", () => {
          if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
          audio.tooltipTimeout = setTimeout(hideTooltip, 100);
        });
        const tooltip = element.querySelector(".minimap-tooltip");
        if (tooltip) {
          tooltip.addEventListener("mouseenter", () => {
            if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
          });
          tooltip.addEventListener("mouseleave", () => {
            if (audio.tooltipTimeout) clearTimeout(audio.tooltipTimeout);
            audio.tooltipTimeout = setTimeout(hideTooltip, 100);
          });
        }
      }

      function addStepToMinimapQueue(step, edgeType = "human") {
        if (!step) return;
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        state.minimapUpdateQueue.push({ step, edgeType });
        if (!state.isMinimapUpdating) {
          processMinimapQueue();
        }
      }

      async function processMinimapQueue() {
        if (state.minimapUpdateQueue.length === 0) {
          state.isMinimapUpdating = false;
          return;
        }
        state.isMinimapUpdating = true;
        const { step, edgeType } = state.minimapUpdateQueue.shift();
        const isNewStep =
          !state.currentMinimapSteps.length ||
          step.id !==
            state.currentMinimapSteps[state.currentMinimapSteps.length - 1].id;

        if (isNewStep) {
          state.currentMinimapSteps.push({
            ...step,
            edge: edgeType || "human",
          });
          playWorkflowStepSound(step.type);
        } else if (state.currentMinimapSteps.length > 0) {
          state.currentMinimapSteps[state.currentMinimapSteps.length - 1].edge =
            edgeType ||
            state.currentMinimapSteps[state.currentMinimapSteps.length - 1]
              .edge ||
            "human";
        }

        renderMinimap(isNewStep);

        await delay(isNewStep ? config.MINIMAP_STEP_DELAY : 50);
        processMinimapQueue();
      }

      function renderMinimap(stepAdded = false) {
        setHtml(dom.minimapContent, "");
        const fragment = document.createDocumentFragment();

        state.currentMinimapSteps
          .sort((a, b) => a.stepNo - b.stepNo)
          .forEach((step, index) => {
            const isLastNode = index === state.currentMinimapSteps.length - 1;

            const nodeEl = createEl("div");
            nodeEl.className = `minimap-node node-${step.type}`;
            setText(nodeEl, step.label);
            nodeEl.tabIndex = 0;
            if (isLastNode) nodeEl.classList.add("active");

            const tooltipEl = createEl("div");
            tooltipEl.className = "minimap-tooltip";
            let tooltipContent = step.description || `Step: ${step.label}`;
            if (step.code)
              tooltipContent += `<code class="minimap-tooltip-code">${sanitizeHtml(
                step.code
              )}</code>`;
            setHtml(tooltipEl, tooltipContent);
            nodeEl.appendChild(tooltipEl);
            fragment.appendChild(nodeEl);
            setupTooltipListeners(nodeEl);

            if (index < state.currentMinimapSteps.length - 1) {
              const nextStep = state.currentMinimapSteps[index + 1];
              const edgeEl = createEl("div");
              const edgeClass = nextStep.edge || "human";
              edgeEl.className = `minimap-edge edge-${edgeClass}`;
              edgeEl.tabIndex = 0;
              const edgeStep = {
                id: `edge_${step.id}_${nextStep.id}`,
                label: `Transition via ${edgeClass}`,
                type: "edge",
                description:
                  edgeClass === "gemini-bridge"
                    ? `LLM API call (${step.label} -> ${nextStep.label})`
                    : `Transition from ${step.label} to ${nextStep.label} via ${edgeClass}.`,
                code: step.code
                  ? `${step.code} -> ${nextStep.code || "..."}`
                  : `Via: ${edgeClass}`,
              };
              const edgeTooltipEl = createEl("div");
              edgeTooltipEl.className = "minimap-tooltip";
              let edgeTooltipContent = edgeStep.description;
              if (
                edgeStep.code &&
                edgeClass !== "human" &&
                edgeClass !== "result"
              ) {
                edgeTooltipContent += `<code class="minimap-tooltip-code">${sanitizeHtml(
                  edgeStep.code
                )}</code>`;
              }
              setHtml(edgeTooltipEl, edgeTooltipContent);
              edgeEl.appendChild(edgeTooltipEl);
              if (index === state.currentMinimapSteps.length - 2)
                edgeEl.classList.add("active");
              fragment.appendChild(edgeEl);
              setupTooltipListeners(edgeEl);
            }
          });

        dom.minimapContent.appendChild(fragment);

        const elementsToAnimate = Array.from(dom.minimapContent.children);
        if (stepAdded && elementsToAnimate.length > 0) {
          const lastAdded =
            elementsToAnimate.length > 1
              ? [
                  elementsToAnimate[elementsToAnimate.length - 2],
                  elementsToAnimate[elementsToAnimate.length - 1],
                ]
              : [elementsToAnimate[0]];
          lastAdded.forEach((el) => {
            requestAnimationFrame(() => {
              el.style.transition = "none";
              el.style.opacity = "0";
              requestAnimationFrame(() => {
                el.style.transition = `opacity ${config.MINIMAP_ANIMATION_DURATION}ms ease-in-out`;
                el.classList.add("visible");
              });
            });
          });
          elementsToAnimate
            .slice(0, elementsToAnimate.length - lastAdded.length)
            .forEach((el) => el.classList.add("visible"));
        } else {
          elementsToAnimate.forEach((el) => el.classList.add("visible"));
        }

        const lastElement = dom.minimapContent.lastElementChild;
        if (lastElement) {
          lastElement.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }

      function playSeveranceIntroStep() {
        if (!audio.isInitialized) {
          initializeAudio();
          if (!audio.isInitialized) return;
        }
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        if (audio.introSequenceIndex < severanceSequenceNotes.length) {
          const note = severanceSequenceNotes[audio.introSequenceIndex];
          const type =
            severanceSequenceTypes[audio.introSequenceIndex] || "note";
          if (type === "note") playNote(note, 0.15);
          else if (type === "chord") playChord(note, 0.3);
          audio.introSequenceIndex++;
        } else {
          audio.introSequenceIndex = 0;
        }
      }

      function resetMinimap(startNode = workflowSteps.START, playSound = true) {
        state.currentMinimapSteps = [];
        state.minimapUpdateQueue = [];
        state.isMinimapUpdating = false;
        setHtml(dom.minimapContent, "");
        addStepToMinimapQueue(startNode);
      }

      function resetMinimapToBase() {
        state.currentMinimapSteps = [workflowSteps.START];
        renderMinimap();
        const currentSource =
          getSelectedValue(dom.inputSourceSelection) ||
          config.defaultInputSource;
        addStepToMinimapQueue(workflowSteps.SELECT_SOURCE);
        updatePhase1UI();
      }

      function loadImageFromSrc(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = (err) =>
            reject(
              new Error(`Image could not be loaded: ${err.type || "error"}`)
            );
          img.src = src;
          if (img.complete && img.naturalWidth > 0)
            setTimeout(() => resolve(img), 0);
        });
      }
      function validateAndConvertHex(hex, label) {
        const argb = hexToArgbInt(hex);
        if (argb === 0 && !["#000", "#000000"].includes(hex?.toLowerCase()))
          throw new Error(`Invalid hex value for ${label}: ${hex}`);
        return argb;
      }

      function displaySeedColors(seeds, theme) {
        setHtml(dom.seedColorsDisplayContainer, "");
        let displayedSeeds = [];
        if (seeds?.length) {
          displayedSeeds = seeds;
        } else if (theme?.source) {
          const sourceSeed = Array.isArray(theme.source)
            ? theme.source[0]
            : theme.source;
          if (typeof sourceSeed === "number") displayedSeeds = [sourceSeed];
        }
        displayedSeeds.forEach((seed, i) => {
          if (typeof seed === "number")
            dom.seedColorsDisplayContainer.innerHTML += createSwatchHtml(
              `Seed ${i + 1}`,
              seed,
              "seed-swatch"
            );
        });
        if (!dom.seedColorsDisplayContainer.hasChildNodes())
          setHtml(dom.seedColorsDisplayContainer, placeholders.seedUnavailable);
      }
      function loadConfig() {
        try {
          if (typeof APP_CONFIG === "undefined")
            throw new Error("config.js not loaded or APP_CONFIG missing.");
          Object.assign(config, {
            ENABLE_IMAGES: !!APP_CONFIG.ENABLE_IMAGES,
            USE_M3_TXT_SYS_PROMPT: !!APP_CONFIG.USE_M3_TXT_SYS_PROMPT,
            ENABLE_AUTO_MODES: !!APP_CONFIG.ENABLE_AUTO_MODES,
            API_KEY: APP_CONFIG.API_KEY || null,
            GEMINI_MODEL: APP_CONFIG.GEMINI_MODEL || null,
            defaultInputSource: APP_CONFIG.DEFAULT_MODE || "text",
            MINIMAP_STEP_DELAY: APP_CONFIG.MINIMAP_STEP_DELAY ?? 1000,
            MINIMAP_ANIMATION_DURATION:
              APP_CONFIG.MINIMAP_ANIMATION_DURATION ?? 400,
          });
          config.GEMINI_MODEL_COLOR_PICKER =
            APP_CONFIG.GEMINI_MODEL_COLOR_PICKER || config.GEMINI_MODEL;
          config.GEMINI_MODEL_COMPONENT_GENERATOR =
            APP_CONFIG.GEMINI_MODEL_COMPONENT_GENERATOR || config.GEMINI_MODEL;

          document.documentElement.style.setProperty(
            "--minimap-transition-duration",
            `${config.MINIMAP_ANIMATION_DURATION}ms`
          );

          if (
            config.defaultInputSource.startsWith("modeImage") &&
            !config.ENABLE_IMAGES
          )
            config.defaultInputSource = "text";
          else if (config.defaultInputSource.startsWith("mode"))
            config.defaultInputSource = "text";
          state.currentInputSource = config.defaultInputSource;

          if (
            !config.API_KEY ||
            config.API_KEY === "YOUR_API_KEY_HERE" ||
            !config.GEMINI_MODEL
          ) {
            config.isApiConfigValid = false;
            showError(
              "Gemini API config missing/invalid in config.js. Using simulation where possible."
            );
          } else {
            const modelIdBase = config.GEMINI_MODEL.startsWith("models/")
              ? config.GEMINI_MODEL
              : `models/${config.GEMINI_MODEL}`;
            const modelIdColorPicker =
              (config.GEMINI_MODEL_COLOR_PICKER &&
                (config.GEMINI_MODEL_COLOR_PICKER.startsWith("models/")
                  ? config.GEMINI_MODEL_COLOR_PICKER
                  : `models/${config.GEMINI_MODEL_COLOR_PICKER}`)) ||
              modelIdBase;
            const modelIdComponentGenerator =
              (config.GEMINI_MODEL_COMPONENT_GENERATOR &&
                (config.GEMINI_MODEL_COMPONENT_GENERATOR.startsWith("models/")
                  ? config.GEMINI_MODEL_COMPONENT_GENERATOR
                  : `models/${config.GEMINI_MODEL_COMPONENT_GENERATOR}`)) ||
              modelIdBase;
            const apiPrefix =
              "https://generativelanguage.googleapis.com/v1beta/";
            config.geminiApiEndpointBase = `${apiPrefix}${modelIdBase}`;
            config.geminiApiEndpointColorPicker = `${apiPrefix}${modelIdColorPicker}`;
            config.geminiApiEndpointComponentGenerator = `${apiPrefix}${modelIdComponentGenerator}`;
            config.isApiConfigValid = true;
          }
        } catch (error) {
          console.error("Error loading config.js:", error);
          showError("Config error. Using simulation, limited features.");
          config.isApiConfigValid = false;
        } finally {
          const defaultRadio = getEl(
            `source${
              config.defaultInputSource.charAt(0).toUpperCase() +
              config.defaultInputSource.slice(1)
            }`
          );
          if (defaultRadio) defaultRadio.checked = true;
          else getEl("sourceText").checked = true;
          state.currentInputSource = $(
            `input[name="inputSource"]:checked`
          ).value;
          setSelectedChip(dom.paletteGenerationMethodSelection, "dreamjs");
          state.generationMethod = "dreamjs";
        }
      }
      function applyFeatureVisibility() {
        const features = {
          image: config.ENABLE_IMAGES,
          api: config.isApiConfigValid,
          auto: config.ENABLE_AUTO_MODES && config.isApiConfigValid,
        };
        hideEl(dom.sourceImageContainer, !features.image);
        hideEl(getEl("textSelectGeminiMCP").parentNode, !features.auto);
        hideEl(
          dom.imageExtractGeminiContainer,
          !features.api || !features.image
        );
        hideEl(
          dom.imageSelectGeminiMCPContainer,
          !features.auto || !features.image
        );

        const simCheckboxLabel = dom.useSimulationCheckbox?.labels?.[0];
        if (simCheckboxLabel) {
          simCheckboxLabel.style.opacity = features.api ? "1" : "0.6";
          simCheckboxLabel.style.cursor = features.api
            ? "pointer"
            : "not-allowed";
          disableEl(dom.useSimulationCheckbox, !features.api);
          dom.useSimulationCheckbox.checked = !features.api;
        }

        [
          dom.processTextButton,
          dom.processImageGeminiButton,
          dom.generateGeminiComponentsButton,
        ].forEach((btn) => {
          if (btn)
            setAttr(
              btn,
              "title",
              !features.api ? "Gemini API not configured." : ""
            );
        });
        hideEl(dom.generateGeminiComponentsButton, !features.api);
        hideEl(dom.m3GuidanceOptionContainer, !features.api);

        const selectedSourceRadio = $(`input[name="inputSource"]:checked`);
        if (selectedSourceRadio?.value === "image" && !features.image) {
          getEl("sourceText").checked = true;
          state.currentInputSource = "text";
        }
        updatePhase1UI();
      }
      function applyTheme() {
        toggleClass(dom.bodyElement, "dark-theme", state.isDarkMode);
        setText(
          dom.themeToggleIcon,
          state.isDarkMode ? "light_mode" : "dark_mode"
        );
        toggleClass(dom.mwcComponentPreview, "dark-theme", state.isDarkMode);
        toggleClass(dom.geminiComponentPreview, "dark-theme", state.isDarkMode);
        if (state.lastGeneratedTheme)
          applyScopedThemeStyles(state.lastGeneratedTheme);
      }
      function handleThemeToggle() {
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        state.isDarkMode = !state.isDarkMode;
        localStorage.setItem("themeMode", state.isDarkMode ? "dark" : "light");
        applyTheme();
        addStepToMinimapQueue(workflowSteps.SELECT_SOURCE, "human");
      }
      function setupThemeToggle() {
        const storedTheme = localStorage.getItem("themeMode");
        state.isDarkMode = storedTheme === "dark";
        applyTheme();
      }
      function displayTheme(theme) {
        setHtml(dom.paletteDisplay, "");
        state.lastGeneratedTheme = theme;
        if (!theme?.palettes || !theme?.schemes) {
          setHtml(dom.paletteDisplay, placeholders.noPalettes);
          hideEl(dom.componentExamplesDiv, true);
          showError("Invalid theme data received.");
          addStepToMinimapQueue(workflowSteps.ERROR, "error");
          return;
        }
        hideError();
        dom.phase2Card.className = "phase-card output-section phase-local-tool";
        const schemeKeys = [
          "primary",
          "secondary",
          "tertiary",
          "neutral",
          "neutralVariant",
          "error",
        ];
        schemeKeys.forEach((key) => {
          if (!theme.palettes[key]) return;
          const section = createEl("div");
          section.className = "palette-section color-group";
          const title =
            key.charAt(0).toUpperCase() +
            key.slice(1).replace(/([A-Z])/g, " $1");
          setHtml(section, `<h4>${title} Roles</h4>`);
          const swatches = createEl("div");
          swatches.className = "scheme-swatches";
          const capKey = key.charAt(0).toUpperCase() + key.slice(1);
          const roles = [
            { n: `${key}(L)`, k: key, s: "light" },
            { n: `On ${key}(L)`, k: `on${capKey}`, s: "light" },
            { n: `${key} Cont.(L)`, k: `${key}Container`, s: "light" },
            { n: `On ${key} Cont.(L)`, k: `on${capKey}Container`, s: "light" },
            { n: `${key}(D)`, k: key, s: "dark" },
            { n: `On ${key}(D)`, k: `on${capKey}`, s: "dark" },
            { n: `${key} Cont.(D)`, k: `${key}Container`, s: "dark" },
            { n: `On ${key} Cont.(D)`, k: `on${capKey}Container`, s: "dark" },
          ];
          roles.forEach((r) => {
            const scheme = theme.schemes[r.s];
            if (scheme && typeof scheme[r.k] === "number")
              swatches.innerHTML += createSwatchHtml(r.n, scheme[r.k]);
          });
          if (swatches.hasChildNodes()) {
            section.appendChild(swatches);
            dom.paletteDisplay.appendChild(section);
          }
        });

        if (!dom.paletteDisplay.hasChildNodes()) {
          setHtml(dom.paletteDisplay, placeholders.noPalettes);
          hideEl(dom.componentExamplesDiv, true);
        } else {
          hideEl(dom.componentExamplesDiv, false);
          applyScopedThemeStyles(theme);
          setHtml(dom.mwcComponentPreview, placeholders.mwcPreview);
          setHtml(dom.geminiComponentPreview, placeholders.geminiPreview);
          addStepToMinimapQueue(workflowSteps.DISPLAY_THEME, "result");
          state.currentPhaseCardId = "phase-2-card";
          dom.phase2Card.classList.add("phase-local-tool");
        }
      }

      function getSelectedValue(selectionGroup) {
        const selectedRadio = selectionGroup?.querySelector(
          `input[type="radio"]:checked`
        );
        return selectedRadio ? selectedRadio.value : null;
      }

      function isUserActionRequired(source) {
        if (source === "text") {
          return getSelectedValue(dom.textSelectionMethodSelection) === "user";
        } else if (source === "image") {
          const extractionMethod = getSelectedValue(
            dom.imageExtractionMethodSelection
          );
          return (
            extractionMethod === "gemini" &&
            getSelectedValue(dom.imageSelectionMethodSelection) === "user"
          );
        }
        return false;
      }

      function updatePhase1UI() {
        hideError();
        const source =
          getSelectedValue(dom.inputSourceSelection) ??
          state.currentInputSource;
        state.currentInputSource = source;

        hideEl(dom.textOptionsGroup, source !== "text");
        hideEl(dom.colorOptionsGroup, source !== "color");
        hideEl(dom.imageOptionsGroup, source !== "image");

        setHtml(dom.paletteDisplay, placeholders.palette);
        setHtml(dom.seedColorsDisplayContainer, placeholders.seeds);
        hideEl(dom.componentExamplesDiv, true);
        setHtml(dom.mwcComponentPreview, placeholders.mwcPreview);
        setHtml(dom.geminiComponentPreview, placeholders.geminiPreview);
        state.lastSuggestions = { text: null, image: null };
        state.selectedSuggestion = { text: null, image: null };
        toggleBackButton(false);
        dom.phase1Card.className =
          "phase-card input-section phase-human-decision";
        state.currentPhaseCardId = "phase-1-card";

        let stepToAdd = null;
        let needsProcessingButton = false;
        let generateButtonText = "Generate Theme";
        let showGenerateButton = true;

        if (source === "text") {
          const selectionMethod = getSelectedValue(
            dom.textSelectionMethodSelection
          );
          needsProcessingButton = selectionMethod === "user";
          hideEl(dom.textPromptSuggestions, !needsProcessingButton);
          if (
            selectionMethod === "gemini" ||
            selectionMethod === "gemini_mcp"
          ) {
            generateButtonText = "Auto Select & Generate";
            toggleClass(dom.generateButtonContainer, "status-active", true);
          } else {
            toggleClass(dom.generateButtonContainer, "status-active", false);
          }
          hideEl(dom.processTextButton, !needsProcessingButton);
          stepToAdd = workflowSteps.INPUT_TEXT;
        } else if (source === "color") {
          const seedCount = getSelectedValue(dom.colorSeedCountSelection);
          hideEl(dom.multiSourceOptionsArea, seedCount !== "multi");
          updateColorPickers(seedCount);
          toggleClass(dom.generateButtonContainer, "status-active", false);
          stepToAdd = workflowSteps.INPUT_COLOR;
        } else if (source === "image") {
          if (!state.currentImageFile) {
            hideEl(dom.imagePreview, true);
            dom.imagePreview.src = "#";
          }
          const extractionMethod = getSelectedValue(
            dom.imageExtractionMethodSelection
          );
          hideEl(dom.imageDreamOptions, extractionMethod === "gemini");
          hideEl(dom.imageGeminiOptions, extractionMethod !== "gemini");

          if (extractionMethod === "gemini") {
            const selectionMethod = getSelectedValue(
              dom.imageSelectionMethodSelection
            );
            needsProcessingButton = selectionMethod === "user";
            hideEl(dom.imagePromptSuggestions, !needsProcessingButton);
            if (
              selectionMethod === "gemini" ||
              selectionMethod === "gemini_mcp"
            ) {
              generateButtonText = "Auto Select & Generate";
              toggleClass(dom.generateButtonContainer, "status-active", true);
            } else {
              toggleClass(dom.generateButtonContainer, "status-active", false);
            }
            hideEl(dom.processImageGeminiButton, !needsProcessingButton);
          } else {
            hideEl(dom.processImageGeminiButton, true);
            toggleClass(dom.generateButtonContainer, "status-active", false);
          }
          stepToAdd = workflowSteps.INPUT_IMAGE;
        }

        setText(dom.generateButton, generateButtonText);
        hideEl(dom.generateButtonContainer, !showGenerateButton);

        if (stepToAdd) addStepToMinimapQueue(stepToAdd, "human");
      }

      function updateColorPickers(seedCount) {
        setHtml(dom.sourceColorInputsContainer, "");
        const isMulti = seedCount === "multi";
        if (isMulti) {
          setText(dom.sourceColorLabel, "Source Colors:");
          addSourceColorInput(0, "Primary");
          addSourceColorInput(1, "Secondary");
          addSourceColorInput(2, "Tertiary");
        } else {
          setText(dom.sourceColorLabel, "Source Color:");
          addSourceColorInput(0);
        }
        addStepToMinimapQueue(workflowSteps.SELECT_COLOR_SEED_COUNT, "human");
      }

      function handleInputSourceChange(event) {
        if (event) state.currentInputSource = event.target.value;
        resetMinimapToBase();
        updatePhase1UI();
      }

      function handleOptionChange(event) {
        if (!event || !event.target) return;
        const group = event.target.closest(".chip-selection-group");
        if (!group) return;

        const name = group.dataset.name;
        let step = null;

        switch (name) {
          case "inputSource":
            state.currentInputSource = event.target.value;
            resetMinimapToBase();
            break;
          case "textSeedCount":
            step = workflowSteps.SELECT_TEXT_SEED_COUNT;
            break;
          case "textSelectionMethod":
            step = workflowSteps.SELECT_TEXT_METHOD;
            break;
          case "colorSeedCount":
            step = workflowSteps.SELECT_COLOR_SEED_COUNT;
            break;
          case "imageExtractionMethod":
            step = workflowSteps.SELECT_IMAGE_EXTRACTOR;
            break;
          case "imageSeedCount":
            step = workflowSteps.SELECT_IMAGE_SEED_COUNT;
            break;
          case "imageSelectionMethod":
            step = workflowSteps.SELECT_IMAGE_METHOD;
            break;
          case "paletteGenerationMethod":
            state.generationMethod = event.target.value;
            step = workflowSteps.SELECT_PALETTE_GEN_METHOD;
            break;
        }
        if (step) addStepToMinimapQueue(step, "human");
        updatePhase1UI();
      }

      function addSourceColorInput(index, label = "", disabled = false) {
        const row = createEl("div");
        row.className = "color-input-row";
        const id = `source-color-${index}`;
        const defaults = ["#6750A4", "#625B71", "#7D5260"];
        const safeLabel = sanitizeHtml(label);
        const labelHtml = label
          ? `<label for="${id}">${safeLabel}:</label>`
          : "";
        const inputHtml = `<input type="color" id="${id}" name="${id}" value="${
          defaults[index] || "#808080"
        }" ${disabled ? "disabled" : ""}>`;
        setHtml(row, `${labelHtml}${inputHtml}`);
        dom.sourceColorInputsContainer.appendChild(row);
        row
          .querySelector('input[type="color"]')
          .addEventListener("input", () => {
            addStepToMinimapQueue(workflowSteps.INPUT_COLOR, "human");
          });
      }
      function handleImageFile(file) {
        if (!file?.type.startsWith("image/")) {
          showError("Invalid file type. Please upload an image.");
          return;
        }
        state.currentImageFile = file;
        const reader = new FileReader();
        reader.onload = (e) => {
          dom.imagePreview.src = e.target.result;
          hideEl(dom.imagePreview, false);
          hideError();
          addStepToMinimapQueue(workflowSteps.INPUT_IMAGE, "human");
          updatePhase1UI();
        };
        reader.onerror = () => {
          showError("Failed to read image file.");
          hideEl(dom.imagePreview, true);
          dom.imagePreview.src = "#";
          state.currentImageFile = null;
        };
        reader.readAsDataURL(file);
      }
      async function fetchM3Content() {
        if (state.m3ContentCache) return state.m3ContentCache;
        try {
          const response = await fetch("m3.txt");
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          state.m3ContentCache = await response.text();
          return state.m3ContentCache;
        } catch (error) {
          console.error("Failed to fetch m3.txt:", error);
          showError(
            "Failed to load base component guidelines (m3.txt). Gemini generation might be less accurate."
          );
          return "";
        }
      }
      async function getGeminiContent(
        endpoint,
        systemPrompt = "",
        userPrompt,
        isJsonResponse = false,
        useM3Guidance = false,
        callingStep = workflowSteps.LLM_SUGGEST,
        imageBase64 = null
      ) {
        if (!config.isApiConfigValid)
          throw new Error("Gemini API is not configured in config.js");
        const fullApiUrl = `${endpoint}:generateContent?key=${config.API_KEY}`;
        let effectiveSystemPrompt = systemPrompt;
        if (useM3Guidance && systemPrompt.includes("Material Design 3")) {
          const m3Content = await fetchM3Content();
          if (m3Content)
            effectiveSystemPrompt += `\n\n# Material Design 3 Component Guidelines and Specifications\n\n${m3Content}`;
        }
        const parts = [];
        if (imageBase64)
          parts.push({
            inline_data: {
              mime_type: "image/jpeg",
              data: imageBase64.split(",")[1],
            },
          });
        if (effectiveSystemPrompt && !imageBase64)
          parts.push({ text: effectiveSystemPrompt });
        parts.push({ text: userPrompt });

        const requestBody = {
          contents: [{ role: "user", parts: parts }],
          generationConfig: {
            temperature: 0.6,
            maxOutputTokens: isJsonResponse ? 1024 : 4096,
          },
        };
        if (isJsonResponse)
          requestBody.generationConfig.responseMimeType = "application/json";
        if (effectiveSystemPrompt && imageBase64)
          requestBody.system_instruction = {
            parts: [{ text: effectiveSystemPrompt }],
          };

        try {
          addStepToMinimapQueue(callingStep, "gemini-bridge");
          const response = await fetch(fullApiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody),
          });
          if (!response.ok) {
            let errorBodyText = await response.text();
            let errorDetails = errorBodyText;
            try {
              errorDetails = JSON.parse(errorBodyText);
            } catch (e) {}
            console.error("Gemini API Error:", response.status, errorDetails);
            throw new Error(
              `API request failed: ${response.status} ${
                response.statusText
              }. Details: ${JSON.stringify(errorDetails)}`
            );
          }
          const data = await response.json();
          if (data.promptFeedback?.blockReason)
            throw new Error(
              `API request blocked: ${
                data.promptFeedback.blockReason
              }. Details: ${JSON.stringify(data.promptFeedback.safetyRatings)}`
            );
          const candidate = data.candidates?.[0];
          if (!candidate) throw new Error("API response missing candidates.");
          if (
            candidate.finishReason &&
            !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)
          ) {
            const safetyInfo = candidate.safetyRatings
              ? `Safety: ${JSON.stringify(candidate.safetyRatings)}`
              : "";
            throw new Error(
              `Generation stopped unexpectedly: ${candidate.finishReason}. ${safetyInfo}`
            );
          }
          const contentText = candidate.content?.parts?.[0]?.text;
          if (typeof contentText !== "string")
            throw new Error("API response missing valid text content.");
          return contentText;
        } catch (error) {
          console.error("Error during Gemini API call:", error);
          addStepToMinimapQueue(workflowSteps.ERROR, "error");
          showError(`Gemini API call failed: ${error.message}`);
          throw error;
        }
      }

      const GEMINI_COLOR_SYSTEM_PROMPT_MULTI = `You are a helpful color palette assistant. Given a text description or an image, suggest exactly 3 DIFFERENT sets of 3 complementary hex color codes suitable for a Material Design 3 theme (Primary, Secondary, Tertiary). Respond ONLY with a valid JSON object containing a single key "suggestions". The value of "suggestions" must be an array containing exactly 3 sub-arrays. Each sub-array must contain exactly 3 valid 6-digit hex color strings (e.g., ["#RRGGBB", "#RRGGBB", "#RRGGBB"]). Example: {"suggestions": [["#6750A4", "#625B71", "#7D5260"], ["#00695C", "#4DB6AC", "#B2DFDB"], ["#B71C1C", "#EF9A9A", "#FFEBEE"]]}. Do not include any other text, explanations, apologies, or markdown formatting. Ensure the hex codes are valid and distinct sets are provided, reflecting the user's prompt or image content.`;
      const GEMINI_COLOR_SYSTEM_PROMPT_SINGLE = `You are a helpful color palette assistant. Given a text description or an image, suggest a SINGLE dominant or representative hex color code suitable as a source color for a Material Design 3 theme. Respond ONLY with a valid JSON object containing a single key "suggestion" whose value is a single valid 6-digit hex color string. Example: {"suggestion": "#6750A4"}. Do not include any other text, explanations, apologies, or markdown formatting.`;

      async function getGeminiSuggestions(
        promptOrImage,
        seedCount = "multi",
        isImage = false
      ) {
        addStepToMinimapQueue(
          isImage
            ? workflowSteps.MCP_WRAP_IMG_EXTRACT
            : workflowSteps.MCP_WRAP_SUGGEST,
          "mcp"
        );
        const systemPrompt =
          seedCount === "single"
            ? GEMINI_COLOR_SYSTEM_PROMPT_SINGLE
            : GEMINI_COLOR_SYSTEM_PROMPT_MULTI;
        const userPrompt = isImage
          ? "Extract color(s) based on the image."
          : promptOrImage;
        const imageBase64 = isImage ? promptOrImage : null;

        try {
          const jsonResponse = await getGeminiContent(
            config.geminiApiEndpointColorPicker,
            systemPrompt,
            userPrompt,
            true,
            false,
            isImage ? workflowSteps.LLM_SUGGEST : workflowSteps.LLM_SUGGEST,
            imageBase64
          );
          try {
            const parsed = JSON.parse(jsonResponse);
            if (seedCount === "single") {
              if (
                !parsed?.suggestion ||
                typeof parsed.suggestion !== "string" ||
                !/^#[0-9A-F]{6}$/i.test(parsed.suggestion)
              ) {
                throw new Error(
                  "Parsed JSON missing 'suggestion' string or invalid hex code."
                );
              }
              return {
                suggestions: [[parsed.suggestion, "#808080", "#A0A0A0"]],
              };
            } else {
              if (
                !parsed?.suggestions ||
                !Array.isArray(parsed.suggestions) ||
                parsed.suggestions.length === 0
              )
                throw new Error(
                  "Parsed JSON missing 'suggestions' array or is empty."
                );
              const validSuggestions = parsed.suggestions.filter(
                (s) =>
                  Array.isArray(s) &&
                  s.length === 3 &&
                  s.every(
                    (c) => typeof c === "string" && /^#[0-9A-F]{6}$/i.test(c)
                  )
              );
              if (validSuggestions.length === 0)
                throw new Error(
                  "No valid suggestions found. Check structure and hex codes."
                );
              return { suggestions: validSuggestions };
            }
          } catch (parseError) {
            console.error(
              "Failed to parse Gemini JSON response:",
              parseError,
              "\nReceived:",
              jsonResponse
            );
            throw new Error(
              `Model returned invalid JSON or structure: ${parseError.message}`
            );
          }
        } catch (apiError) {
          displaySuggestions([], isImage ? "image" : "text");
          throw apiError;
        }
      }
      async function simulateGeminiCall(promptText, seedCount = "multi") {
        addStepToMinimapQueue(workflowSteps.MCP_WRAP_SUGGEST, "mcp");
        await delay(600 + Math.random() * 400);
        const predefinedSets = [
          ["#6750A4", "#625B71", "#7D5260"],
          ["#00695C", "#4DB6AC", "#B2DFDB"],
          ["#B71C1C", "#EF9A9A", "#FFEBEE"],
          ["#0D47A1", "#90CAF9", "#E3F2FD"],
          ["#EF6C00", "#FFCA28", "#FFF9C4"],
          ["#4E342E", "#A1887F", "#D7CCC8"],
          ["#311B92", "#9575CD", "#EDE7F6"],
        ];
        let suggestions = [];
        if (seedCount === "single") {
          const randomIndex = Math.floor(Math.random() * predefinedSets.length);
          suggestions.push([
            predefinedSets[randomIndex][0],
            "#808080",
            "#A0A0A0",
          ]);
        } else {
          const availableIndices = [...Array(predefinedSets.length).keys()];
          while (suggestions.length < 3 && availableIndices.length > 0) {
            const randomIndex = Math.floor(
              Math.random() * availableIndices.length
            );
            const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
            suggestions.push(predefinedSets[selectedIndex]);
          }
        }
        addStepToMinimapQueue(workflowSteps.LLM_SUGGEST, "tool");
        return { suggestions };
      }
      async function simulateGeminiImageCall(imageBase64, seedCount = "multi") {
        addStepToMinimapQueue(workflowSteps.MCP_WRAP_IMG_EXTRACT, "mcp");
        await delay(800 + Math.random() * 500);
        return simulateGeminiCall("Simulated image prompt", seedCount);
      }

      async function getGeminiBestSuggestion(suggestions, promptText) {
        addStepToMinimapQueue(workflowSteps.MCP_WRAP_SELECT, "mcp");
        const GEMINI_SELECT_SYSTEM_PROMPT = `You are a design critic. Given a user prompt/image description and a list of 3 color palettes (each palette has Primary, Secondary, Tertiary hex codes), choose the single BEST palette that matches the user's prompt/image. Respond ONLY with the index number (0, 1, or 2) of the best matching palette. Do not include any other text, explanations, or formatting. Example Response: 1`;
        const userQuery = `User Prompt/Image Context: "${promptText}"\n\nPalettes:\n0: ${JSON.stringify(
          suggestions[0]
        )}\n1: ${JSON.stringify(suggestions[1])}\n2: ${JSON.stringify(
          suggestions[2]
        )}\n\nWhich index (0, 1, or 2) is the best match? Respond with only the index number.`;
        try {
          const responseText = await getGeminiContent(
            config.geminiApiEndpointColorPicker,
            GEMINI_SELECT_SYSTEM_PROMPT,
            userQuery,
            false,
            false,
            workflowSteps.LLM_SELECT_BEST
          );
          try {
            const index = parseInt(responseText.trim(), 10);
            if (isNaN(index) || index < 0 || index >= suggestions.length)
              return suggestions[0];
            return suggestions[index];
          } catch (parseError) {
            console.error("Gemini Best Suggestion Parse Error:", parseError);
            return suggestions[0];
          }
        } catch (apiError) {
          return suggestions[0];
        }
      }
      async function simulateBestSuggestion(suggestions, promptText) {
        addStepToMinimapQueue(workflowSteps.MCP_WRAP_SELECT, "mcp");
        await delay(300 + Math.random() * 200);
        const randomIndex = Math.floor(Math.random() * suggestions.length);
        addStepToMinimapQueue(workflowSteps.LLM_SELECT_BEST, "tool");
        return suggestions[randomIndex];
      }

      function displaySuggestions(suggestionData, type = "text") {
        const container =
          type === "image" ? dom.imageSuggestionsList : dom.suggestionsList;
        const parentDiv =
          type === "image"
            ? dom.imagePromptSuggestions
            : dom.textPromptSuggestions;
        const label =
          type === "image"
            ? placeholders.suggestionsLabelImage
            : placeholders.suggestionsLabelText;
        setHtml(container, "");
        parentDiv.querySelector(".selection-group-label").innerHTML = label;

        if (!suggestionData?.suggestions?.length) {
          setHtml(container, placeholders.noSuggestions);
          hideEl(parentDiv, false);
          addStepToMinimapQueue(workflowSteps.DISPLAY_SUGGESTIONS, "result");
          return;
        }
        const seedCount =
          type === "text"
            ? getSelectedValue(dom.textSeedCountSelection)
            : getSelectedValue(dom.imageSeedCountSelection);
        const isSingleSeed = seedCount === "single";

        suggestionData.suggestions.forEach((colorSet, index) => {
          const displaySet = isSingleSeed ? [colorSet[0]] : colorSet;
          if (
            !Array.isArray(displaySet) ||
            displaySet.length === 0 ||
            !displaySet.every((c) => /^#[0-9A-F]{6}$/i.test(c))
          )
            return;

          const div = createEl("div");
          div.className = "suggestion-option";
          div.dataset.colors = JSON.stringify(colorSet);
          div.dataset.type = type;
          setAttr(div, "role", "button");
          div.tabIndex = 0;
          const swatchesHtml = displaySet
            .map(
              (hex) =>
                `<span class="suggestion-swatch" style="background-color: ${hex};" title="${hex}"></span>`
            )
            .join("");
          const radioId = `${type}_suggestion_${index}`;
          setHtml(
            div,
            ` <input type="radio" name="${type}_suggestion_radio" id="${radioId}" value='${JSON.stringify(
              colorSet
            )}' class="hidden"> <label for="${radioId}">${swatchesHtml}<span>${
              isSingleSeed ? "Color " : "Option "
            }${index + 1}</span></label>`
          );
          div.addEventListener("click", handleSuggestionSelection);
          div.addEventListener("keydown", (e) => {
            if (e.key === " " || e.key === "Enter") {
              handleSuggestionSelection.call(div, e);
              e.preventDefault();
            }
          });
          container.appendChild(div);
        });

        if (container.querySelectorAll(".suggestion-option").length > 0) {
          hideEl(parentDiv, false);
        } else {
          setHtml(container, placeholders.noValidSuggestions);
          hideEl(parentDiv, false);
        }
        addStepToMinimapQueue(workflowSteps.DISPLAY_SUGGESTIONS, "result");
      }

      function applySuggestionToUI(
        colors,
        type = "text",
        markAsSelected = true
      ) {
        if (!Array.isArray(colors) || colors.length === 0)
          throw new Error("Invalid color data provided to apply.");
        const seedCount =
          type === "text"
            ? getSelectedValue(dom.textSeedCountSelection)
            : type === "image"
            ? getSelectedValue(dom.imageSeedCountSelection)
            : "multi";
        const isSingle = seedCount === "single";
        const count = isSingle ? 1 : 3;

        let sourceInputs = dom.sourceColorInputsContainer.querySelectorAll(
          'input[type="color"]'
        );
        if (sourceInputs.length < count) {
          updateColorPickers(seedCount);
          sourceInputs = dom.sourceColorInputsContainer.querySelectorAll(
            'input[type="color"]'
          );
          if (sourceInputs.length < count)
            throw new Error(
              "Failed to create source color inputs for applying suggestion."
            );
        }

        for (let i = 0; i < count; i++) {
          if (sourceInputs[i] && colors[i]) {
            sourceInputs[i].value = colors[i];
            disableEl(sourceInputs[i], false);
            sourceInputs[i].dispatchEvent(
              new Event("input", { bubbles: true })
            );
          }
        }
        for (let i = count; i < sourceInputs.length; i++) {
          disableEl(sourceInputs[i], true);
          sourceInputs[i].closest(".color-input-row").style.opacity = "0.5";
        }

        if (markAsSelected) {
          const container =
            type === "image" ? dom.imageSuggestionsList : dom.suggestionsList;
          container
            .querySelectorAll(".suggestion-option.selected")
            .forEach((el) => el.classList.remove("selected"));
          const matchingSuggestionDiv = Array.from(
            container.querySelectorAll(".suggestion-option")
          ).find((div) => div.dataset.colors === JSON.stringify(colors));
          if (matchingSuggestionDiv) {
            matchingSuggestionDiv.classList.add("selected");
            const radio = matchingSuggestionDiv.querySelector(
              'input[type="radio"]'
            );
            if (radio) radio.checked = true;
          }
        }
        hideError();
      }

      function applyScopedThemeStyles(theme) {
        if (!theme?.schemes) return;
        const lightCSS = [],
          darkCSS = [];
        const previewSelectorBase = `#mwc-component-preview, #gemini-component-preview`;
        for (const [schemeKey, scheme] of Object.entries(theme.schemes)) {
          const isDark = schemeKey === "dark";
          const selector = isDark
            ? `${previewSelectorBase}.dark-theme`
            : `${previewSelectorBase}:not(.dark-theme)`;
          const targetCSS = isDark ? darkCSS : lightCSS;
          targetCSS.push(`${selector} {`);
          for (const [token, value] of Object.entries(scheme)) {
            if (typeof value === "number")
              targetCSS.push(
                `--local-sys-color-${kebabCase(token)}: ${argbIntToHex(value)};`
              );
          }
          targetCSS.push("}");
        }
        setText(
          dom.dynamicThemeStyles,
          `${lightCSS.join("\n")}\n${darkCSS.join("\n")}`
        );
      }
      function handleGenerateMwcComponents() {
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        if (!state.lastGeneratedTheme?.schemes) {
          showError("Please generate a theme first.");
          return;
        }
        addStepToMinimapQueue(workflowSteps.CLICK_GEN_MWC, "human");
        addStepToMinimapQueue(workflowSteps.TOOL_RENDER_MWC, "tool");
        applyScopedThemeStyles(state.lastGeneratedTheme);
        const mwcHTML = ` <div style="display:flex;flex-direction:column;gap:25px;"> <div> <h5>Buttons & FAB</h5> <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;"> <md-filled-button>Filled</md-filled-button> <md-outlined-button>Outlined</md-outlined-button> <md-fab aria-label="Edit"><md-icon slot="icon">edit</md-icon></md-fab> </div> </div> <div> <h5>Chips</h5> <md-chip-set style="display:flex;flex-wrap:wrap;gap:8px;"> <md-assist-chip label="Assist"></md-assist-chip> <md-filter-chip label="Filter" elevated></md-filter-chip> <md-suggestion-chip label="Suggest"></md-suggestion-chip> </md-chip-set> </div> <div> <h5>Slider</h5> <md-slider ticks value="65" style="width: 80%;"></md-slider> </div> <div> <h5>Card</h5> <md-card style="padding:16px;max-width:350px;"> <p style="margin:0; font-weight: 500;">The Music Dance Experience is officially CANCELED.</p> </md-card> </div> </div>`;
        setHtml(dom.mwcComponentPreview, `<h4>MWC Preview</h4> ${mwcHTML}`);
        toggleClass(dom.mwcComponentPreview, "dark-theme", state.isDarkMode);
        addStepToMinimapQueue(workflowSteps.DISPLAY_COMPONENTS, "result");
      }
      const GEMINI_COMPONENT_SYSTEM_PROMPT = `You are an expert web UI designer specializing in Material Design 3. You will be given: 1. A Material Design 3 color theme represented as CSS custom properties starting with '--local-sys-color-...'. Use these variables directly in your CSS. 2. An optional user style prompt. Your task is to: - Create an HTML structure containing ONLY the following components IN THIS ORDER: - Two buttons: one filled (<button class="gemini-filled-button">Filled</button>), one outlined (<button class="gemini-outlined-button">Outlined</button>). - One Floating Action Button (FAB) (<button class="gemini-fab"><span class="material-icons">edit</span></button>). Use standard HTML button and span. - Three chips (<span class="gemini-chip">Assist</span>, <span class="gemini-chip gemini-elevated">Filter</span>, <span class="gemini-chip">Suggest</span>). Use standard HTML spans. - One slider element (<input type="range" class="gemini-slider" value="65">). Use standard HTML range input. - One card (<div class="gemini-card"><p>The Music Dance Experience is officially CANCELED.</p></div>). Use standard HTML divs/paragraphs. - Apply styling using ONLY CSS classes defined within a SINGLE '<style>' tag. Define base styles first, then dark mode overrides using a '.dark-theme' prefix. - **CRITICAL:** Use the provided --local-sys-color-... CSS variables extensively and semantically for ALL colors (backgrounds, text, borders, icons, states like :hover). - Incorporate the user's style prompt subtly. If no prompt, use standard Material Design appearance. - Ensure output is visually coherent, uses appropriate padding/margins. - Respond ONLY with the final combined HTML structure (using specified tags/classes) and the single '<style>' tag. No explanations, markdown, <!DOCTYPE>, <html>, <body>.`;
      async function handleGenerateGeminiComponents() {
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        if (!state.lastGeneratedTheme) {
          showError("Generate a theme first.");
          return;
        }
        if (!config.isApiConfigValid) {
          showError("Gemini API is not configured.");
          return;
        }
        addStepToMinimapQueue(workflowSteps.CLICK_GEN_GEMINI, "human");
        addStepToMinimapQueue(workflowSteps.MCP_WRAP_GEN_COMP, "mcp");
        setGeminiComponentLoading(true);
        setHtml(dom.geminiComponentPreview, "");
        hideError();
        try {
          const stylePrompt = dom.componentStylePromptInput.value.trim();
          let themeVariablesString = ":root {\n";
          if (state.lastGeneratedTheme.schemes.light) {
            for (const [token, value] of Object.entries(
              state.lastGeneratedTheme.schemes.light
            )) {
              if (typeof value === "number")
                themeVariablesString += ` --local-sys-color-${kebabCase(
                  token
                )}: ${argbIntToHex(value)};\n`;
            }
            themeVariablesString += "}";
          }
          const fullPrompt = `MATERIAL DESIGN 3 THEME VARIABLES (Use these in CSS):\n\`\`\`css\n${themeVariablesString}\n\`\`\`\n\nUSER STYLE PROMPT: ${
            stylePrompt || "Default clean Material Design style."
          }\n\nGenerate HTML/CSS using EXACT tags/classes specified. Use --local-sys-color-... variables.`;
          const useM3Guidance = dom.useM3GuidanceCheckbox.checked;
          const generatedHtmlAndCss = await getGeminiContent(
            config.geminiApiEndpointComponentGenerator,
            GEMINI_COMPONENT_SYSTEM_PROMPT,
            fullPrompt,
            false,
            useM3Guidance,
            workflowSteps.LLM_GEN_COMP
          );
          const cleanedHtmlCss = generatedHtmlAndCss
            .replace(/^\s*```(?:html|css|markup|)\s*\n?/im, "")
            .replace(/\n?\s*```\s*$/im, "")
            .trim();
          setHtml(
            dom.geminiComponentPreview,
            `<h4>Gemini Preview</h4> ${cleanedHtmlCss}`
          );
          toggleClass(
            dom.geminiComponentPreview,
            "dark-theme",
            state.isDarkMode
          );
          applyScopedThemeStyles(state.lastGeneratedTheme);
          addStepToMinimapQueue(workflowSteps.DISPLAY_COMPONENTS, "result");
        } catch (error) {
          showError(`Gemini component generation failed: ${error.message}`);
          setHtml(dom.geminiComponentPreview, placeholders.geminiPreviewError);
        } finally {
          setGeminiComponentLoading(false);
        }
      }
      function handleSuggestionSelection(event) {
        if (audio.context && audio.context.state === "suspended")
          audio.context.resume();
        const selectedDiv = event.currentTarget;
        event.preventDefault();
        const colorsJson = selectedDiv.dataset.colors;
        const type = selectedDiv.dataset.type || "text";
        if (!colorsJson) return;
        try {
          const colors = JSON.parse(colorsJson);
          state.selectedSuggestion[type] = colors;
          applySuggestionToUI(colors, type, false);
          const container =
            type === "image" ? dom.imageSuggestionsList : dom.suggestionsList;
          container
            .querySelectorAll(".suggestion-option.selected")
            .forEach((el) => el.classList.remove("selected"));
          selectedDiv.classList.add("selected");
          const radio = selectedDiv.querySelector('input[type="radio"]');
          if (radio) radio.checked = true;
          addStepToMinimapQueue(workflowSteps.SELECT_SUGGESTION, "human");
        } catch (error) {
          showError(`Failed to apply suggestion: ${error.message}`);
        }
      }
      async function generateThemeInternal(seeds, options) {
        if (!seeds || seeds.length === 0)
          throw new Error(
            "No valid seed colors provided for theme generation."
          );
        addStepToMinimapQueue(workflowSteps.TOOL_COLOR_MATH, "tool");
        let theme;
        if (seeds.length === 1) {
          theme = themeFromSourceColor(seeds[0]);
        } else {
          theme = themeFromSourceColors(seeds, options);
        }
        return { theme, seeds };
      }

      async function handleProcessTextClick() {
        const promptText = dom.textPromptInput.value.trim();
        if (!promptText) {
          showError("Please enter a theme description first.");
          return;
        }
        addStepToMinimapQueue(workflowSteps.CLICK_PROCESS_TEXT, "human");
        hideError();
        setSuggestionLoading(true, "text");
        hideEl(dom.textPromptSuggestions, true);
        setHtml(dom.suggestionsList, "");
        state.lastSuggestions.text = null;
        state.selectedSuggestion.text = null;

        try {
          const useSim = dom.useSimulationCheckbox.checked;
          const useApi = !useSim && config.isApiConfigValid;
          const seedCount = getSelectedValue(dom.textSeedCountSelection);
          let data;
          if (useApi) {
            data = await getGeminiSuggestions(promptText, seedCount, false);
          } else if (!config.isApiConfigValid && !useSim) {
            showError(
              "Gemini API not configured. Check simulation box or configure API."
            );
            setHtml(dom.suggestionsList, placeholders.suggestionsApiError);
            hideEl(dom.textPromptSuggestions, false);
            addStepToMinimapQueue(workflowSteps.ERROR, "error");
            return;
          } else {
            data = await simulateGeminiCall(promptText, seedCount);
          }
          state.lastSuggestions.text = data.suggestions;
          displaySuggestions(data, "text");
        } catch (error) {
          showError(`Failed to get text suggestions: ${error.message}`);
          setHtml(dom.suggestionsList, placeholders.suggestionsLoadError);
          hideEl(dom.textPromptSuggestions, false);
        } finally {
          setSuggestionLoading(false, "text");
        }
      }

      async function handleProcessImageGeminiClick() {
        if (!state.currentImageFile) {
          showError("Please upload an image first.");
          return;
        }
        addStepToMinimapQueue(workflowSteps.CLICK_PROCESS_IMAGE, "human");
        hideError();
        setSuggestionLoading(true, "image");
        hideEl(dom.imagePromptSuggestions, true);
        setHtml(dom.imageSuggestionsList, "");
        state.lastSuggestions.image = null;
        state.selectedSuggestion.image = null;

        try {
          const useSim = dom.useSimulationCheckbox.checked;
          const useApi = !useSim && config.isApiConfigValid;
          const seedCount = getSelectedValue(dom.imageSeedCountSelection);
          const imageBase64 = dom.imagePreview.src;
          let data;

          if (useApi) {
            data = await getGeminiSuggestions(imageBase64, seedCount, true);
          } else if (!config.isApiConfigValid && !useSim) {
            showError(
              "Gemini API not configured. Check simulation box or configure API."
            );
            setHtml(dom.imageSuggestionsList, placeholders.suggestionsApiError);
            hideEl(dom.imagePromptSuggestions, false);
            addStepToMinimapQueue(workflowSteps.ERROR, "error");
            return;
          } else {
            data = await simulateGeminiImageCall(imageBase64, seedCount);
          }
          state.lastSuggestions.image = data.suggestions;
          displaySuggestions(data, "image");
        } catch (error) {
          showError(`Failed to get image suggestions: ${error.message}`);
          setHtml(dom.imageSuggestionsList, placeholders.suggestionsLoadError);
          hideEl(dom.imagePromptSuggestions, false);
        } finally {
          setSuggestionLoading(false, "image");
        }
      }

      async function performAutoSelection(
        suggestions,
        contextPrompt,
        useApi,
        type
      ) {
        const wrapStep =
          type === "image"
            ? workflowSteps.MCP_WRAP_IMG_EXTRACT
            : workflowSteps.MCP_WRAP_SUGGEST;
        const selectStep = workflowSteps.MCP_WRAP_SELECT;
        addStepToMinimapQueue(wrapStep, "mcp");
        addStepToMinimapQueue(selectStep, "mcp");
        let bestSuggestion;
        if (useApi) {
          bestSuggestion = await getGeminiBestSuggestion(
            suggestions,
            contextPrompt
          );
        } else {
          bestSuggestion = await simulateBestSuggestion(
            suggestions,
            contextPrompt
          );
        }
        addStepToMinimapQueue(workflowSteps.APPLY_LLM_SELECTION, "decision");
        return bestSuggestion;
      }

      async function handleGenerateClick() {
        addStepToMinimapQueue(workflowSteps.CLICK_GENERATE, "human");
        const source = state.currentInputSource;
        let seeds = [];
        let themeOptions = {};
        let autoInvokedTool = false;
        const useSim = dom.useSimulationCheckbox.checked;
        const useApi = !useSim && config.isApiConfigValid;
        const generationMethod = getSelectedValue(
          dom.paletteGenerationMethodSelection
        );
        state.generationMethod = generationMethod;

        setUILoading(true, source);
        setHtml(dom.paletteDisplay, placeholders.generating);
        setHtml(dom.seedColorsDisplayContainer, "");
        hideError();

        const dreamExists =
          typeof themeFromSourceColor === "function" &&
          typeof themeFromSourceColors === "function" &&
          (!config.ENABLE_IMAGES ||
            (typeof sourceColorFromImage === "function" &&
              typeof sourceColorsFromImage === "function"));
        if (
          !dreamExists &&
          (generationMethod === "dreamjs" ||
            generationMethod === "gemini_mcp" ||
            generationMethod === "manual_mcp")
        ) {
          showError(
            "Core color generation library (dream.js) not found for selected method."
          );
          setUILoading(false);
          return;
        }

        try {
          addStepToMinimapQueue(workflowSteps.MCP_WRAP_GENERATE, "mcp");
          let contextPrompt = "";

          if (source === "text") {
            contextPrompt = dom.textPromptInput.value.trim();
            const selectionMethod = getSelectedValue(
              dom.textSelectionMethodSelection
            );
            const seedCount = getSelectedValue(dom.textSeedCountSelection);
            if (
              selectionMethod === "gemini" ||
              selectionMethod === "gemini_mcp"
            ) {
              if (!state.lastSuggestions.text)
                throw new Error(
                  "Please process the text prompt first to get suggestions for auto-selection."
                );
              if (!contextPrompt)
                throw new Error(
                  "Please enter a theme description for auto-selection."
                );
              const bestSuggestion = await performAutoSelection(
                state.lastSuggestions.text,
                contextPrompt,
                useApi,
                "text"
              );
              state.selectedSuggestion.text = bestSuggestion;
              applySuggestionToUI(bestSuggestion, "text", true);
              seeds = bestSuggestion.map((hex, i) =>
                validateAndConvertHex(hex, `LLM Text Color ${i + 1}`)
              );
              if (
                selectionMethod === "gemini_mcp" &&
                (generationMethod === "gemini_mcp" ||
                  generationMethod === "manual_mcp")
              )
                autoInvokedTool = true;
            } else {
              if (!state.selectedSuggestion.text)
                throw new Error("Please select a suggested color set first.");
              seeds = state.selectedSuggestion.text.map((hex, i) =>
                validateAndConvertHex(hex, `Selected Text Color ${i + 1}`)
              );
            }
            themeOptions = {};
          } else if (source === "color") {
            const seedCount = getSelectedValue(dom.colorSeedCountSelection);
            const isMulti = seedCount === "multi";
            const count = isMulti ? 3 : 1;
            const inputs = Array.from(
              dom.sourceColorInputsContainer.querySelectorAll(
                'input[type="color"]'
              )
            ).slice(0, count);
            if (inputs.length < count)
              throw new Error(
                `Expected ${count} color picker(s), found ${inputs.length}.`
              );
            seeds = inputs
              .map((input, idx) => {
                if (input.disabled) return null;
                const label =
                  input.previousElementSibling?.textContent ||
                  `Color ${idx + 1}`;
                return validateAndConvertHex(input.value, label);
              })
              .filter((v) => typeof v === "number");
            if (seeds.length === 0)
              throw new Error("Please provide valid source color(s).");
            if (isMulti)
              themeOptions.harmonyStrategy = dom.harmonyStrategySelect.value;
            contextPrompt = `User selected color(s): ${seeds
              .map(argbIntToHex)
              .join(", ")}`;
          } else if (source === "image") {
            if (
              !state.currentImageFile ||
              !dom.imagePreview.src ||
              dom.imagePreview.src.startsWith("#")
            )
              throw new Error("Please upload an image first.");
            contextPrompt = "Image Analysis Context";
            const extractionMethod = getSelectedValue(
              dom.imageExtractionMethodSelection
            );
            const seedCount = getSelectedValue(dom.imageSeedCountSelection);
            if (extractionMethod === "gemini") {
              const selectionMethod = getSelectedValue(
                dom.imageSelectionMethodSelection
              );
              if (
                selectionMethod === "gemini" ||
                selectionMethod === "gemini_mcp"
              ) {
                if (!state.lastSuggestions.image)
                  throw new Error(
                    "Please process the image with Gemini first to get suggestions."
                  );
                const bestSuggestion = await performAutoSelection(
                  state.lastSuggestions.image,
                  contextPrompt,
                  useApi,
                  "image"
                );
                state.selectedSuggestion.image = bestSuggestion;
                applySuggestionToUI(bestSuggestion, "image", true);
                seeds = bestSuggestion.map((hex, i) =>
                  validateAndConvertHex(hex, `LLM Image Color ${i + 1}`)
                );
                if (
                  selectionMethod === "gemini_mcp" &&
                  (generationMethod === "gemini_mcp" ||
                    generationMethod === "manual_mcp")
                )
                  autoInvokedTool = true;
              } else {
                if (!state.selectedSuggestion.image)
                  throw new Error(
                    "Please select a suggested color set from the image first."
                  );
                seeds = state.selectedSuggestion.image.map((hex, i) =>
                  validateAndConvertHex(hex, `Selected Image Color ${i + 1}`)
                );
              }
              themeOptions = {};
            } else {
              addStepToMinimapQueue(
                workflowSteps.TOOL_IMAGE_PROC_DREAM,
                "tool"
              );
              const img = await loadImageFromSrc(dom.imagePreview.src);
              if (seedCount === "single") {
                const srcColor = await sourceColorFromImage(img);
                if (typeof srcColor !== "number")
                  throw new Error(
                    "Failed to extract dominant color from image using Dream.js."
                  );
                seeds = [srcColor];
              } else {
                const num = parseInt(dom.numSourcesInput.value, 10) || 3;
                const qual = parseInt(dom.extractQualityInput.value, 10) || 10;
                seeds = await sourceColorsFromImage(img, num, qual);
                if (!seeds?.length)
                  throw new Error(
                    "Failed to extract multiple colors from image using Dream.js."
                  );
                themeOptions.harmonyStrategy = "direct";
              }
            }
          } else {
            throw new Error(
              "Invalid or unsupported generation source selected."
            );
          }

          const finalSeeds = seeds.filter((s) => typeof s === "number");
          if (finalSeeds.length === 0) {
            throw new Error(
              "No valid seed colors could be determined for generation."
            );
          }

          let themeResult;
          if (generationMethod === "dreamjs") {
            themeResult = await generateThemeInternal(finalSeeds, themeOptions);
          } else if (
            generationMethod === "gemini_mcp" ||
            (autoInvokedTool && generationMethod === "manual_mcp")
          ) {
            addStepToMinimapQueue(workflowSteps.MCP_INVOKE_TOOL, "mcp");
            if (generationMethod === "manual_mcp") {
              themeResult = await simulateDreamJSTheme(
                finalSeeds,
                themeOptions
              );
            } else {
              themeResult = await generateThemeInternal(
                finalSeeds,
                themeOptions
              );
            }
          } else if (generationMethod === "manual_mcp") {
            addStepToMinimapQueue(workflowSteps.MCP_INVOKE_TOOL, "mcp");
            themeResult = await simulateDreamJSTheme(finalSeeds, themeOptions);
          } else if (generationMethod === "gemini_only") {
            addStepToMinimapQueue(workflowSteps.LLM_GEN_PALETTE, "llm");
            themeResult = await generateGeminiPalette(
              finalSeeds,
              contextPrompt || "Color palette",
              useApi
            );
          } else {
            throw new Error(`Unknown generation method: ${generationMethod}`);
          }

          if (themeResult && themeResult.theme) {
            state.lastGeneratedTheme = themeResult.theme;
            displaySeedColors(finalSeeds, themeResult.seeds || finalSeeds);
            displayTheme(themeResult.theme);
            updatePhaseCardStyle(dom.phase2Card, generationMethod);
          } else {
            showError("Theme generation failed. No theme object was returned.");
          }
        } catch (error) {
          showError(`Generation Error: ${error.message}`);
          setHtml(dom.paletteDisplay, placeholders.paletteError);
        } finally {
          setUILoading(false);
          toggleBackButton(true);
        }
      }

      function updatePhaseCardStyle(cardElement, method) {
        cardElement.classList.remove(
          "phase-local-tool",
          "phase-mcp-tool",
          "phase-llm-decision"
        );
        if (method === "dreamjs") cardElement.classList.add("phase-local-tool");
        else if (method === "gemini_mcp" || method === "manual_mcp")
          cardElement.classList.add("phase-mcp-tool");
        else if (method === "gemini_only")
          cardElement.classList.add("phase-llm-decision");
      }

      async function simulateDreamJSTheme(seeds, options) {
        addStepToMinimapQueue(workflowSteps.TOOL_COLOR_MATH, "tool");
        await delay(500 + Math.random() * 300);
        if (Math.random() < 0.2)
          throw new Error("Simulated Dream.js tool failure.");
        return generateThemeInternal(seeds, options);
      }

      async function generateGeminiPalette(seeds, contextPrompt, useApi) {
        if (!useApi) {
          await delay(400 + Math.random() * 200);
          if (
            typeof themeFromSourceColor === "function" &&
            typeof themeFromSourceColors === "function"
          ) {
            showError(
              "Gemini API not available, falling back to Dream.js simulation for palette generation."
            );
            return simulateDreamJSTheme(seeds, {});
          } else {
            throw new Error(
              "Gemini API not available and Dream.js fallback also failed."
            );
          }
        }
        const seedHexes = seeds.map(argbIntToHex);
        const userQuery = `Generate a Material Design 3 color palette in JSON format based on these seed colors: ${JSON.stringify(
          seedHexes
        )}. Context: ${contextPrompt}. Include light and dark schemes, and palettes for primary, secondary, tertiary, neutral, neutral variant, and error. Ensure the output ONLY contains the valid JSON object with 'palettes' and 'schemes' keys, following the structure used by material-color-utilities.`;
        try {
          const jsonResponse = await getGeminiContent(
            config.geminiApiEndpointComponentGenerator,
            `You are a Material Design 3 color palette generator. Output ONLY valid JSON matching the material-color-utilities theme structure.`,
            userQuery,
            true,
            false,
            workflowSteps.LLM_GEN_PALETTE
          );
          const parsed = JSON.parse(jsonResponse);

          if (
            !parsed ||
            typeof parsed !== "object" ||
            !parsed.schemes ||
            typeof parsed.schemes !== "object" ||
            !parsed.palettes ||
            typeof parsed.palettes !== "object"
          ) {
            throw new Error(
              "Invalid palette JSON response structure from Gemini."
            );
          }
          if (
            !parsed.schemes.light ||
            !parsed.schemes.dark ||
            !parsed.palettes.primary ||
            !parsed.palettes.secondary ||
            !parsed.palettes.tertiary ||
            !parsed.palettes.neutral ||
            !parsed.palettes.neutralVariant ||
            !parsed.palettes.error
          ) {
            console.warn(
              "Gemini palette response missing some standard keys, using what's available.",
              parsed
            );
          }
          const convertScheme = (scheme) =>
            Object.fromEntries(
              Object.entries(scheme).map(([key, value]) => [
                key,
                typeof value === "string" && value.startsWith("#")
                  ? hexToArgbInt(value)
                  : value,
              ])
            );
          const convertPalette = (palette) =>
            Object.fromEntries(
              Object.entries(palette).map(([key, value]) => [
                key,
                typeof value === "string" && value.startsWith("#")
                  ? hexToArgbInt(value)
                  : value,
              ])
            );

          const themeWithInts = {
            source: seeds[0],
            schemes: {
              light: parsed.schemes.light
                ? convertScheme(parsed.schemes.light)
                : {},
              dark: parsed.schemes.dark
                ? convertScheme(parsed.schemes.dark)
                : {},
            },
            palettes: {
              primary: parsed.palettes.primary
                ? convertPalette(parsed.palettes.primary)
                : {},
              secondary: parsed.palettes.secondary
                ? convertPalette(parsed.palettes.secondary)
                : {},
              tertiary: parsed.palettes.tertiary
                ? convertPalette(parsed.palettes.tertiary)
                : {},
              neutral: parsed.palettes.neutral
                ? convertPalette(parsed.palettes.neutral)
                : {},
              neutralVariant: parsed.palettes.neutralVariant
                ? convertPalette(parsed.palettes.neutralVariant)
                : {},
              error: parsed.palettes.error
                ? convertPalette(parsed.palettes.error)
                : {},
            },
            customColors: parsed.customColors || [],
          };

          return { theme: themeWithInts, seeds };
        } catch (apiError) {
          showError(
            `Gemini Palette API Error: ${apiError.message}. Falling back to Dream.js simulation.`
          );
          return simulateDreamJSTheme(seeds, {});
        }
      }

      function handleBackButtonClick() {
        if (state.history.length <= 1) {
          resetMinimapToBase();
          state.history = [];
          toggleBackButton(false);
          return;
        }
        state.history.pop();
        const prevState = state.history[state.history.length - 1];
        if (!prevState) {
          resetMinimapToBase();
          state.history = [];
          toggleBackButton(false);
          return;
        }
        restoreFullState(prevState);
        addStepToMinimapQueue(workflowSteps.GO_BACK, "decision");
        if (state.history.length <= 1) toggleBackButton(false);
      }

      function toggleBackButton(show) {
        hideEl(dom.backButtonArea, !show);
      }

      function saveFullState() {
        const currentState = {
          ...state,
          currentMinimapSteps: [...state.currentMinimapSteps],
          selectedSuggestion: { ...state.selectedSuggestion },
          lastSuggestions: { ...state.lastSuggestions },
          history: undefined,

          inputSourceValue: getSelectedValue(dom.inputSourceSelection),
          textPromptInputValue: dom.textPromptInput.value,
          textSeedCountValue: getSelectedValue(dom.textSeedCountSelection),
          textSelectionMethodValue: getSelectedValue(
            dom.textSelectionMethodSelection
          ),
          colorSeedCountValue: getSelectedValue(dom.colorSeedCountSelection),
          harmonyStrategyValue: dom.harmonyStrategySelect.value,
          imageExtractionMethodValue: getSelectedValue(
            dom.imageExtractionMethodSelection
          ),
          imageSeedCountValue: getSelectedValue(dom.imageSeedCountSelection),
          imageSelectionMethodValue: getSelectedValue(
            dom.imageSelectionMethodSelection
          ),
          numSourcesInputValue: dom.numSourcesInput.value,
          extractQualityInputValue: dom.extractQualityInput.value,
          paletteGenerationMethodValue: getSelectedValue(
            dom.paletteGenerationMethodSelection
          ),
          useSimulationChecked: dom.useSimulationCheckbox.checked,
          componentStylePromptValue: dom.componentStylePromptInput.value,
          useM3GuidanceChecked: dom.useM3GuidanceCheckbox.checked,

          suggestionsListHTML: dom.suggestionsList.innerHTML,
          imageSuggestionsListHTML: dom.imageSuggestionsList.innerHTML,
          sourceColorInputsHTML: dom.sourceColorInputsContainer.innerHTML,
          seedColorsDisplayHTML: dom.seedColorsDisplayContainer.innerHTML,
          paletteDisplayHTML: dom.paletteDisplay.innerHTML,
          mwcComponentPreviewHTML: dom.mwcComponentPreview.innerHTML,
          geminiComponentPreviewHTML: dom.geminiComponentPreview.innerHTML,

          textOptionsGroupHidden:
            dom.textOptionsGroup.classList.contains("hidden"),
          colorOptionsGroupHidden:
            dom.colorOptionsGroup.classList.contains("hidden"),
          imageOptionsGroupHidden:
            dom.imageOptionsGroup.classList.contains("hidden"),
          textPromptSuggestionsHidden:
            dom.textPromptSuggestions.classList.contains("hidden"),
          imagePromptSuggestionsHidden:
            dom.imagePromptSuggestions.classList.contains("hidden"),
          imagePreviewHidden: dom.imagePreview.classList.contains("hidden"),
          componentExamplesHidden:
            dom.componentExamplesDiv.classList.contains("hidden"),
          errorMessageHidden: dom.errorMessageDiv.classList.contains("hidden"),
          errorMessageText: dom.errorMessageDiv.textContent,
        };
        state.history.push(currentState);
      }

      function restoreFullState(prevState) {
        state.currentImageFile = prevState.currentImageFile;
        state.currentInputSource = prevState.currentInputSource;
        state.lastGeneratedTheme = prevState.lastGeneratedTheme;
        state.isDarkMode = prevState.isDarkMode;
        state.m3ContentCache = prevState.m3ContentCache;
        state.currentMinimapSteps = [...prevState.currentMinimapSteps];
        state.selectedSuggestion = { ...prevState.selectedSuggestion };
        state.lastSuggestions = { ...prevState.lastSuggestions };
        state.generationMethod = prevState.generationMethod;
        state.currentPhaseCardId = prevState.currentPhaseCardId;

        setSelectedChip(dom.inputSourceSelection, prevState.inputSourceValue);
        dom.textPromptInput.value = prevState.textPromptInputValue;
        setSelectedChip(
          dom.textSeedCountSelection,
          prevState.textSeedCountValue
        );
        setSelectedChip(
          dom.textSelectionMethodSelection,
          prevState.textSelectionMethodValue
        );
        setSelectedChip(
          dom.colorSeedCountSelection,
          prevState.colorSeedCountValue
        );
        dom.harmonyStrategySelect.value = prevState.harmonyStrategyValue;
        setSelectedChip(
          dom.imageExtractionMethodSelection,
          prevState.imageExtractionMethodValue
        );
        setSelectedChip(
          dom.imageSeedCountSelection,
          prevState.imageSeedCountValue
        );
        setSelectedChip(
          dom.imageSelectionMethodSelection,
          prevState.imageSelectionMethodValue
        );
        dom.numSourcesInput.value = prevState.numSourcesInputValue;
        dom.extractQualityInput.value = prevState.extractQualityInputValue;
        setSelectedChip(
          dom.paletteGenerationMethodSelection,
          prevState.paletteGenerationMethodValue
        );
        dom.useSimulationCheckbox.checked = prevState.useSimulationChecked;
        dom.componentStylePromptInput.value =
          prevState.componentStylePromptValue;
        dom.useM3GuidanceCheckbox.checked = prevState.useM3GuidanceChecked;

        // Restore HTML Content
        setHtml(dom.suggestionsList, prevState.suggestionsListHTML);
        setHtml(dom.imageSuggestionsList, prevState.imageSuggestionsListHTML);
        setHtml(
          dom.sourceColorInputsContainer,
          prevState.sourceColorInputsHTML
        );
        setHtml(
          dom.seedColorsDisplayContainer,
          prevState.seedColorsDisplayHTML
        );
        setHtml(dom.paletteDisplay, prevState.paletteDisplayHTML);
        setHtml(dom.mwcComponentPreview, prevState.mwcComponentPreviewHTML);
        setHtml(
          dom.geminiComponentPreview,
          prevState.geminiComponentPreviewHTML
        );

        hideEl(dom.textOptionsGroup, prevState.textOptionsGroupHidden);
        hideEl(dom.colorOptionsGroup, prevState.colorOptionsGroupHidden);
        hideEl(dom.imageOptionsGroup, prevState.imageOptionsGroupHidden);
        hideEl(
          dom.textPromptSuggestions,
          prevState.textPromptSuggestionsHidden
        );
        hideEl(
          dom.imagePromptSuggestions,
          prevState.imagePromptSuggestionsHidden
        );
        hideEl(dom.imagePreview, prevState.imagePreviewHidden);
        hideEl(dom.componentExamplesDiv, prevState.componentExamplesHidden);
        hideEl(dom.errorMessageDiv, prevState.errorMessageHidden);
        setText(dom.errorMessageDiv, prevState.errorMessageText);

        if (state.lastGeneratedTheme)
          applyScopedThemeStyles(state.lastGeneratedTheme);
        renderMinimap();
        attachSuggestionListeners(dom.suggestionsList);
        attachSuggestionListeners(dom.imageSuggestionsList);
        if (state.currentPhaseCardId) {
          const card = getEl(state.currentPhaseCardId);
          if (card) updatePhaseCardStyle(card, state.generationMethod);
        }
        updatePhase1UI();
      }

      function setSelectedChip(chipGroup, value) {
        if (!chipGroup || !value) return;
        chipGroup.querySelectorAll('input[type="radio"]').forEach((radio) => {
          radio.checked = radio.value === value;
        });
      }

      function attachSuggestionListeners(container) {
        container?.querySelectorAll(".suggestion-option").forEach((div) => {
          div.removeEventListener("click", handleSuggestionSelection);
          div.removeEventListener("keydown", handleSuggestionKeydown);
          div.addEventListener("click", handleSuggestionSelection);
          div.addEventListener("keydown", handleSuggestionKeydown);
        });
      }

      function handleSuggestionKeydown(e) {
        if (e.key === " " || e.key === "Enter") {
          handleSuggestionSelection.call(this, e);
          e.preventDefault();
        }
      }

      function setupEventListeners() {
        dom.inputSourceSelection.addEventListener(
          "change",
          handleInputSourceChange
        );

        $$(".chip-selection-group").forEach((group) => {
          group.addEventListener("change", handleOptionChange);
        });

        dom.dropArea.addEventListener("click", () => dom.imageInput.click());
        dom.dropArea.addEventListener("dragover", (e) => {
          e.preventDefault();
          dom.dropArea.classList.add("drag-over");
        });
        dom.dropArea.addEventListener("dragleave", () =>
          dom.dropArea.classList.remove("drag-over")
        );
        dom.dropArea.addEventListener("drop", (e) => {
          e.preventDefault();
          dom.dropArea.classList.remove("drag-over");
          if (e.dataTransfer.files.length)
            handleImageFile(e.dataTransfer.files[0]);
        });
        dom.imageInput.addEventListener("change", (e) => {
          if (e.target.files.length) handleImageFile(e.target.files[0]);
        });

        dom.processTextButton.addEventListener("click", () => {
          saveFullState();
          handleProcessTextClick();
        });
        dom.processImageGeminiButton.addEventListener("click", () => {
          saveFullState();
          handleProcessImageGeminiClick();
        });
        dom.generateButton.addEventListener("click", () => {
          saveFullState();
          handleGenerateClick();
        });
        dom.generateMwcComponentsButton.addEventListener(
          "click",
          handleGenerateMwcComponents
        );
        dom.generateGeminiComponentsButton.addEventListener(
          "click",
          handleGenerateGeminiComponents
        );

        dom.themeToggleButton.addEventListener("click", handleThemeToggle);

        dom.backButton.addEventListener("click", handleBackButtonClick);

        attachSuggestionListeners(dom.suggestionsList);
        attachSuggestionListeners(dom.imageSuggestionsList);
      }

      function initializeApp() {
        loadConfig();
        setupThemeToggle();
        applyFeatureVisibility();
        setupEventListeners();
        document.body.addEventListener("click", initializeAudio, {
          once: true,
        });
        resetMinimapToBase();
        saveFullState();
        toggleBackButton(false);
      }

      document.addEventListener("DOMContentLoaded", (event) => {
        initializeApp();
      });
    </script>
  </body>
</html>
