<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>
        MILCHICK: Material Integration Leveraging Creative Human-LLM Intelligence
        Colors Kit
      </title>
      <link
        href="https://fonts.googleapis.com/icon?family=Material+Icons"
        rel="stylesheet"
      />
    </head>
  
    <style>
      * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --md-sys-color-primary-light: #6750a4;
  --md-sys-color-on-primary-light: #ffffff;
  --md-sys-color-primary-container-light: #eaddff;
  --md-sys-color-on-primary-container-light: #21005d;
  --md-sys-color-secondary-light: #625b71;
  --md-sys-color-on-secondary-light: #ffffff;
  --md-sys-color-secondary-container-light: #e8def8;
  --md-sys-color-on-secondary-container-light: #1d192b;
  --md-sys-color-tertiary-light: #7d5260;
  --md-sys-color-on-tertiary-light: #ffffff;
  --md-sys-color-tertiary-container-light: #ffd8e4;
  --md-sys-color-on-tertiary-container-light: #31111d;
  --md-sys-color-error-light: #b3261e;
  --md-sys-color-on-error-light: #ffffff;
  --md-sys-color-error-container-light: #f9dedc;
  --md-sys-color-on-error-container-light: #410e0b;
  --md-sys-color-background-light: #fffbfe;
  --md-sys-color-on-background-light: #1c1b1f;
  --md-sys-color-surface-light: #fffbfe;
  --md-sys-color-on-surface-light: #1c1b1f;
  --md-sys-color-surface-variant-light: #e7e0ec;
  --md-sys-color-on-surface-variant-light: #49454f;
  --md-sys-color-outline-light: #79747e;
  --md-sys-color-outline-variant-light: #cac4d0;
  --md-sys-color-shadow-light: #000000;
  --md-sys-color-scrim-light: #000000;
  --md-sys-color-inverse-surface-light: #313033;
  --md-sys-color-inverse-on-surface-light: #f4eff4;
  --md-sys-color-inverse-primary-light: #d0bcff;
  --md-sys-color-primary-dark: #d0bcff;
  --md-sys-color-on-primary-dark: #381e72;
  --md-sys-color-primary-container-dark: #4f378b;
  --md-sys-color-on-primary-container-dark: #eaddff;
  --md-sys-color-secondary-dark: #ccc2dc;
  --md-sys-color-on-secondary-dark: #332d41;
  --md-sys-color-secondary-container-dark: #4a4458;
  --md-sys-color-on-secondary-container-dark: #e8def8;
  --md-sys-color-tertiary-dark: #efb8c8;
  --md-sys-color-on-tertiary-dark: #492532;
  --md-sys-color-tertiary-container-dark: #633b48;
  --md-sys-color-on-tertiary-container-dark: #ffd8e4;
  --md-sys-color-error-dark: #f2b8b5;
  --md-sys-color-on-error-dark: #601410;
  --md-sys-color-error-container-dark: #8c1d18;
  --md-sys-color-on-error-container-dark: #f9dedc;
  --md-sys-color-background-dark: #1c1b1f;
  --md-sys-color-on-background-dark: #e6e1e5;
  --md-sys-color-surface-dark: #1c1b1f;
  --md-sys-color-on-surface-dark: #e6e1e5;
  --md-sys-color-surface-variant-dark: #49454f;
  --md-sys-color-on-surface-variant-dark: #cac4d0;
  --md-sys-color-outline-dark: #938f99;
  --md-sys-color-outline-variant-dark: #49454f;
  --md-sys-color-shadow-dark: #000000;
  --md-sys-color-scrim-dark: #000000;
  --md-sys-color-inverse-surface-dark: #e6e1e5;
  --md-sys-color-inverse-on-surface-dark: #313033;
  --md-sys-color-inverse-primary-dark: #6750a4;
  --comp-font-family: system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
    "Helvetica Neue", sans-serif;
  --comp-border-radius: 4px;

  --radio-chip-bg: var(--md-sys-color-surface-variant-light);
  --radio-chip-border: var(--md-sys-color-outline-variant-light);
  --radio-chip-text: var(--md-sys-color-on-surface-variant-light);
  --radio-chip-hover-bg: color-mix(
    in srgb,
    var(--md-sys-color-primary-light) 10%,
    transparent
  );
  --radio-chip-hover-border: var(--md-sys-color-primary-light);
  --radio-chip-selected-bg: var(--md-sys-color-primary-light);
  --radio-chip-selected-border: var(--md-sys-color-primary-light);
  --radio-chip-selected-text: var(--md-sys-color-on-primary-light);
}

.dark-theme {
  --radio-chip-bg: var(--md-sys-color-surface-variant-dark);
  --radio-chip-border: var(--md-sys-color-outline-variant-dark);
  --radio-chip-text: var(--md-sys-color-on-surface-variant-dark);
  --radio-chip-hover-bg: color-mix(
    in srgb,
    var(--md-sys-color-primary-dark) 10%,
    transparent
  );
  --radio-chip-hover-border: var(--md-sys-color-primary-dark);
  --radio-chip-selected-bg: var(--md-sys-color-primary-dark);
  --radio-chip-selected-border: var(--md-sys-color-primary-dark);
  --radio-chip-selected-text: var(--md-sys-color-on-primary-dark);

  background-color: var(--md-sys-color-background-dark);
  color: var(--md-sys-color-on-background-dark);
}

body {
  font-family: var(--comp-font-family);
  line-height: 1.6;
  background-color: var(--md-sys-color-background-light);
  color: var(--md-sys-color-on-background-light);
  padding: 20px;
  padding-top: 130px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  transition: background-color 0.3s ease, color 0.3s ease;
  position: relative;
}

#workflow-minimap {
  position: fixed;
  top: 15px;
  left: 15px;
  background-color: color-mix(in srgb, var(--md-sys-color-surface-light) 85%, transparent);
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  border: 1px solid var(--md-sys-color-outline-variant-light);
  border-radius: 8px;
  padding: 8px 10px;
  z-index: 1000;
  font-size: 10px;
  max-width: 280px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.dark-theme #workflow-minimap {
   background-color: color-mix(in srgb, var(--md-sys-color-surface-dark) 85%, transparent);
   border-color: var(--md-sys-color-outline-variant-dark);
   box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

#minimap-title {
    font-weight: 600;
    margin-bottom: 3px;
    color: var(--md-sys-color-on-surface-variant-light);
    border-bottom: 1px solid var(--md-sys-color-outline-variant-light);
    padding-bottom: 3px;
}
.dark-theme #minimap-title {
    color: var(--md-sys-color-on-surface-variant-dark);
    border-bottom-color: var(--md-sys-color-outline-variant-dark);
}
 #minimap-content {
     display: flex;
     flex-wrap: wrap;
     gap: 4px 6px;
     align-items: center;
     max-height: 70px;
     overflow-y: auto;
 }

 .minimap-node {
     padding: 2px 5px;
     border-radius: 3px;
     border: 1px solid;
     line-height: 1.2;
 }
 .minimap-edge {
     padding: 0 3px;
     font-weight: bold;
     position: relative;
     color: var(--md-sys-color-outline-light);
 }
 .dark-theme .minimap-edge {
     color: var(--md-sys-color-outline-dark);
 }

 /* Node Styles */
 .node-start { background-color: var(--md-sys-color-tertiary-container-light); border-color: var(--md-sys-color-tertiary-light); color: var(--md-sys-color-on-tertiary-container-light); }
 .dark-theme .node-start { background-color: var(--md-sys-color-tertiary-container-dark); border-color: var(--md-sys-color-tertiary-dark); color: var(--md-sys-color-on-tertiary-container-dark); }
 .node-human { background-color: var(--md-sys-color-primary-container-light); border-color: var(--md-sys-color-primary-light); color: var(--md-sys-color-on-primary-container-light); }
 .dark-theme .node-human { background-color: var(--md-sys-color-primary-container-dark); border-color: var(--md-sys-color-primary-dark); color: var(--md-sys-color-on-primary-container-dark); }
 .node-tool { background-color: var(--md-sys-color-secondary-container-light); border-color: var(--md-sys-color-secondary-light); color: var(--md-sys-color-on-secondary-container-light); }
 .dark-theme .node-tool { background-color: var(--md-sys-color-secondary-container-dark); border-color: var(--md-sys-color-secondary-dark); color: var(--md-sys-color-on-secondary-container-dark); }
 .node-mcp { background-color: #e0f7fa; border-color: #0097a7; color: #006064; }
 .dark-theme .node-mcp { background-color: #004d40; border-color: #4db6ac; color: #e0f2f1; }
 .node-llm { background-color: #fff3e0; border-color: #ffb74d; color: #e65100; }
 .dark-theme .node-llm { background-color: #4e342e; border-color: #ffcc80; color: #ffe0b2; }
 .node-result { background-color: #e8f5e9; border-color: #81c784; color: #1b5e20; }
 .dark-theme .node-result { background-color: #1b5e20; border-color: #a5d6a7; color: #c8e6c9; }

 /* Edge Styles */
 .edge-human { color: var(--md-sys-color-primary-light); }
 .dark-theme .edge-human { color: var(--md-sys-color-primary-dark); }
 .edge-tool { color: var(--md-sys-color-secondary-light); }
 .dark-theme .edge-tool { color: var(--md-sys-color-secondary-dark); }
 .edge-mcp { color: #0097a7; }
 .dark-theme .edge-mcp { color: #4db6ac; }
 .edge-llm { color: #ffb74d; }
 .dark-theme .edge-llm { color: #ffcc80; }
 .edge-gemini-bridge { color: #ffb74d; border: 1px dashed #ffb74d; padding: 0 2px; border-radius: 2px;}
 .dark-theme .edge-gemini-bridge { color: #ffcc80; border-color: #ffcc80;}


 /* Active State */
 .minimap-node.active, .minimap-edge.active {
    box-shadow: 0 0 0 2px var(--md-sys-color-primary-light);
    font-weight: bold;
 }
 .dark-theme .minimap-node.active, .dark-theme .minimap-edge.active {
    box-shadow: 0 0 0 2px var(--md-sys-color-primary-dark);
 }
 .minimap-edge::after {
     content: '>';
     font-size: 1.2em;
     margin-left: 2px;
 }
 .minimap-edge.edge-gemini-bridge::before {
     content: '<';
     font-size: 1.2em;
     margin-right: 2px;
 }
  .minimap-edge.edge-gemini-bridge::after {
     content: '>';
     font-size: 1.2em;
     margin-left: 2px;
 }

.container {
  max-width: 1300px;
  margin: 0 auto;
}

#theme-toggle {
  position: absolute;
  top: 15px;
  right: 20px;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--md-sys-color-on-surface-variant-light);
  padding: 8px;
  border-radius: 50%;
}

#theme-toggle:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-variant-light) 10%,
    transparent
  );
}

.dark-theme #theme-toggle {
  color: var(--md-sys-color-on-surface-variant-dark);
}

.dark-theme #theme-toggle:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-variant-dark) 10%,
    transparent
  );
}

.main-layout {
  display: grid;
  grid-template-columns: minmax(300px, 1fr) 2fr;
  gap: 30px;
}

@media (max-width: 900px) {
  .main-layout {
    grid-template-columns: 1fr;
  }

  #theme-toggle {
    top: 10px;
    right: 15px;
  }
   #workflow-minimap {
       max-width: calc(100vw - 30px);
       font-size: 9px;
       padding: 6px 8px;
       max-height: 60px;
   }
   body { padding-top: 110px;}
}

.card {
  background-color: var(--md-sys-color-surface-light);
  border-radius: 12px;
  border: 1px solid var(--md-sys-color-outline-variant-light);
  padding: 25px;
  margin-bottom: 25px;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.dark-theme .card {
  background-color: var(--md-sys-color-surface-dark);
  border-color: var(--md-sys-color-outline-variant-dark);
}

h1,
h2,
h3,
h4,
h5 {
  margin-bottom: 0.8em;
  color: var(--md-sys-color-on-surface-light);
  font-weight: 600;
}

.dark-theme h1,
.dark-theme h2,
.dark-theme h3,
.dark-theme h4,
.dark-theme h5 {
  color: var(--md-sys-color-on-surface-dark);
}

h1 {
  font-size: 1.8em;
  margin-bottom: 1em;
}

h2 {
  margin-top: 1.5em;
  font-size: 1.4em;
}

h3 {
  margin-top: 1em;
  font-size: 1.15em;
  border-bottom: 1px solid var(--md-sys-color-outline-variant-light);
  padding-bottom: 0.4em;
}

.dark-theme h3 {
  border-bottom-color: var(--md-sys-color-outline-variant-dark);
}

h4 {
  font-size: 1em;
  margin-bottom: 0.8em;
  color: var(--md-sys-color-on-surface-variant-light);
  font-weight: 500;
}

.dark-theme h4 {
  color: var(--md-sys-color-on-surface-variant-dark);
}

h5 {
  font-size: 0.95em;
  margin-bottom: 0.5em;
  font-weight: 500;
}

p {
  margin-bottom: 1em;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme p {
  color: var(--md-sys-color-on-surface-variant-dark);
}

code {
  background-color: #f0f0f0;
  padding: 0.2em 0.4em;
  border-radius: 3px;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
    Courier, monospace;
  font-size: 0.9em;
  color: #111;
  border: 1px solid #e0e0e0;
}

.dark-theme code {
  background-color: #333;
  color: #eee;
  border-color: #555;
}

fieldset {
  border: 1px solid var(--md-sys-color-outline-light);
  border-radius: 4px;
  padding: 15px;
  margin-bottom: 20px;
}

.dark-theme fieldset {
  border-color: var(--md-sys-color-outline-dark);
}

legend {
  font-weight: 600;
  padding: 0 8px;
  font-size: 0.95em;
  color: var(--md-sys-color-on-surface-light);
}

.dark-theme legend {
  color: var(--md-sys-color-on-surface-dark);
}

.input-group {
  margin-bottom: 20px;
}

.input-group label,
.checkbox-label {
  display: block;
  font-weight: 500;
  margin-bottom: 6px;
  font-size: 0.9em;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme .input-group label,
.dark-theme .checkbox-label {
  color: var(--md-sys-color-on-surface-variant-dark);
}

.input-group input[type="text"],
.input-group input[type="number"],
.input-group select,
.input-group textarea {
  padding: 10px 12px;
  border: 1px solid var(--md-sys-color-outline-light);
  border-radius: 4px;
  width: 100%;
  margin-bottom: 5px;
  background-color: var(--md-sys-color-surface-light);
  color: var(--md-sys-color-on-surface-light);
  font-size: 0.95em;
  transition: border-color 0.2s ease;
}

.dark-theme .input-group input[type="text"],
.dark-theme .input-group input[type="number"],
.dark-theme .input-group select,
.dark-theme .input-group textarea {
  background-color: var(--md-sys-color-surface-dark);
  color: var(--md-sys-color-on-surface-dark);
  border-color: var(--md-sys-color-outline-dark);
}

#text-prompt-input {
  font-size: 1.05em;
  padding: 12px;
  min-height: 80px;
}

.input-group input:focus,
.input-group select:focus,
.input-group textarea:focus {
  border-color: var(--md-sys-color-primary-light);
  outline: 1px solid var(--md-sys-color-primary-light);
}

.dark-theme .input-group input:focus,
.dark-theme .input-group select:focus,
.dark-theme .input-group textarea:focus {
  border-color: var(--md-sys-color-primary-dark);
  outline-color: var(--md-sys-color-primary-dark);
}

.input-group input[type="color"] {
  width: 42px;
  height: 42px;
  padding: 2px;
  vertical-align: middle;
  border: 1px solid var(--md-sys-color-outline-light);
  border-radius: 4px;
  cursor: pointer;
  background-color: #fff;
}

.dark-theme .input-group input[type="color"] {
  border-color: var(--md-sys-color-outline-dark);
  background-color: #333;
}

input[type="color"]::-webkit-color-swatch-wrapper {
  padding: 0;
}

input[type="color"]::-webkit-color-swatch {
  border: none;
  border-radius: 3px;
}

input[type="color"]::-moz-color-swatch {
  border: none;
  border-radius: 3px;
}

.input-group .color-input-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.input-group .color-input-row label {
  width: 70px;
  margin-bottom: 0;
  text-align: right;
  font-size: 0.85em;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme .input-group .color-input-row label {
  color: var(--md-sys-color-on-surface-variant-dark);
}

.mode-selection {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 8px;
}

.mode-selection input[type="radio"] {
  opacity: 0;
  position: absolute;
  width: 1px;
  height: 1px;
}

.mode-selection label {
  display: inline-block;
  padding: 6px 14px;
  border: 1px solid var(--radio-chip-border);
  background-color: var(--radio-chip-bg);
  color: var(--radio-chip-text);
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9em;
  transition: background-color 0.2s ease, border-color 0.2s ease,
    color 0.2s ease;
  user-select: none;
}

.mode-selection label:hover {
  background-color: var(--radio-chip-hover-bg);
  border-color: var(--radio-chip-hover-border);
}

.mode-selection input[type="radio"]:checked + label {
  background-color: var(--radio-chip-selected-bg);
  border-color: var(--radio-chip-selected-border);
  color: var(--radio-chip-selected-text);
  font-weight: 500;
}

.mode-selection input[type="radio"]:focus-visible + label {
  outline: 2px solid var(--md-sys-color-primary-light);
  outline-offset: 2px;
}

.dark-theme .mode-selection input[type="radio"]:focus-visible + label {
  outline-color: var(--md-sys-color-primary-dark);
}

.mode-selection label::before,
.mode-selection label::after {
  display: none;
}

.mode-selection div {
  line-height: 1;
}

input[type="checkbox"].custom-styled {
  opacity: 0;
  position: absolute;
  width: 1px;
  height: 1px;
}

.checkbox-label {
  margin-left: 0;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  position: relative;
  padding-left: 28px;
  min-height: 20px;
  user-select: none;
  color: var(--md-sys-color-on-surface-light);
}

.dark-theme .checkbox-label {
  color: var(--md-sys-color-on-surface-dark);
}

.checkbox-label::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 18px;
  height: 18px;
  border: 1px solid var(--md-sys-color-outline-light);
  background-color: var(--md-sys-color-surface-light);
  transition: all 0.2s ease;
  border-radius: 3px;
}

.dark-theme .checkbox-label::before {
  border-color: var(--md-sys-color-outline-dark);
  background-color: var(--md-sys-color-surface-dark);
}

.checkbox-label:hover::before {
  border-color: var(--md-sys-color-primary-light);
}

.dark-theme .checkbox-label:hover::before {
  border-color: var(--md-sys-color-primary-dark);
}

input[type="checkbox"].custom-styled:focus-visible
  + .checkbox-label::before {
  outline: 2px solid var(--md-sys-color-primary-light);
  outline-offset: 2px;
}

.dark-theme
  input[type="checkbox"].custom-styled:focus-visible
  + .checkbox-label::before {
  outline-color: var(--md-sys-color-primary-dark);
}

input[type="checkbox"].custom-styled:checked + .checkbox-label::before {
  border-color: var(--md-sys-color-primary-light);
  background-color: var(--md-sys-color-primary-light);
}

.dark-theme
  input[type="checkbox"].custom-styled:checked
  + .checkbox-label::before {
  border-color: var(--md-sys-color-primary-dark);
  background-color: var(--md-sys-color-primary-dark);
}

input[type="checkbox"].custom-styled:checked + .checkbox-label::after {
  content: "";
  position: absolute;
  left: 6px;
  top: 50%;
  width: 3px;
  height: 8px;
  border: solid var(--md-sys-color-on-primary-light);
  border-width: 0 2px 2px 0;
  transform: translateY(-60%) rotate(45deg);
}

.dark-theme
  input[type="checkbox"].custom-styled:checked
  + .checkbox-label::after {
  border-color: var(--md-sys-color-on-primary-dark);
}

button:not([id^="md-"]) {
  padding: 10px 18px;
  background-color: var(--md-sys-color-primary-light);
  color: var(--md-sys-color-on-primary-light);
  border: none;
  border-radius: 20px;
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: background-color 0.2s ease, opacity 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  vertical-align: middle;
}

.dark-theme button:not([id^="md-"]) {
  background-color: var(--md-sys-color-primary-dark);
  color: var(--md-sys-color-on-primary-dark);
}

button:not([id^="md-"]):hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-primary-light) 90%,
    black
  );
}

.dark-theme button:not([id^="md-"]):hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-primary-dark) 90%,
    white
  );
}

button:not([id^="md-"]):disabled {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-light) 30%,
    transparent
  );
  color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-light) 50%,
    transparent
  );
  cursor: not-allowed;
  opacity: 0.7;
}

.dark-theme button:not([id^="md-"]):disabled {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-dark) 30%,
    transparent
  );
  color: color-mix(
    in srgb,
    var(--md-sys-color-on-surface-dark) 50%,
    transparent
  );
}

#generate-button {
  width: 100%;
  margin-top: 15px;
  font-size: 1.1em;
  justify-content: center;
}

#suggest-colors-button {
  margin-top: 5px;
}

#generate-mwc-components-button,
#generate-gemini-components-button {
  margin-top: 5px;
  background-color: var(--md-sys-color-secondary-light);
  color: var(--md-sys-color-on-secondary-light);
  font-size: 0.95em;
}

.dark-theme #generate-mwc-components-button,
.dark-theme #generate-gemini-components-button {
  background-color: var(--md-sys-color-secondary-dark);
  color: var(--md-sys-color-on-secondary-dark);
}

#generate-mwc-components-button:hover,
#generate-gemini-components-button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-secondary-light) 90%,
    black
  );
}

.dark-theme #generate-mwc-components-button:hover,
.dark-theme #generate-gemini-components-button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-secondary-dark) 90%,
    white
  );
}

#add-custom-color-button {
  margin-top: 0px;
  font-size: 0.9em;
  padding: 6px 12px;
  background-color: var(--md-sys-color-secondary-container-light);
  color: var(--md-sys-color-on-secondary-container-light);
  border: 1px solid var(--md-sys-color-outline-light);
}

.dark-theme #add-custom-color-button {
  background-color: var(--md-sys-color-secondary-container-dark);
  color: var(--md-sys-color-on-secondary-container-dark);
  border-color: var(--md-sys-color-outline-dark);
}

#add-custom-color-button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-secondary-container-light) 90%,
    black
  );
}

.dark-theme #add-custom-color-button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-secondary-container-dark) 90%,
    white
  );
}

#drop-area {
  border: 2px dashed var(--md-sys-color-outline-light);
  border-radius: 4px;
  padding: 25px;
  text-align: center;
  cursor: pointer;
  background-color: var(--md-sys-color-surface-variant-light);
  transition: background-color 0.2s ease, border-color 0.2s ease;
  position: relative;
  min-height: 120px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.dark-theme #drop-area {
  border-color: var(--md-sys-color-outline-dark);
  background-color: var(--md-sys-color-surface-variant-dark);
}

#drop-area.drag-over {
  background-color: var(--md-sys-color-secondary-container-light);
  border-color: var(--md-sys-color-primary-light);
}

.dark-theme #drop-area.drag-over {
  background-color: var(--md-sys-color-secondary-container-dark);
  border-color: var(--md-sys-color-primary-dark);
}

#drop-area p {
  margin: 0;
  color: var(--md-sys-color-on-surface-variant-light);
  font-size: 0.95em;
}

.dark-theme #drop-area p {
  color: var(--md-sys-color-on-surface-variant-dark);
}

#image-preview {
  max-width: 100%;
  max-height: 150px;
  margin-top: 15px;
  border-radius: 4px;
  object-fit: contain;
  border: 1px solid var(--md-sys-color-outline-variant-light);
}

.dark-theme #image-preview {
  border-color: var(--md-sys-color-outline-variant-dark);
}

.image-options {
  margin-top: 15px;
  border-top: 1px solid var(--md-sys-color-outline-variant-light);
  padding-top: 15px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.dark-theme .image-options {
  border-top-color: var(--md-sys-color-outline-variant-dark);
}

.image-options label {
  font-size: 0.85em;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme .image-options label {
  color: var(--md-sys-color-on-surface-variant-dark);
}

.image-options input {
  max-width: 70px;
}

#custom-color-list .custom-color-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
  border: 1px solid var(--md-sys-color-outline-variant-light);
  padding: 8px 10px;
  border-radius: 4px;
  background-color: var(--md-sys-color-surface-light);
}

.dark-theme #custom-color-list .custom-color-row {
  border-color: var(--md-sys-color-outline-variant-dark);
  background-color: var(--md-sys-color-surface-dark);
}

#custom-color-list label {
  margin-bottom: 0;
  font-weight: normal;
  font-size: 0.85em;
  white-space: nowrap;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme #custom-color-list label {
  color: var(--md-sys-color-on-surface-variant-dark);
}

#custom-color-list input[type="text"] {
  flex-grow: 1;
  min-width: 80px;
  font-size: 0.9em;
  padding: 6px 8px;
}

#custom-color-list input[type="checkbox"] {
  margin-left: 2px;
  transform: scale(0.9);
}

#custom-color-list button {
  padding: 3px 7px;
  font-size: 0.8em;
  line-height: 1;
  background-color: transparent;
  border: none;
  color: var(--md-sys-color-error-light);
  border-radius: 50%;
  cursor: pointer;
  font-weight: bold;
}

.dark-theme #custom-color-list button {
  color: var(--md-sys-color-error-dark);
}

#custom-color-list button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-error-light) 15%,
    transparent
  );
}

.dark-theme #custom-color-list button:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-error-dark) 15%,
    transparent
  );
}

.output-section {
  min-height: 300px;
}

.output-section .placeholder {
  color: var(--md-sys-color-outline-light);
  text-align: center;
  margin-top: 60px;
  font-style: italic;
  font-size: 0.95em;
}

.dark-theme .output-section .placeholder {
  color: var(--md-sys-color-outline-dark);
}

.color-group {
  margin-bottom: 30px;
}

.swatch-container {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.swatch {
  width: 110px;
  height: 110px;
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  padding: 8px;
  font-size: 0.8em;
  color: white;
  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(0, 0, 0, 0.08);
}

.swatch span {
  display: block;
  line-height: 1.3;
}

.swatch .swatch-name {
  font-weight: 600;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.swatch .swatch-hex {
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
    Courier, monospace;
  font-size: 0.9em;
  opacity: 0.9;
}

#seed-colors-display .swatch {
  width: 70px;
  height: 70px;
  font-size: 0.75em;
  padding: 5px;
}

#seed-colors-display h3 {
  border-bottom: none;
  margin-bottom: 0.5em;
}

.palette-section {
  margin-bottom: 20px;
}

.scheme-swatches {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.custom-color-group-display {
  border-left: 3px solid var(--md-sys-color-outline-variant-light);
  padding-left: 15px;
  margin-left: 5px;
  margin-top: 15px;
}

.dark-theme .custom-color-group-display {
  border-left-color: var(--md-sys-color-outline-variant-dark);
}

.custom-color-group-display .scheme-pair {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 10px;
  margin-bottom: 15px;
}

.hidden {
  display: none !important;
}

.error {
  color: var(--md-sys-color-error-light);
  background-color: var(--md-sys-color-error-container-light);
  border: 1px solid
    color-mix(in srgb, var(--md-sys-color-error-light) 30%, transparent);
  padding: 12px 15px;
  border-radius: 4px;
  margin-top: 15px;
  font-size: 0.9em;
}

.dark-theme .error {
  color: var(--md-sys-color-error-dark);
  background-color: var(--md-sys-color-error-container-dark);
  border-color: color-mix(
    in srgb,
    var(--md-sys-color-error-dark) 30%,
    transparent
  );
}

#loading-indicator,
#suggestion-loading-indicator,
#gemini-component-loading {
  text-align: center;
  padding: 15px 10px;
  color: var(--md-sys-color-outline-light);
  font-style: italic;
  font-size: 0.95em;
}

.dark-theme #loading-indicator,
.dark-theme #suggestion-loading-indicator,
.dark-theme #gemini-component-loading {
  color: var(--md-sys-color-outline-dark);
}

#text-prompt-options {
  margin: 10px 0 5px 0;
  font-size: 0.85em;
}

#text-prompt-suggestions {
  margin-top: 20px;
  border-top: 1px solid var(--md-sys-color-outline-variant-light);
  padding-top: 20px;
}

.dark-theme #text-prompt-suggestions {
  border-top-color: var(--md-sys-color-outline-variant-dark);
}

#text-prompt-suggestions > label {
  display: block;
  margin-bottom: 12px;
  font-weight: 500;
  font-size: 0.9em;
  color: var(--md-sys-color-on-surface-variant-light);
}

.dark-theme #text-prompt-suggestions > label {
  color: var(--md-sys-color-on-surface-variant-dark);
}

.suggestion-option {
  padding: 10px 12px;
  border: 1px solid var(--md-sys-color-outline-light);
  border-radius: 4px;
  margin-bottom: 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  transition: background-color 0.2s ease, border-color 0.2s ease;
  background-color: var(--md-sys-color-surface-light);
}

.dark-theme .suggestion-option {
  border-color: var(--md-sys-color-outline-dark);
  background-color: var(--md-sys-color-surface-dark);
}

.suggestion-option:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-primary-light) 8%,
    transparent
  );
  border-color: var(--md-sys-color-primary-light);
}

.dark-theme .suggestion-option:hover {
  background-color: color-mix(
    in srgb,
    var(--md-sys-color-primary-dark) 8%,
    transparent
  );
  border-color: var(--md-sys-color-primary-dark);
}

.suggestion-option.selected {
  border-color: var(--md-sys-color-primary-light);
  background-color: var(--md-sys-color-primary-container-light);
  outline: 1px solid var(--md-sys-color-primary-light);
}

.dark-theme .suggestion-option.selected {
  border-color: var(--md-sys-color-primary-dark);
  background-color: var(--md-sys-color-primary-container-dark);
  outline-color: var(--md-sys-color-primary-dark);
}

.suggestion-option.selected span:not(.suggestion-swatch) {
  font-weight: 600;
  color: var(--md-sys-color-on-primary-container-light);
}

.dark-theme .suggestion-option.selected span:not(.suggestion-swatch) {
  color: var(--md-sys-color-on-primary-container-dark);
}

.suggestion-option input[type="radio"] {
  opacity: 0;
  width: 1px;
  height: 1px;
  position: absolute;
}

.suggestion-option label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  width: 100%;
  margin: 0;
  font-weight: normal;
  color: var(--md-sys-color-on-surface-light);
}

.dark-theme .suggestion-option label {
  color: var(--md-sys-color-on-surface-dark);
}

.suggestion-swatch {
  width: 22px;
  height: 22px;
  border-radius: 3px;
  border: 1px solid var(--md-sys-color-outline-variant-light);
  display: inline-block;
  flex-shrink: 0;
}

.dark-theme .suggestion-swatch {
  border-color: var(--md-sys-color-outline-variant-dark);
}

#component-examples {
  margin-top: 30px;
  border-top: 1px solid var(--md-sys-color-outline-variant-light);
  padding-top: 25px;
}

.dark-theme #component-examples {
  border-top-color: var(--md-sys-color-outline-variant-dark);
}

#component-examples h3 {
  border-bottom: none;
  margin-bottom: 15px;
}

.component-generation-options {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-bottom: 15px;
}

.component-generation-options .input-group {
  margin-bottom: 0;
  width: 100%;
}

.component-buttons-container {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  align-items: center;
}

.component-preview-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

@media (max-width: 1100px) {
  .component-preview-grid {
    grid-template-columns: 1fr;
  }
}

.component-preview-area {
  display: flex;
  flex-direction: column;
  gap: 15px;
  padding: 25px;
  border-radius: 8px;
  border: 1px solid var(--md-sys-color-outline-variant-light);
  background-color: var(--md-sys-color-background-light);
  color: var(--md-sys-color-on-background-light);
  transition: background-color 0.3s ease, color 0.3s ease,
    border-color 0.3s ease;
  min-height: 300px;

  background-color: var(
    --local-sys-color-background,
    var(--md-sys-color-background-light)
  );
  color: var(
    --local-sys-color-on-background,
    var(--md-sys-color-on-background-light)
  );
  border-color: var(
    --local-sys-color-outline-variant,
    var(--md-sys-color-outline-variant-light)
  );
}

.component-preview-area.dark-theme {
  background-color: var(
    --local-sys-color-background,
    var(--md-sys-color-background-dark)
  );
  color: var(
    --local-sys-color-on-background,
    var(--md-sys-color-on-background-dark)
  );
  border-color: var(
    --local-sys-color-outline-variant,
    var(--md-sys-color-outline-variant-dark)
  );
}

.component-preview-area h4 {
  color: var(
    --local-sys-color-on-surface,
    var(--md-sys-color-on-surface-light)
  );
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 1.2em;
}

.dark-theme .component-preview-area h4 {
  color: var(
    --local-sys-color-on-surface,
    var(--md-sys-color-on-surface-dark)
  );
}

.component-preview-area h5 {
  color: var(
    --local-sys-color-on-surface,
    var(--md-sys-color-on-surface-light)
  );
  margin-bottom: 10px;
  font-size: 1em;
}

.dark-theme .component-preview-area h5 {
  color: var(
    --local-sys-color-on-surface,
    var(--md-sys-color-on-surface-dark)
  );
}

#mwc-component-preview md-filled-button,
#mwc-component-preview md-outlined-button,
#mwc-component-preview md-fab,
#mwc-component-preview md-chip-set md-assist-chip,
#mwc-component-preview md-chip-set md-filter-chip,
#mwc-component-preview md-chip-set md-suggestion-chip,
#mwc-component-preview md-slider,
#mwc-component-preview md-card {
  --md-sys-color-primary: var(--local-sys-color-primary);
  --md-sys-color-on-primary: var(--local-sys-color-on-primary);
  --md-sys-color-primary-container: var(
    --local-sys-color-primary-container
  );
  --md-sys-color-on-primary-container: var(
    --local-sys-color-on-primary-container
  );
  --md-sys-color-secondary: var(--local-sys-color-secondary);
  --md-sys-color-on-secondary: var(--local-sys-color-on-secondary);
  --md-sys-color-secondary-container: var(
    --local-sys-color-secondary-container
  );
  --md-sys-color-on-secondary-container: var(
    --local-sys-color-on-secondary-container
  );
  --md-sys-color-tertiary: var(--local-sys-color-tertiary);
  --md-sys-color-on-tertiary: var(--local-sys-color-on-tertiary);
  --md-sys-color-tertiary-container: var(
    --local-sys-color-tertiary-container
  );
  --md-sys-color-on-tertiary-container: var(
    --local-sys-color-on-tertiary-container
  );
  --md-sys-color-error: var(--local-sys-color-error);
  --md-sys-color-on-error: var(--local-sys-color-on-error);
  --md-sys-color-error-container: var(--local-sys-color-error-container);
  --md-sys-color-on-error-container: var(
    --local-sys-color-on-error-container
  );
  --md-sys-color-surface: var(--local-sys-color-surface);
  --md-sys-color-on-surface: var(--local-sys-color-on-surface);
  --md-sys-color-surface-variant: var(--local-sys-color-surface-variant);
  --md-sys-color-on-surface-variant: var(
    --local-sys-color-on-surface-variant
  );
  --md-sys-color-outline: var(--local-sys-color-outline);
  --md-sys-color-outline-variant: var(--local-sys-color-outline-variant);
  --md-sys-color-inverse-surface: var(--local-sys-color-inverse-surface);
  --md-sys-color-inverse-on-surface: var(
    --local-sys-color-inverse-on-surface
  );
  --md-sys-color-inverse-primary: var(--local-sys-color-inverse-primary);
  --md-sys-color-background: var(--local-sys-color-background);
  --md-sys-color-on-background: var(--local-sys-color-on-background);
}

#mwc-component-preview md-card p {
  color: var(
    --local-sys-color-on-surface-variant,
    var(--md-sys-color-on-surface-variant-light)
  );
}

.dark-theme #mwc-component-preview md-card p {
  color: var(
    --local-sys-color-on-surface-variant,
    var(--md-sys-color-on-surface-variant-dark)
  );
}

.dark-theme #gemini-component-preview h1,
.dark-theme #gemini-component-preview h2,
.dark-theme #gemini-component-preview h3,
.dark-theme #gemini-component-preview h4,
.dark-theme #gemini-component-preview h5 {
  color: var(
    --local-sys-color-on-surface,
    var(--md-sys-color-on-surface-dark)
  );
}

.dark-theme #gemini-component-preview p,
.dark-theme #gemini-component-preview li {
  color: var(
    --local-sys-color-on-surface-variant,
    var(--md-sys-color-on-surface-variant-dark)
  );
}

.dark-theme #gemini-component-preview code {
  background-color: #333;
  color: #eee;
  border-color: #555;
}

.dark-theme #gemini-component-preview a {
  color: var(--local-sys-color-primary, var(--md-sys-color-primary-dark));
}

#dynamic-theme-styles {
    display: none;
}
</style>

  <body>
    <div id="workflow-minimap">
      <div id="minimap-title">Workflow Path</div>
      <div id="minimap-content"></div>
    </div>

    <button id="theme-toggle" title="Toggle Light/Dark Mode">
      <span class="material-icons"></span>
    </button>

    <div class="container">
      <h1>
        MILCHICK: Material Integration Leveraging Creative Human-LLM
        Intelligence Colors Kit
      </h1>
      <p>
        Generate Material Design 3 color palettes from colors, images, or text
        prompts. Uses a pure js fork of
        <a
          href="https://github.com/material-foundation/material-color-utilities/tree/main/typescript"
          target="_blank"
          rel="noopener"
          >material-color-utilities</a
        >
        via <code>dream.js</code>.
      </p>

      <div class="main-layout">
        <div class="input-section card">
          <h2>Configuration</h2>
          <fieldset class="mode-selection">
            <legend>Input Mode</legend>
            <div>
              <input
                type="radio"
                id="modeText"
                name="generationMode"
                value="modeText"
                checked
              /><label
                for="modeText"
                title="Generate seed colors using a text prompt via Gemini."
                >Gemini Prompt</label
              >
            </div>
            <div>
              <input
                type="radio"
                id="mode3"
                name="generationMode"
                value="mode3"
              /><label
                for="mode3"
                title="Generate theme from a single source color."
                >Single Source</label
              >
            </div>
            <div id="mode4-container">
              <input
                type="radio"
                id="mode4"
                name="generationMode"
                value="mode4"
              /><label
                for="mode4"
                title="Generate theme from one source plus custom accent colors."
                >Single + Custom</label
              >
            </div>
            <div>
              <input
                type="radio"
                id="mode1"
                name="generationMode"
                value="mode1"
              /><label
                for="mode1"
                title="Generate theme from multiple source colors (Primary, Secondary, Tertiary)."
                >Multiple Sources</label
              >
            </div>
            <div id="mode2-container">
              <input
                type="radio"
                id="mode2"
                name="generationMode"
                value="mode2"
              /><label
                for="mode2"
                title="Generate theme from multiple sources plus custom accent colors."
                >Multiple + Custom</label
              >
            </div>
            <div id="modeImageSingle-container">
              <input
                type="radio"
                id="modeImageSingle"
                name="generationMode"
                value="modeImageSingle"
              /><label
                for="modeImageSingle"
                title="Generate theme from the single most dominant color in an image."
                >Image (Single)</label
              >
            </div>
            <div id="modeImageMulti-container">
              <input
                type="radio"
                id="modeImageMulti"
                name="generationMode"
                value="modeImageMulti"
              /><label
                for="modeImageMulti"
                title="Generate theme from multiple seed colors extracted from an image."
                >Image (Multiple)</label
              >
            </div>
          </fieldset>

          <div id="text-prompt-area" class="input-group">
            <label for="text-prompt-input">Describe your theme:</label>
            <textarea
              id="text-prompt-input"
              rows="3"
              placeholder="e.g., calm ocean sunset, vibrant forest floor..."
            ></textarea>
            <div id="text-prompt-options">
              <input
                type="checkbox"
                id="use-gemini-simulation"
                class="custom-styled"
              />
              <label for="use-gemini-simulation" class="checkbox-label"
                >Use Simulation (Offline)</label
              >
            </div>
            <button type="button" id="suggest-colors-button">
              Suggest Colors
            </button>
            <div id="suggestion-loading-indicator" class="hidden">
              Getting suggestions...
            </div>
            <div id="text-prompt-suggestions" class="hidden">
              <label>Select a suggested color set:</label>
            </div>
            <p
              style="
                font-size: 0.8em;
                color: var(--md-sys-color-outline-light);
                margin-top: 5px;
              "
            >
              Select a suggestion to populate Source Colors.
            </p>
          </div>

          <div id="image-input-area" class="input-group hidden">
            <label>Upload or Drop Image:</label>
            <div id="drop-area">
              <p>Drag & Drop or click</p>
              <input type="file" id="image-input" accept="image/*" hidden />
              <img id="image-preview" src="#" alt="Preview" class="hidden" />
            </div>
            <div class="image-options hidden" id="image-multi-options">
              <label for="numSources">Max Colors:</label>
              <input type="number" id="numSources" value="5" min="1" max="20" />
              <label for="extractQuality">Quality (1=Best):</label>
              <input
                type="number"
                id="extractQuality"
                value="10"
                min="1"
                max="50"
              />
            </div>
          </div>

          <div id="source-color-area" class="input-group hidden">
            <label id="source-color-label">Source Color:</label>
            <div id="source-color-inputs"></div>
          </div>

          <div id="custom-color-area" class="input-group hidden">
            <label>Custom Accent Colors:</label>
            <div id="custom-color-list"></div>
            <button type="button" id="add-custom-color-button">
              Add Custom
            </button>
          </div>

          <div id="multi-source-options" class="input-group hidden">
            <label for="harmonyStrategy">Multi-Color Strategy:</label>
            <select id="harmonyStrategy">
              <option value="direct" selected>Direct</option>
              <option value="harmonized">Harmonized</option>
            </select>
          </div>

          <button type="button" id="generate-button">Generate Theme</button>
          <div id="loading-indicator" class="hidden">Generating theme...</div>
          <div id="error-message" class="error hidden"></div>
        </div>

        <div class="output-section card">
          <h2>Generated Theme</h2>
          <div id="seed-colors-display" class="color-group">
            <h3>Seed Color(s) Used</h3>
            <div class="swatch-container">
              <p class="placeholder">Seeds appear here.</p>
            </div>
          </div>
          <hr
            style="
              border: none;
              border-top: 1px solid var(--md-sys-color-outline-variant-light);
              margin: 25px 0;
            "
          />
          <div id="palette-display">
            <p class="placeholder">Configure inputs and click Generate.</p>
          </div>

          <div id="component-examples" class="hidden">
            <hr
              style="
                border: none;
                border-top: 1px solid var(--md-sys-color-outline-variant-light);
                margin: 25px 0;
              "
            />
            <h3>Component Examples</h3>
            <div class="component-generation-options">
              <div class="input-group">
                <label for="component-style-prompt"
                  >Optional Gemini Style Prompt:</label
                >
                <input
                  type="text"
                  id="component-style-prompt"
                  placeholder="e.g., modern and clean, playful, brutalist..."
                />
              </div>
              <div class="component-buttons-container">
                <button
                  type="button"
                  id="generate-mwc-components-button"
                  title="Apply theme to standard Material Web Components"
                >
                  Generate deterministic component set
                </button>
                <button
                  type="button"
                  id="generate-gemini-components-button"
                  title="Use Gemini to generate styled HTML based on the theme and your style prompt"
                >
                  Generate gemini created component set
                </button>
              </div>
            </div>
            <div id="gemini-component-loading" class="hidden">
              Generating Gemini components...
            </div>

            <div class="component-preview-grid">
              <div class="component-preview-area" id="mwc-component-preview">
                <h4>MWC Preview</h4>
              </div>
              <div class="component-preview-area" id="gemini-component-preview">
                <h4>Gemini Preview</h4>
              </div>
            </div>
          </div>

          <style id="dynamic-theme-styles"></style>
        </div>
      </div>
    </div>

    <script src="config.js"></script>
    <script src="dream.js"></script>
    <script src="m3.txt" type="text/plain"></script>

    <script
      type="module"
      src="https://cdn.skypack.dev/@material/web/all.js"
    ></script>

    <script type="module">
      
    </script>
  </body>
</html>

    <script src="config.js"></script>
    <script src="dream.js"></script>

    <script
      type="module"
      src="https://cdn.skypack.dev/@material/web/all.js"
    ></script>

    <script type="module">
    document.addEventListener("DOMContentLoaded", () => {
  const modeRadios = document.querySelectorAll('input[name="generationMode"]');
  const imageInputArea = document.getElementById("image-input-area");
  const dropArea = document.getElementById("drop-area");
  const imageInput = document.getElementById("image-input");
  const imagePreview = document.getElementById("image-preview");
  const imageMultiOptions = document.getElementById("image-multi-options");
  const sourceColorArea = document.getElementById("source-color-area");
  const sourceColorLabel = document.getElementById("source-color-label");
  const sourceColorInputsContainer = document.getElementById("source-color-inputs");
  const customColorArea = document.getElementById("custom-color-area");
  const customColorList = document.getElementById("custom-color-list");
  const addCustomColorButton = document.getElementById("add-custom-color-button");
  const multiSourceOptionsArea = document.getElementById("multi-source-options");
  const harmonyStrategySelect = document.getElementById("harmonyStrategy");
  const generateButton = document.getElementById("generate-button");
  const loadingIndicator = document.getElementById("loading-indicator");
  const errorMessageDiv = document.getElementById("error-message");
  const seedColorsDisplayContainer = document.getElementById("seed-colors-display").querySelector(".swatch-container");
  const paletteDisplay = document.getElementById("palette-display");
  const numSourcesInput = document.getElementById("numSources");
  const extractQualityInput = document.getElementById("extractQuality");
  const textPromptArea = document.getElementById("text-prompt-area");
  const textPromptInput = document.getElementById("text-prompt-input");
  const useSimulationCheckbox = document.getElementById("use-gemini-simulation");
  const suggestColorsButton = document.getElementById("suggest-colors-button");
  const suggestionLoadingIndicator = document.getElementById("suggestion-loading-indicator");
  const textPromptSuggestionsContainer = document.getElementById("text-prompt-suggestions");
  const componentExamplesDiv = document.getElementById("component-examples");
  const generateMwcComponentsButton = document.getElementById("generate-mwc-components-button");
  const generateGeminiComponentsButton = document.getElementById("generate-gemini-components-button");
  const componentStylePromptInput = document.getElementById("component-style-prompt");
  const geminiComponentLoadingIndicator = document.getElementById("gemini-component-loading");
  const mwcComponentPreview = document.getElementById("mwc-component-preview");
  const geminiComponentPreview = document.getElementById("gemini-component-preview");
  const dynamicThemeStyles = document.getElementById("dynamic-theme-styles");
  const bodyElement = document.body;
  const themeToggleButton = document.getElementById("theme-toggle");
  const themeToggleIcon = themeToggleButton.querySelector(".material-icons");
  const minimapContent = document.getElementById('minimap-content');

  const mode4Container = document.getElementById("mode4-container");
  const mode2Container = document.getElementById("mode2-container");
  const modeImageSingleContainer = document.getElementById("modeImageSingle-container");
  const modeImageMultiContainer = document.getElementById("modeImageMulti-container");

  let currentImageFile = null;
  let currentMode = "modeText";
  let lastGeneratedTheme = null;
  let isDarkMode = false;
  let m3ContentCache = null; // Cache for m3.txt content

  let API_KEY;
  let GEMINI_MODEL;
  let GEMINI_MODEL_COLOR_PICKER;
  let GEMINI_MODEL_COMPONENT_GENERATOR;
  let USE_M3_TXT_SYS_PROMPT;
  let ENABLE_CUSTOM_COLORS;
  let ENABLE_IMAGES;
  let isApiConfigValid = false;
  let geminiApiEndpointBase;
  let geminiApiEndpointColorPicker;
  let geminiApiEndpointComponentGenerator;

  const workflowSteps = {
      START: { id: 'start', label: 'Start', type: 'start' },
      SELECT_MODE: { id: 'select_mode', label: 'Select Mode', type: 'human' },
      INPUT_TEXT: { id: 'input_text', label: 'Input Text', type: 'human' },
      INPUT_COLOR: { id: 'input_color', label: 'Input Color(s)', type: 'human' },
      INPUT_IMAGE: { id: 'input_image', label: 'Input Image', type: 'human' },
      INPUT_CUSTOM: { id: 'input_custom', label: 'Input Custom Colors', type: 'human' },
      CLICK_SUGGEST: { id: 'click_suggest', label: 'Suggest Colors', type: 'human' },
      CLICK_GENERATE: { id: 'click_generate', label: 'Generate Theme', type: 'human' },
      CLICK_GEN_MWC: { id: 'click_gen_mwc', label: 'Gen MWC', type: 'human'},
      CLICK_GEN_GEMINI: { id: 'click_gen_gemini', label: 'Gen Gemini Comp', type: 'human'},
      MCP_WRAP_SUGGEST: { id: 'mcp_wrap_suggest', label: 'MCP: SuggestColors', type: 'mcp' },
      MCP_WRAP_GENERATE: { id: 'mcp_wrap_generate', label: 'MCP: GenerateTheme', type: 'mcp' },
      MCP_WRAP_GEN_COMP: { id: 'mcp_wrap_gen_comp', label: 'MCP: GenerateComponents', type: 'mcp'},
      LLM_SUGGEST: { id: 'llm_suggest', label: 'LLM: Suggest', type: 'llm' },
      LLM_GEN_COMP: { id: 'llm_gen_comp', label: 'LLM: Generate Comp', type: 'llm'},
      TOOL_IMAGE_PROC: { id: 'tool_image_proc', label: 'Tool: Image Proc', type: 'tool' },
      TOOL_COLOR_MATH: { id: 'tool_color_math', label: 'Tool: Color Math', type: 'tool' },
      TOOL_RENDER_MWC: { id: 'tool_render_mwc', label: 'Tool: Render MWC', type: 'tool'},
      SELECT_SUGGESTION: { id: 'select_suggestion', label: 'Select Suggestion', type: 'human' },
      DISPLAY_SUGGESTIONS: { id: 'display_suggestions', label: 'Display Suggestions', type: 'result' },
      DISPLAY_THEME: { id: 'display_theme', label: 'Display Theme', type: 'result' },
      DISPLAY_COMPONENTS: { id: 'display_components', label: 'Display Components', type: 'result' },
      ERROR: { id: 'error', label: 'Error', type: 'error' } // Implicit step
  };

  let currentPath = [workflowSteps.START];

  function updateMinimap(newStep = null, edgeType = null) {
      if (newStep && newStep !== currentPath[currentPath.length -1]) {
          if (edgeType) {
              currentPath.push({ ...newStep, edge: edgeType });
          } else {
              currentPath.push(newStep);
          }
      }

      minimapContent.innerHTML = '';
      currentPath.forEach((step, index) => {
           const nodeEl = document.createElement('span');
           nodeEl.classList.add('minimap-node', `node-${step.type}`);
           nodeEl.textContent = step.label;
           nodeEl.title = `Step ${index + 1}: ${step.label} (${step.type})`;
           if (index === currentPath.length - 1) {
               nodeEl.classList.add('active');
           }
           minimapContent.appendChild(nodeEl);

          if (index < currentPath.length - 1) {
              const nextStep = currentPath[index + 1];
              const edgeEl = document.createElement('span');
              const edgeClass = nextStep.edge || 'human'; // Default edge is human action
              edgeEl.classList.add('minimap-edge', `edge-${edgeClass}`);
              if (edgeClass === 'gemini-bridge') {
                  edgeEl.title = 'Gemini API Call (Request/Response)';
              } else {
                 edgeEl.title = `Via: ${edgeClass}`;
              }
              if (index === currentPath.length - 2) {
                  edgeEl.classList.add('active');
              }
              minimapContent.appendChild(edgeEl);
          }
      });
      minimapContent.scrollTop = minimapContent.scrollHeight; // Scroll to bottom
  }

   function resetMinimap(startNode = workflowSteps.START) {
      currentPath = [startNode];
      updateMinimap();
   }

  function initializeApp() {
    loadConfig();
    setupThemeToggle();
    applyFeatureVisibility();
    setupEventListeners();
    updateInputUI(currentMode);
    resetMinimap(); // Initial state
  }

  function loadConfig() {
    try {
      if (typeof APP_CONFIG === "undefined") throw new Error("config.js not loaded or APP_CONFIG missing.");

      ENABLE_CUSTOM_COLORS = !!APP_CONFIG.ENABLE_CUSTOM_COLORS;
      ENABLE_IMAGES = !!APP_CONFIG.ENABLE_IMAGES;
      USE_M3_TXT_SYS_PROMPT = !!APP_CONFIG.USE_M3_TXT_SYS_PROMPT;
      API_KEY = APP_CONFIG.API_KEY || null;
      GEMINI_MODEL = APP_CONFIG.GEMINI_MODEL || null;
      GEMINI_MODEL_COLOR_PICKER = APP_CONFIG.GEMINI_MODEL_COLOR_PICKER || GEMINI_MODEL;
      GEMINI_MODEL_COMPONENT_GENERATOR = APP_CONFIG.GEMINI_MODEL_COMPONENT_GENERATOR || GEMINI_MODEL;


      if (!API_KEY || API_KEY === "YOUR_API_KEY_HERE" || !GEMINI_MODEL) {
        isApiConfigValid = false;
        showError("Gemini API config missing in config.js. Using simulation where possible.");
        useSimulationCheckbox.checked = true; // Force simulation
        useSimulationCheckbox.disabled = true;
        suggestColorsButton.title = "Gemini API not configured.";
        generateGeminiComponentsButton.disabled = true;
        generateGeminiComponentsButton.title = "Gemini API not configured.";
      } else {
          const modelIdBase = GEMINI_MODEL.startsWith("models/") ? GEMINI_MODEL : `models/${GEMINI_MODEL}`;
          const modelIdColorPicker = GEMINI_MODEL_COLOR_PICKER && GEMINI_MODEL_COLOR_PICKER.startsWith("models/")
              ? GEMINI_MODEL_COLOR_PICKER : GEMINI_MODEL_COLOR_PICKER ? `models/${GEMINI_MODEL_COLOR_PICKER}` : modelIdBase;
          const modelIdComponentGenerator = GEMINI_MODEL_COMPONENT_GENERATOR && GEMINI_MODEL_COMPONENT_GENERATOR.startsWith("models/")
              ? GEMINI_MODEL_COMPONENT_GENERATOR : GEMINI_MODEL_COMPONENT_GENERATOR ? `models/${GEMINI_MODEL_COMPONENT_GENERATOR}` : modelIdBase;

        const geminiApiEndpointPrefix = "https://generativelanguage.googleapis.com/v1beta/";
        geminiApiEndpointBase = `${geminiApiEndpointPrefix}${modelIdBase}`;
        geminiApiEndpointColorPicker = `${geminiApiEndpointPrefix}${modelIdColorPicker}`;
        geminiApiEndpointComponentGenerator = `${geminiApiEndpointPrefix}${modelIdComponentGenerator}`;

        isApiConfigValid = true;
        useSimulationCheckbox.disabled = false;
        suggestColorsButton.title = "";
        generateGeminiComponentsButton.disabled = false;
        generateGeminiComponentsButton.title = "";
      }
    } catch (error) {
      console.error("Error loading config.js:", error);
      showError("Config error. Using simulation, limited features.");
      isApiConfigValid = false;
      useSimulationCheckbox.checked = true;
      useSimulationCheckbox.disabled = true;
      suggestColorsButton.disabled = true;
      suggestColorsButton.title = "Config error.";
      generateGeminiComponentsButton.disabled = true;
      generateGeminiComponentsButton.title = "Config error.";
    }
  }

  function applyFeatureVisibility() {
      const features = { custom: ENABLE_CUSTOM_COLORS, image: ENABLE_IMAGES };
      mode4Container?.classList.toggle("hidden", !features.custom);
      mode2Container?.classList.toggle("hidden", !features.custom);
      addCustomColorButton?.classList.toggle("hidden", !features.custom);
      customColorArea?.classList.toggle("hidden", !features.custom); // Also hide area initially if feature disabled

      modeImageSingleContainer?.classList.toggle("hidden", !features.image);
      modeImageMultiContainer?.classList.toggle("hidden", !features.image);
      imageInputArea?.classList.toggle("hidden", !features.image); // Hide area initially if disabled

      // If the currently checked radio is now hidden, default to text mode
      const selectedRadio = document.querySelector('input[name="generationMode"]:checked');
      if (selectedRadio?.closest("div")?.classList.contains("hidden")) {
        currentMode = "modeText";
        document.getElementById("modeText").checked = true;
      }
  }


  function setupThemeToggle() {
    const storedTheme = localStorage.getItem("themeMode");
    isDarkMode = storedTheme === "dark";
    applyTheme();
    themeToggleButton.addEventListener("click", () => {
      isDarkMode = !isDarkMode;
      localStorage.setItem("themeMode", isDarkMode ? "dark" : "light");
      applyTheme();
      updateMinimap(workflowSteps.SELECT_MODE, 'human'); // Consider theme toggle a mode selection
    });
  }

  function applyTheme() {
    bodyElement.classList.toggle("dark-theme", isDarkMode);
    themeToggleIcon.textContent = isDarkMode ? "light_mode" : "dark_mode";
    mwcComponentPreview?.classList.toggle("dark-theme", isDarkMode);
    geminiComponentPreview?.classList.toggle("dark-theme", isDarkMode);
    if (lastGeneratedTheme) {
      applyScopedThemeStyles(lastGeneratedTheme);
    }
  }

  function hexToArgbInt(hex) {
    if (!hex) return 0;
    hex = hex.replace("#", "");
    if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    if (hex.length !== 6) return 0;
    // Use unsigned right shift for cleaner conversion if numbers get large
    return (parseInt(`ff${hex}`, 16) | 0) >>> 0;
  }

  function argbIntToHex(argb) {
    // Handle potential negative numbers from signed int conversion if >>> 0 wasn't used at input
    if (typeof argb !== "number" || isNaN(argb) || argb < 0) argb = (argb >>> 0);
    const r = (argb >> 16) & 0xff;
    const g = (argb >> 8) & 0xff;
    const b = argb & 0xff;
    return `#${[r, g, b].map((c) => c.toString(16).padStart(2, "0")).join("")}`;
  }


  function getContrastColor(hex) {
      if (!hex || hex.length < 4) return "#000000";
      hex = hex.replace("#", "");
      if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      if (hex.length !== 6) return "#000000";

      // Calculate relative luminance (Y)
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;

      const rLinear = r <= 0.03928 ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
      const gLinear = g <= 0.03928 ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
      const bLinear = b <= 0.03928 ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);

      const lum = 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;

      // WCAG contrast ratio check (approximated by luminance midpoint 0.5 doesn't work well)
      // Contrast ratio = (L1 + 0.05) / (L2 + 0.05) where L1 is lighter, L2 is darker
      // Check contrast against white (L=1) and black (L=0)
      const contrastWithWhite = (1 + 0.05) / (lum + 0.05);
      const contrastWithBlack = (lum + 0.05) / (0 + 0.05);

      // Prefer white text if contrast with black is higher (meets threshold better)
      // Threshold 4.5:1 for normal text
      return contrastWithBlack >= 4.5 || contrastWithBlack > contrastWithWhite ? "#000000" : "#FFFFFF";
  }


  function createSwatchHtml(name, colorInt, extraClass = "") {
      const hex = argbIntToHex(colorInt);
      const contrast = getContrastColor(hex);
      const safeName = name ? String(name).replace(/</g, "<").replace(/>/g, ">") : "";
      return `<div class="swatch ${extraClass}" style="background-color: ${hex}; color: ${contrast};" title="${safeName} - ${hex}"><span class="swatch-name">${safeName}</span><span class="swatch-hex">${hex}</span></div>`;
  }

  function showError(msg) {
    errorMessageDiv.textContent = msg;
    errorMessageDiv.classList.remove("hidden");
    console.error("Error Displayed:", msg);
    updateMinimap(workflowSteps.ERROR, 'error'); // Indicate error state
  }

  function hideError() {
    errorMessageDiv.classList.add("hidden");
    errorMessageDiv.textContent = "";
  }

  function setUILoading(isLoading, source = '') {
      loadingIndicator.textContent = isLoading ? `Generating theme (${source})...` : '';
      loadingIndicator.classList.toggle("hidden", !isLoading);
      generateButton.disabled = isLoading;
      // Could optionally disable other inputs here too
  }

  function setSuggestionLoading(isLoading) {
      suggestionLoadingIndicator.classList.toggle("hidden", !isLoading);
      suggestColorsButton.disabled = isLoading;
      textPromptInput.disabled = isLoading;
  }

  function setGeminiComponentLoading(isLoading) {
      geminiComponentLoadingIndicator.classList.toggle("hidden", !isLoading);
      generateGeminiComponentsButton.disabled = isLoading;
      generateMwcComponentsButton.disabled = isLoading; // Disable both while generating
  }

  function displayTheme(theme) {
    paletteDisplay.innerHTML = "";
    lastGeneratedTheme = theme;

    if (!theme?.palettes || !theme?.schemes) {
      paletteDisplay.innerHTML = '<p class="placeholder error">Invalid theme generated.</p>';
      componentExamplesDiv.classList.add("hidden");
      showError("Invalid theme data received."); // Also show top error
      return;
    }

    hideError(); // Clear previous errors if successful

    const schemeKeys = ["primary", "secondary", "tertiary", "neutral", "neutralVariant", "error"];
    schemeKeys.forEach((key) => {
        if (!theme.palettes[key]) return;
        const section = document.createElement("div");
        section.classList.add("palette-section", "color-group");
        const title = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, " $1");
        section.innerHTML = `<h4>${title} Roles</h4>`;
        const swatches = document.createElement("div");
        swatches.classList.add("scheme-swatches");

        const capKey = key.charAt(0).toUpperCase() + key.slice(1);
        const roles = [
            { n: `${key}(L)`, k: key, s: "light" }, { n: `On ${key}(L)`, k: `on${capKey}`, s: "light" },
            { n: `${key} Cont.(L)`, k: `${key}Container`, s: "light" }, { n: `On ${key} Cont.(L)`, k: `on${capKey}Container`, s: "light" },
            { n: `${key}(D)`, k: key, s: "dark" }, { n: `On ${key}(D)`, k: `on${capKey}`, s: "dark" },
            { n: `${key} Cont.(D)`, k: `${key}Container`, s: "dark" }, { n: `On ${key} Cont.(D)`, k: `on${capKey}Container`, s: "dark" },
        ];

        roles.forEach((r) => {
            const scheme = theme.schemes[r.s];
            if (scheme && typeof scheme[r.k] === 'number') { // Check if the key exists and is a number
                swatches.innerHTML += createSwatchHtml(r.n, scheme[r.k]);
            }
        });

        if (swatches.hasChildNodes()) {
          section.appendChild(swatches);
          paletteDisplay.appendChild(section);
        }
    });

    if (ENABLE_CUSTOM_COLORS && theme.customColors?.length > 0) {
        const customSection = document.createElement("div");
        customSection.classList.add("palette-section", "color-group");
        customSection.innerHTML = `<h4>Custom Colors</h4>`;
        theme.customColors.forEach((group) => {
          if (!group?.color?.value || !group.light || !group.dark) return;

          const groupDiv = document.createElement("div");
          groupDiv.classList.add("custom-color-group-display");
          const safeName = (group.color.name || "Unnamed").replace(/</g, "<").replace(/>/g, ">");
          const seedHex = argbIntToHex(group.color.value);
          const finalHex = argbIntToHex(group.value); // Harmonized value
          groupDiv.innerHTML = `<h5>${safeName} (Seed: ${seedHex}${seedHex !== finalHex ? `, Harmonized: ${finalHex}` : ''})</h5>`;

          const pairDiv = document.createElement("div");
          pairDiv.classList.add("scheme-pair");

          const customRoles = [
              { n: `Color(L)`, s: "light", k: "color" }, { n: `On Color(L)`, s: "light", k: "onColor" },
              { n: `Container(L)`, s: "light", k: "colorContainer" }, { n: `On Container(L)`, s: "light", k: "onColorContainer" },
              { n: `Color(D)`, s: "dark", k: "color" }, { n: `On Color(D)`, s: "dark", k: "onColor" },
              { n: `Container(D)`, s: "dark", k: "colorContainer" }, { n: `On Container(D)`, s: "dark", k: "onColorContainer" },
          ];

          customRoles.forEach((r) => {
            if (group[r.s]?.[r.k] !== undefined && typeof group[r.s][r.k] === 'number') {
              pairDiv.innerHTML += createSwatchHtml(r.n, group[r.s][r.k]);
            }
          });

          if (pairDiv.hasChildNodes()) groupDiv.appendChild(pairDiv);
          if (groupDiv.querySelector(".scheme-pair")) customSection.appendChild(groupDiv); // Only add if pair has content
        });

        if (customSection.querySelector(".custom-color-group-display")) {
            paletteDisplay.appendChild(customSection);
        }
    }


    if (!paletteDisplay.hasChildNodes()) {
      paletteDisplay.innerHTML = '<p class="placeholder">No palettes generated.</p>';
      componentExamplesDiv.classList.add("hidden");
    } else {
      componentExamplesDiv.classList.remove("hidden");
      applyScopedThemeStyles(theme);
      // Automatically generate MWC preview after successful theme generation
      generateMwcComponents(false); // Don't reapply styles, just render HTML
      // Clear Gemini preview until explicitly requested
      geminiComponentPreview.innerHTML = '<h4>Gemini Preview</h4>';
      updateMinimap(workflowSteps.DISPLAY_THEME, 'result');
    }
  }

  function updateInputUI(mode) {
      currentMode = mode;
      hideError();
      sourceColorInputsContainer.innerHTML = "";
      textPromptSuggestionsContainer.innerHTML = '<label>Select a suggested color set:</label>'; // Reset suggestions
      textPromptSuggestionsContainer.classList.add("hidden");
      paletteDisplay.innerHTML = '<p class="placeholder">Configure inputs and click Generate.</p>';
      seedColorsDisplayContainer.innerHTML = '<p class="placeholder">Seeds appear here.</p>';
      componentExamplesDiv.classList.add("hidden"); // Hide components until theme exists
      mwcComponentPreview.innerHTML = '<h4>MWC Preview</h4>'; // Clear previews
      geminiComponentPreview.innerHTML = '<h4>Gemini Preview</h4>';

      const showImageInput = ENABLE_IMAGES && mode.startsWith("modeImage");
      const showCustomColorArea = ENABLE_CUSTOM_COLORS && ["mode4", "mode2"].includes(mode);
      const showMultiSourceOptions = ["mode1", "mode2", "modeImageMulti"].includes(mode) && (!mode.startsWith("modeImage") || ENABLE_IMAGES);
      const showSourceColorArea = !showImageInput && mode !== 'modeText';

      imageInputArea.classList.toggle("hidden", !showImageInput);
      imageMultiOptions.classList.toggle("hidden", mode !== "modeImageMulti" || !ENABLE_IMAGES);
      sourceColorArea.classList.toggle("hidden", !showSourceColorArea);
      customColorArea.classList.toggle("hidden", !showCustomColorArea);
      multiSourceOptionsArea.classList.toggle("hidden", !showMultiSourceOptions);
      textPromptArea.classList.toggle("hidden", mode !== "modeText");

      // Reset minimap based on the mode selected
      resetMinimap(workflowSteps.SELECT_MODE);

      if (mode === 'modeText') {
          if (!isApiConfigValid) {
              useSimulationCheckbox.checked = true;
              useSimulationCheckbox.disabled = true;
          } else {
               useSimulationCheckbox.disabled = false;
          }
          updateMinimap(workflowSteps.INPUT_TEXT, 'human');
      } else if (showImageInput) {
          if (!currentImageFile) {
              imagePreview.classList.add("hidden");
              imagePreview.src = "#";
          }
          updateMinimap(workflowSteps.INPUT_IMAGE, 'human');
      } else if (mode === "mode3" || (mode === "mode4" && ENABLE_CUSTOM_COLORS)) {
          sourceColorLabel.textContent = "Source Color:";
          addSourceColorInput(0);
          updateMinimap(workflowSteps.INPUT_COLOR, 'human');
      } else if (mode === "mode1" || (mode === "mode2" && ENABLE_CUSTOM_COLORS)) {
          sourceColorLabel.textContent = "Source Colors:";
          addSourceColorInput(0, "Primary");
          addSourceColorInput(1, "Secondary");
          addSourceColorInput(2, "Tertiary");
          updateMinimap(workflowSteps.INPUT_COLOR, 'human');
      }

      // Add initial custom color row if the area is visible and empty
      if (showCustomColorArea && customColorList.children.length === 0) {
          addCustomColorRow();
      } else if (!showCustomColorArea) {
          customColorList.innerHTML = ""; // Clear list if area is hidden
      }
  }

  function addSourceColorInput(index, label = "", disabled = false) {
      const row = document.createElement("div");
      row.classList.add("color-input-row");
      const id = `source-color-${index}`;
      const defaults = ["#6750A4", "#625B71", "#7D5260"];
      const safeLabel = label ? String(label).replace(/</g, "<").replace(/>/g, ">") : "";
      const labelHtml = label ? `<label for="${id}">${safeLabel}:</label>` : '';
      const inputHtml = `<input type="color" id="${id}" name="${id}" value="${defaults[index] || '#808080'}" ${disabled ? 'disabled' : ''}>`;
      row.innerHTML = `${labelHtml}${inputHtml}`;
      sourceColorInputsContainer.appendChild(row);

      row.querySelector('input[type="color"]').addEventListener('input', () => {
           updateMinimap(workflowSteps.INPUT_COLOR, 'human');
      });
  }

  function addCustomColorRow() {
      const index = Date.now(); // Use timestamp for a unique ID
      const row = document.createElement("div");
      row.classList.add("custom-color-row");
      row.dataset.id = index;

      row.innerHTML = `
          <label for="custom-name-${index}">Name:</label>
          <input type="text" id="custom-name-${index}" value="custom${customColorList.children.length + 1}" placeholder="e.g., Brand">
          <label for="custom-value-${index}">Value:</label>
          <input type="color" id="custom-value-${index}" value="#808080">
          <label for="custom-blend-${index}" title="Harmonize with Primary">Blend:</label>
          <input type="checkbox" id="custom-blend-${index}" checked class="custom-styled">
          <label for="custom-blend-${index}" class="checkbox-label"></label>
          <button type="button" class="remove-custom-color" data-id="${index}" title="Remove Custom Color">
              <span class="material-icons" style="font-size: 1.1em; vertical-align: middle;">delete_outline</span>
          </button>`;

      customColorList.appendChild(row);

      row.querySelector(`#custom-name-${index}`).addEventListener('input', () => updateMinimap(workflowSteps.INPUT_CUSTOM, 'human'));
      row.querySelector(`#custom-value-${index}`).addEventListener('input', () => updateMinimap(workflowSteps.INPUT_CUSTOM, 'human'));
      row.querySelector(`#custom-blend-${index}`).addEventListener('change', () => updateMinimap(workflowSteps.INPUT_CUSTOM, 'human'));

      row.querySelector(".remove-custom-color").addEventListener("click", (e) => {
          e.target.closest(".custom-color-row")?.remove();
          updateMinimap(workflowSteps.INPUT_CUSTOM, 'human');
      });
      updateMinimap(workflowSteps.INPUT_CUSTOM, 'human');
  }

  function handleImageFile(file) {
    if (!file?.type.startsWith("image/")) {
      showError("Invalid file type. Please upload an image.");
      return;
    }
    currentImageFile = file;
    const reader = new FileReader();
    reader.onload = (e) => {
      imagePreview.src = e.target.result;
      imagePreview.classList.remove("hidden");
      hideError();
       updateMinimap(workflowSteps.INPUT_IMAGE, 'human'); // Image loaded is human input completion
    };
    reader.onerror = () => {
      showError("Failed to read image file.");
      imagePreview.classList.add("hidden");
      imagePreview.src = "#";
      currentImageFile = null;
    };
    reader.readAsDataURL(file);
  }

  async function fetchM3Content() {
    if (m3ContentCache) return m3ContentCache;
    try {
        const response = await fetch("m3.txt");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        m3ContentCache = await response.text();
        return m3ContentCache;
    } catch (error) {
        console.error("Failed to fetch m3.txt:", error);
        showError("Failed to load base component guidelines (m3.txt). Gemini generation might be less accurate.");
        return ""; // Return empty string on failure
    }
  }

  async function getGeminiContent(endpoint, systemPrompt = "", userPrompt, isJsonResponse = false) {
      if (!isApiConfigValid) throw new Error("Gemini API is not configured in config.js");

      const fullApiUrl = `${endpoint}:generateContent?key=${API_KEY}`;
      let effectiveSystemPrompt = systemPrompt;

      if (USE_M3_TXT_SYS_PROMPT && systemPrompt.includes("Material Design 3")) { // Add M3 only if relevant
          const m3Content = await fetchM3Content();
          if (m3Content) {
              effectiveSystemPrompt += `\n\n# Material Design 3 Component Guidelines and Specifications\n\n${m3Content}`;
          }
      }

      const parts = [];
      if (effectiveSystemPrompt) parts.push({ text: effectiveSystemPrompt });
      parts.push({ text: userPrompt });

      const requestBody = {
        contents: [{ role: "user", parts: parts }], // Use explicit role
        generationConfig: {
          temperature: 0.6, // Slightly lower temp for more predictable structure
          maxOutputTokens: isJsonResponse ? 1024 : 4096, // Increased limits
          // topP: 0.9, // Optional: nucleus sampling
          // topK: 40   // Optional: top-k sampling
        },
        // safetySettings: [ // Optional: Adjust safety settings if needed
        //   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        //   // ... other categories
        // ]
      };
      if (isJsonResponse) requestBody.generationConfig.responseMimeType = "application/json";


      try {
        updateMinimap(workflowSteps.LLM_SUGGEST, 'gemini-bridge'); // Indicate API call start

        const response = await fetch(fullApiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
            let errorBodyText = await response.text();
            let errorDetails = errorBodyText;
            try { errorDetails = JSON.parse(errorBodyText); } catch (e) { /* ignore parsing error */ }
            console.error("Gemini API Error:", response.status, errorDetails);
            throw new Error(`API request failed: ${response.status} ${response.statusText}. Details: ${JSON.stringify(errorDetails)}`);
        }

        const data = await response.json();

        if (data.promptFeedback && data.promptFeedback.blockReason) {
            throw new Error(`API request blocked: ${data.promptFeedback.blockReason}. Details: ${JSON.stringify(data.promptFeedback.safetyRatings)}`);
        }

        const candidate = data.candidates?.[0];
        if (!candidate) throw new Error("API response missing candidates.");

        if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
            const safetyInfo = candidate.safetyRatings ? `Safety: ${JSON.stringify(candidate.safetyRatings)}` : "";
            throw new Error(`Generation stopped unexpectedly: ${candidate.finishReason}. ${safetyInfo}`);
        }

        const contentText = candidate.content?.parts?.[0]?.text;
        if (typeof contentText !== 'string') throw new Error("API response missing valid text content."); // Check type

        updateMinimap(workflowSteps.MCP_WRAP_SUGGEST, 'mcp'); // Indicate data returned to MCP layer
        return contentText;

      } catch (error) {
        console.error("Error during Gemini API call:", error);
         updateMinimap(workflowSteps.ERROR, 'error'); // Show error in minimap
        throw error; // Re-throw after logging and updating map
      }
  }


  async function getGeminiSuggestions(promptText) {
    updateMinimap(workflowSteps.MCP_WRAP_SUGGEST, 'mcp'); // Entering MCP abstraction
    const GEMINI_COLOR_SYSTEM_PROMPT = `You are a helpful color palette assistant. Given a text description, suggest exactly 3 DIFFERENT sets of 3 complementary hex color codes suitable for a Material Design 3 theme (Primary, Secondary, Tertiary). Respond ONLY with a valid JSON object containing a single key "suggestions". The value of "suggestions" must be an array containing exactly 3 sub-arrays. Each sub-array must contain exactly 3 valid 6-digit hex color strings (e.g., ["#RRGGBB", "#RRGGBB", "#RRGGBB"]). Example: {"suggestions": [["#6750A4", "#625B71", "#7D5260"], ["#00695C", "#4DB6AC", "#B2DFDB"], ["#B71C1C", "#EF9A9A", "#FFEBEE"]]}. Do not include any other text, explanations, apologies, or markdown formatting. Ensure the hex codes are valid and distinct sets are provided, reflecting the user's prompt.`;

    const jsonResponse = await getGeminiContent(geminiApiEndpointColorPicker, GEMINI_COLOR_SYSTEM_PROMPT, promptText, true);

    try {
      const parsed = JSON.parse(jsonResponse);
      if (!parsed || !Array.isArray(parsed.suggestions) || parsed.suggestions.length === 0) {
          throw new Error("Parsed JSON missing 'suggestions' array or is empty.");
      }

      const validSuggestions = parsed.suggestions.filter(s =>
          Array.isArray(s) && s.length === 3 && s.every(c => typeof c === 'string' && /^#[0-9A-F]{6}$/i.test(c))
      );

      if (validSuggestions.length === 0) {
          throw new Error("No valid suggestions found in the 'suggestions' array. Check structure and hex codes.");
      }

       // Return only valid ones, even if fewer than 3
      return { suggestions: validSuggestions };

    } catch (parseError) {
      console.error("Failed to parse Gemini JSON response:", parseError, "\nReceived:", jsonResponse);
      throw new Error(`Model returned invalid JSON or structure: ${parseError.message}`);
    }
  }

  async function simulateGeminiCall(promptText) {
    updateMinimap(workflowSteps.MCP_WRAP_SUGGEST, 'mcp');
    console.log("Simulating Gemini suggestion call for:", promptText);
    await new Promise((resolve) => setTimeout(resolve, 600 + Math.random() * 400)); // Simulate network delay

    // Collection of predefined color theme palettes.
    const predefinedSets = [
      ["#6750A4", "#625B71", "#7D5260"], // Default Material Purple/Pink
      ["#00695C", "#4DB6AC", "#B2DFDB"], // Teal/Aqua Green
      ["#B71C1C", "#EF9A9A", "#FFEBEE"], // Red/Pink
      ["#0D47A1", "#90CAF9", "#E3F2FD"], // Blue Tones
      ["#EF6C00", "#FFCA28", "#FFF9C4"], // Amber/Yellow
      ["#4E342E", "#A1887F", "#D7CCC8"], // Brown/Beige
      ["#311B92", "#9575CD", "#EDE7F6"], // Deep Purple/Lilac
    ];
    // Select 3 random *different* sets
    const suggestions = [];
    const availableIndices = predefinedSets.map((_, i) => i);
    while(suggestions.length < 3 && availableIndices.length > 0) {
        const randomIndex = Math.floor(Math.random() * availableIndices.length);
        const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
        suggestions.push(predefinedSets[selectedIndex]);
    }

    updateMinimap(workflowSteps.LLM_SUGGEST, 'tool'); // Indicate simulation tool ran
    updateMinimap(workflowSteps.MCP_WRAP_SUGGEST, 'mcp'); // Data returned
    return { suggestions: suggestions };
  }

  function displaySuggestions(suggestionData) {
      textPromptSuggestionsContainer.innerHTML = '<label>Select a suggested color set:</label>'; // Reset
      if (!suggestionData?.suggestions?.length) {
        textPromptSuggestionsContainer.innerHTML += '<p style="color: var(--md-sys-color-outline-light); font-size: 0.9em;">No valid suggestions generated.</p>';
        textPromptSuggestionsContainer.classList.remove("hidden");
        updateMinimap(workflowSteps.DISPLAY_SUGGESTIONS, 'result'); // Show result (empty)
        return;
      }

      suggestionData.suggestions.forEach((colorSet, index) => {
        // Basic validation already done in getGeminiSuggestions, but double-check format just in case
        if (!Array.isArray(colorSet) || colorSet.length !== 3 || !colorSet.every(c => /^#[0-9A-F]{6}$/i.test(c))) {
            console.warn("Skipping invalid suggestion format:", colorSet);
            return;
        }

        const div = document.createElement("div");
        div.classList.add("suggestion-option");
        div.dataset.colors = JSON.stringify(colorSet); // Store colors for easy retrieval
        div.setAttribute("role", "button");
        div.tabIndex = 0; // Make it focusable

        const swatchesHtml = colorSet.map(hex => `<span class="suggestion-swatch" style="background-color: ${hex};" title="${hex}"></span>`).join("");
        const radioId = `suggestion_${index}`; // Unique ID for the radio

        div.innerHTML = `
            <input type="radio" name="suggestion_radio" id="${radioId}" value='${JSON.stringify(colorSet)}' class="hidden">
            <label for="${radioId}">${swatchesHtml}<span>Option ${index + 1}</span></label>`;

        div.addEventListener("click", handleSuggestionSelection);
        div.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Enter") {
            handleSuggestionSelection.call(div, e); // Use call to set 'this' correctly
            e.preventDefault();
          }
        });

        textPromptSuggestionsContainer.appendChild(div);
      });

      if (textPromptSuggestionsContainer.querySelectorAll(".suggestion-option").length > 0) {
        textPromptSuggestionsContainer.classList.remove("hidden");
      } else {
        // This case should ideally not happen if validation upstream is correct
        textPromptSuggestionsContainer.innerHTML += '<p style="color: var(--md-sys-color-outline-light);">No valid suggestions could be displayed.</p>';
        textPromptSuggestionsContainer.classList.remove("hidden");
      }
      updateMinimap(workflowSteps.DISPLAY_SUGGESTIONS, 'result');
  }

  function handleSuggestionSelection(event) {
      const selectedDiv = this; // 'this' refers to the clicked div element
      event.preventDefault(); // Prevent default if triggered by keydown on label etc.

      const colorsJson = selectedDiv.dataset.colors;
      if (!colorsJson) return;

      try {
        const colors = JSON.parse(colorsJson);
        if (!Array.isArray(colors) || colors.length !== 3) throw new Error("Invalid color data in suggestion.");

        // Ensure source inputs exist for text mode (they should be created by updateInputUI)
        let sourceInputs = sourceColorInputsContainer.querySelectorAll('input[type="color"]');
        if (currentMode === 'modeText' && sourceInputs.length < 3) {
            // If inputs aren't there for some reason, create them
             sourceColorArea.classList.remove("hidden");
             sourceColorLabel.textContent = "Source Colors:";
             sourceColorInputsContainer.innerHTML = ''; // Clear any potential partial state
             addSourceColorInput(0, "Primary", false); // Now enable them
             addSourceColorInput(1, "Secondary", false);
             addSourceColorInput(2, "Tertiary", false);
             sourceInputs = sourceColorInputsContainer.querySelectorAll('input[type="color"]');
              if (sourceInputs.length < 3) throw new Error("Failed to create source color inputs.");
        } else if (sourceInputs.length < 3) {
             throw new Error("Source color inputs are missing.");
        }

        colors.forEach((color, index) => {
          if (sourceInputs[index]) {
            sourceInputs[index].value = color;
            sourceInputs[index].disabled = false; // Enable the input
            // Trigger 'input' event manually if needed, though direct value set usually suffices
             sourceInputs[index].dispatchEvent(new Event('input', { bubbles: true }));
          }
        });

        // Visually mark the selected option
        document.querySelectorAll(".suggestion-option.selected").forEach((el) => el.classList.remove("selected"));
        selectedDiv.classList.add("selected");

        // Also check the hidden radio button for form semantics if needed later
        const radio = selectedDiv.querySelector('input[type="radio"]');
        if (radio) radio.checked = true;

        hideError(); // Clear any previous errors
        updateMinimap(workflowSteps.SELECT_SUGGESTION, 'human');

      } catch (error) {
        showError(`Failed to apply suggestion: ${error.message}`);
        console.error("Suggestion application error:", error);
      }
  }

  function applyScopedThemeStyles(theme) {
      if (!theme?.schemes) return;

      const lightCSS = [], darkCSS = [];
      const previewSelectorBase = `#mwc-component-preview, #gemini-component-preview`;

      for (const [schemeKey, scheme] of Object.entries(theme.schemes)) {
          const isDark = schemeKey === "dark";
          const selector = isDark ? `${previewSelectorBase}.dark-theme` : `${previewSelectorBase}:not(.dark-theme)`;
          const targetCSS = isDark ? darkCSS : lightCSS;

          targetCSS.push(`${selector} {`);
          for (const [token, value] of Object.entries(scheme)) {
              if (typeof value === 'number') { // Ensure value is a number (ARGB int)
                  const kebab = token.replace(/([A-Z])/g, "-$1").toLowerCase();
                  targetCSS.push(`--local-sys-color-${kebab}: ${argbIntToHex(value)};`);
              }
          }

          // Apply custom color variables
          if (ENABLE_CUSTOM_COLORS && theme.customColors?.length > 0) {
              theme.customColors.forEach((customGroup) => {
                  if (customGroup[schemeKey]) {
                       // Sanitize name for CSS variable
                      const baseName = (customGroup.color.name || "custom")
                          .replace(/[^a-zA-Z0-9_-]/g, '-') // Replace invalid chars with hyphen
                          .replace(/-+/g, '-')             // Collapse multiple hyphens
                          .replace(/^-+|-+$/g, '')       // Trim leading/trailing hyphens
                          .toLowerCase() || `custom-${customGroup.color.value}`; // Fallback if name becomes empty

                      for (const [token, value] of Object.entries(customGroup[schemeKey])) {
                           if (typeof value === 'number') {
                              const kebab = token.replace(/([A-Z])/g, "-$1").toLowerCase();
                              targetCSS.push(`--local-sys-color-custom-${baseName}-${kebab}: ${argbIntToHex(value)};`);
                           }
                      }
                  }
              });
          }
          targetCSS.push("}");
      }

      dynamicThemeStyles.textContent = lightCSS.join("\n") + "\n" + darkCSS.join("\n");
  }

 function generateMwcComponents(applyStyles = true) {
      if (!lastGeneratedTheme?.schemes) {
          showError("Please generate a theme first.");
          return;
      }
      updateMinimap(workflowSteps.CLICK_GEN_MWC, 'human');
      updateMinimap(workflowSteps.MCP_WRAP_GEN_COMP, 'mcp');

      if (applyStyles) {
        applyScopedThemeStyles(lastGeneratedTheme);
      }

      const mwcHTML = `
          <div style="display:flex;flex-direction:column;gap:25px;">
              <div>
                  <h5>Buttons & FAB</h5>
                  <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;">
                      <md-filled-button>Filled</md-filled-button>
                      <md-outlined-button>Outlined</md-outlined-button>
                      <md-fab aria-label="Edit">
                          <md-icon slot="icon">edit</md-icon>
                      </md-fab>
                  </div>
              </div>
               <div>
                   <h5>Chips</h5>
                   <md-chip-set style="display:flex;flex-wrap:wrap;gap:8px;">
                       <md-assist-chip label="Assist"></md-assist-chip>
                       <md-filter-chip label="Filter" elevated></md-filter-chip>
                       <md-suggestion-chip label="Suggest"></md-suggestion-chip>
                   </md-chip-set>
              </div>
              <div>
                  <h5>Slider</h5>
                  <md-slider ticks value="65" style="width: 80%;"></md-slider>
              </div>
              <div>
                  <h5>Card</h5>
                  <md-card style="padding:16px;max-width:350px;">
                      <p style="margin:0; font-weight: 500;">The Music Dance Experience is officially CANCELED.</p>
                   </md-card>
              </div>
           </div>`;

      mwcComponentPreview.innerHTML = `<h4>MWC Preview</h4> ${mwcHTML}`;
      mwcComponentPreview.classList.toggle("dark-theme", isDarkMode); // Ensure correct theme class
      updateMinimap(workflowSteps.TOOL_RENDER_MWC, 'tool');
      updateMinimap(workflowSteps.DISPLAY_COMPONENTS, 'result');
  }

  const GEMINI_COMPONENT_SYSTEM_PROMPT = `You are an expert web UI designer specializing in Material Design 3. You will be given:
1.  A Material Design 3 color theme represented as CSS custom properties starting with '--local-sys-color-...'. These variables are dynamically updated for light and dark modes by the host environment. You should use these variables directly in your CSS.
2.  An optional user style prompt.

Your task is to:
- Create an HTML structure containing ONLY the following components IN THIS ORDER:
    - Two buttons: one filled (<button class="gemini-filled-button">Filled</button>), one outlined (<button class="gemini-outlined-button">Outlined</button>).
    - One Floating Action Button (FAB) (<button class="gemini-fab"><span class="material-icons">edit</span></button>). Use a standard HTML button and span for the icon.
    - Three chips (<span class="gemini-chip">Assist</span>, <span class="gemini-chip gemini-elevated">Filter</span>, <span class="gemini-chip">Suggest</span>). Use standard HTML spans.
    - One slider element (<input type="range" class="gemini-slider" value="65">). Use a standard HTML range input.
    - One card (<div class="gemini-card"><p>The Music Dance Experience is officially CANCELED.</p></div>). Use standard HTML divs and paragraphs.
- Apply styling using ONLY CSS classes defined within a SINGLE '<style>' tag in your response. Define base styles first, then dark mode overrides using a '.dark-theme' prefix (e.g., '.dark-theme .gemini-card { ... }').
- **CRITICAL:** Use the provided --local-sys-color-... CSS variables extensively and semantically for ALL colors (backgrounds, text, borders, icons, states like :hover). Apply styles assuming the variables correctly reflect the current (light or dark) theme.
- Incorporate the user's style prompt (if provided) to influence visual design (spacing, border-radius, font weights, layout, etc.) subtly. If no prompt, use a standard, clean Material Design appearance.
- Ensure the output is visually coherent, uses appropriate padding/margins, and looks like a standard Material Design layout.
- Respond ONLY with the final combined HTML structure (using the specific tags and classes mentioned above) and the single '<style>' tag containing all CSS definitions. Do not include explanations, markdown formatting, <!DOCTYPE>, <html>, <body> tags, or any other elements.`;


  async function generateGeminiComponents() {
      if (!lastGeneratedTheme) {
        showError("Generate a theme first.");
        return;
      }
      if (!isApiConfigValid) {
        showError("Gemini API is not configured.");
        return;
      }

      updateMinimap(workflowSteps.CLICK_GEN_GEMINI, 'human');
      updateMinimap(workflowSteps.MCP_WRAP_GEN_COMP, 'mcp');

      setGeminiComponentLoading(true);
      geminiComponentPreview.innerHTML = ''; // Clear previous
      hideError();

      try {
        const stylePrompt = componentStylePromptInput.value.trim();

        // Create a string representation of the theme variables for the prompt
        let themeVariablesString = "";
        if (lastGeneratedTheme.schemes.light) {
            themeVariablesString += "/* Light Theme Variables (Example Values) */\n:root {\n";
            for (const [token, value] of Object.entries(lastGeneratedTheme.schemes.light)) {
                 if (typeof value === 'number') {
                    const kebab = token.replace(/([A-Z])/g, "-$1").toLowerCase();
                    themeVariablesString += `  --local-sys-color-${kebab}: ${argbIntToHex(value)};\n`;
                 }
            }
            if (ENABLE_CUSTOM_COLORS && lastGeneratedTheme.customColors?.length > 0) {
                lastGeneratedTheme.customColors.forEach((customGroup) => {
                    if (customGroup.light) {
                        const baseName = (customGroup.color.name || "custom").replace(/[^a-zA-Z0-9_-]/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '').toLowerCase() || `custom-${customGroup.color.value}`;
                        for (const [token, value] of Object.entries(customGroup.light)) {
                            if (typeof value === 'number') {
                                const kebab = token.replace(/([A-Z])/g, "-$1").toLowerCase();
                                themeVariablesString += `  --local-sys-color-custom-${baseName}-${kebab}: ${argbIntToHex(value)};\n`;
                            }
                        }
                    }
                });
            }
             themeVariablesString += "}\n";
        }
         // Note: We don't need to send dark vars, the prompt tells Gemini to use the same vars under .dark-theme selector

        const fullPrompt = `MATERIAL DESIGN 3 THEME VARIABLES (Use these variable names in your CSS):\n\`\`\`css\n${themeVariablesString}\n\`\`\`\n\nUSER STYLE PROMPT: ${stylePrompt || "Default clean Material Design style."}\n\nGenerate the HTML structure and CSS for the requested components based on the system instructions. Use the EXACT HTML tags and classes specified. Ensure CSS uses the --local-sys-color-... variables.`;

        const generatedHtmlAndCss = await getGeminiContent(
            geminiApiEndpointComponentGenerator,
            GEMINI_COMPONENT_SYSTEM_PROMPT,
            fullPrompt,
            false // Expecting HTML/CSS text
        );

        // Basic cleaning for common markdown fences
        let cleanedHtmlCss = generatedHtmlAndCss
            .replace(/^\s*```(?:html|css|markup|)\s*\n?/im, "") // Remove opening fence variations
            .replace(/\n?\s*```\s*$/im, "") // Remove closing fence
            .trim();

        geminiComponentPreview.innerHTML = `<h4>Gemini Preview</h4> ${cleanedHtmlCss}`;
        geminiComponentPreview.classList.toggle("dark-theme", isDarkMode); // Ensure correct theme
        updateMinimap(workflowSteps.DISPLAY_COMPONENTS, 'result');

      } catch (error) {
        showError(`Gemini component generation failed: ${error.message}`);
        geminiComponentPreview.innerHTML = `<h4 class="error">Gemini Preview</h4><p class="error">Failed to generate components via Gemini.</p>`;
      } finally {
        setGeminiComponentLoading(false);
      }
  }

  function setupEventListeners() {
      modeRadios.forEach((radio) => radio.addEventListener("change", (e) => updateInputUI(e.target.value)));

      dropArea.addEventListener("click", () => imageInput.click());
      dropArea.addEventListener("dragover", (e) => { e.preventDefault(); dropArea.classList.add("drag-over"); });
      dropArea.addEventListener("dragleave", () => dropArea.classList.remove("drag-over"));
      dropArea.addEventListener("drop", (e) => {
          e.preventDefault();
          dropArea.classList.remove("drag-over");
          if (e.dataTransfer.files.length) handleImageFile(e.dataTransfer.files[0]);
      });
      imageInput.addEventListener("change", (e) => { if (e.target.files.length) handleImageFile(e.target.files[0]); });

      if (ENABLE_CUSTOM_COLORS) {
         addCustomColorButton.addEventListener("click", addCustomColorRow);
      }

      suggestColorsButton.addEventListener("click", async () => {
        const promptText = textPromptInput.value.trim();
        if (!promptText) {
          showError("Please enter a theme description first.");
          return;
        }
        updateMinimap(workflowSteps.CLICK_SUGGEST, 'human');

        hideError();
        setSuggestionLoading(true);
        textPromptSuggestionsContainer.classList.add("hidden"); // Hide while loading

        try {
          const useSim = useSimulationCheckbox.checked;
          const useApi = !useSim && isApiConfigValid;

          if (useApi) {
              console.log("Calling Gemini API for color suggestions...");
              const data = await getGeminiSuggestions(promptText);
              displaySuggestions(data);
          } else if (!isApiConfigValid && !useSim) {
              console.warn("API request attempted but config is invalid and simulation unchecked.");
              showError("Gemini API not configured. Check simulation box or configure API in config.js.");
              // No suggestions to display
              textPromptSuggestionsContainer.innerHTML = '<label>Select a suggested color set:</label><p class="error">API not configured.</p>';
              textPromptSuggestionsContainer.classList.remove('hidden');
              updateMinimap(workflowSteps.ERROR, 'error');
          } else {
              console.log("Simulating color suggestions...");
              const data = await simulateGeminiCall(promptText);
              displaySuggestions(data);
          }

        } catch (error) {
          showError(`Failed to get suggestions: ${error.message}`);
          textPromptSuggestionsContainer.innerHTML = '<label>Select a suggested color set:</label><p class="error">Failed to load suggestions.</p>';
          textPromptSuggestionsContainer.classList.remove('hidden'); // Show the container with error
          console.error("Suggestion Error:", error);
        } finally {
          setSuggestionLoading(false);
        }
      });

      generateButton.addEventListener("click", async () => {
          updateMinimap(workflowSteps.CLICK_GENERATE, 'human');
          updateMinimap(workflowSteps.MCP_WRAP_GENERATE, 'mcp');
          setUILoading(true, currentMode);
          paletteDisplay.innerHTML = '<p class="placeholder">Generating theme...</p>';
          seedColorsDisplayContainer.innerHTML = "";
          hideError();

          // Check dream.js functions exist (basic check)
          const dreamExists = typeof themeFromSourceColor === 'function' &&
                              typeof themeFromSourceColors === 'function' &&
                              (!ENABLE_IMAGES || (typeof sourceColorFromImage === 'function' && typeof sourceColorsFromImage === 'function'));
           if (!dreamExists) {
              showError("Core color generation library (dream.js) or required functions not found. Check console.");
              console.error("Missing functions from dream.js. Ensure it's loaded correctly.");
              setUILoading(false);
              return;
           }


          try {
              let theme, seeds = [];
              const customData = ENABLE_CUSTOM_COLORS ? Array.from(customColorList.children).map(row => {
                  const id = row.dataset.id;
                  return {
                      name: row.querySelector(`#custom-name-${id}`)?.value || `custom_${id}`,
                      value: hexToArgbInt(row.querySelector(`#custom-value-${id}`)?.value),
                      blend: row.querySelector(`#custom-blend-${id}`)?.checked || false,
                  };
              }).filter(c => typeof c.value === 'number' && c.value !== 0) : []; // Ensure value is valid number

              let effectiveMode = currentMode;
              // Adjust mode if features are disabled but mode selected relies on them
              if (!ENABLE_CUSTOM_COLORS && (effectiveMode === 'mode4' || effectiveMode === 'mode2')) {
                  effectiveMode = (effectiveMode === 'mode4') ? 'mode3' : 'mode1';
              }
              if (!ENABLE_IMAGES && (effectiveMode.startsWith('modeImage'))) {
                  effectiveMode = 'modeText'; // Default to text if image modes disabled
                  document.getElementById("modeText").checked = true; // Update UI radio
                  updateInputUI(effectiveMode); // Refresh UI for text mode
                  showError("Image modes disabled in config. Defaulting to Text mode.");
                  setUILoading(false);
                  return; // Stop generation as mode changed
              }


              let harmony = "direct"; // Default
              if (!multiSourceOptionsArea.classList.contains('hidden') && harmonyStrategySelect) {
                   harmony = harmonyStrategySelect.value;
              }
              const themeOptions = {
                    harmonyStrategy: harmony,
                    customColors: customData
              };

              // --- Generation Logic based on effectiveMode ---
              if (effectiveMode === 'mode3' || effectiveMode === 'mode4') {
                   const input = document.getElementById('source-color-0');
                   if (!input) throw new Error("Source color input #0 is missing.");
                   const colorValue = hexToArgbInt(input.value);
                   if (colorValue === 0 && !['#000', '#000000'].includes(input.value.toLowerCase())) {
                        throw new Error(`Invalid source color hex value: ${input.value}`);
                   }
                   seeds = [colorValue];
                   updateMinimap(workflowSteps.TOOL_COLOR_MATH, 'tool');
                   theme = themeFromSourceColor(colorValue, themeOptions.customColors);
              }
              else if (effectiveMode === 'mode1' || effectiveMode === 'mode2' || effectiveMode === 'modeText') {
                  const inputs = [0, 1, 2].map(i => document.getElementById(`source-color-${i}`));
                   if (inputs.some(input => !input)) throw new Error("One or more source color inputs are missing.");

                   const values = inputs.map((input, idx) => {
                       if (input.disabled) return null; // Skip disabled inputs (like in default text mode)
                       const hex = input.value;
                       const argb = hexToArgbInt(hex);
                       if (argb === 0 && !['#000', '#000000'].includes(hex.toLowerCase())) {
                           throw new Error(`Invalid hex value for ${input.previousElementSibling?.textContent || `Color ${idx+1}`}: ${hex}`);
                       }
                       return argb;
                   }).filter(v => typeof v === 'number'); // Filter out nulls

                   if (values.length === 0) {
                       throw new Error(effectiveMode === 'modeText' ? "Please select a suggestion or provide source colors manually." : "Please provide at least one source color.");
                   }
                   seeds = values;
                   updateMinimap(workflowSteps.TOOL_COLOR_MATH, 'tool');
                   theme = seeds.length === 1
                        ? themeFromSourceColor(seeds[0], themeOptions.customColors) // Use single color function if only one provided
                        : themeFromSourceColors(seeds, themeOptions);
              }
              else if (ENABLE_IMAGES && (effectiveMode === 'modeImageSingle' || effectiveMode === 'modeImageMulti')) {
                  if (!currentImageFile || !imagePreview.src || imagePreview.src.startsWith('#')) throw new Error("Please upload or select an image.");

                  updateMinimap(workflowSteps.TOOL_IMAGE_PROC, 'tool');
                  const img = await new Promise((resolve, reject) => {
                      const i = new Image();
                      i.onload = () => resolve(i);
                      i.onerror = (err) => reject(new Error(`Image could not be loaded: ${err.type || 'error'}`));
                      i.src = imagePreview.src;
                       // Handle cases where image might already be loaded from cache
                      if (i.complete && i.naturalWidth > 0) setTimeout(() => resolve(i), 0);
                  });


                  if (effectiveMode === 'modeImageSingle') {
                      const srcColor = await sourceColorFromImage(img); // Assumes dream.js provides this
                      if (typeof srcColor !== 'number') throw new Error("Failed to extract dominant color from image.");
                      seeds = [srcColor];
                      updateMinimap(workflowSteps.TOOL_COLOR_MATH, 'tool');
                      theme = themeFromSourceColor(srcColor, themeOptions.customColors);
                  } else { // modeImageMulti
                       const num = parseInt(numSourcesInput.value, 10) || 5;
                       const qual = parseInt(extractQualityInput.value, 10) || 10;
                       themeOptions.numSources = num;
                       themeOptions.extractQuality = qual;

                      // Use combined function if available in dream.js, otherwise do separate steps
                      if (typeof themeFromImageUsingSources === "function") {
                          theme = await themeFromImageUsingSources(img, themeOptions);
                          // Try to get the seeds separately for display, fallback to theme.source
                          try {
                              seeds = await sourceColorsFromImage(img, num, qual);
                          } catch (seedError) {
                               console.warn("Could not re-extract seeds for display:", seedError);
                               seeds = theme?.source ? (Array.isArray(theme.source) ? theme.source : [theme.source]) : [];
                          }
                          updateMinimap(workflowSteps.TOOL_COLOR_MATH, 'tool'); // Color math is part of the combined func
                      } else {
                           seeds = await sourceColorsFromImage(img, num, qual);
                           if (!seeds?.length) throw new Error("Failed to extract multiple colors from image.");
                           updateMinimap(workflowSteps.TOOL_COLOR_MATH, 'tool');
                           theme = themeFromSourceColors(seeds, themeOptions);
                      }
                  }
              }
              else {
                  throw new Error("Invalid or unsupported generation mode selected.");
              }

              // --- Display Results ---
              if (theme) {
                  seedColorsDisplayContainer.innerHTML = ""; // Clear placeholder
                  if (seeds?.length) {
                      seeds.forEach((seed, i) => {
                          if (typeof seed === 'number')
                              seedColorsDisplayContainer.innerHTML += createSwatchHtml(`Seed ${i + 1}`, seed, "seed-swatch");
                      });
                  } else if (theme.source) { // Fallback for single source if seeds array empty
                      const sourceSeed = Array.isArray(theme.source) ? theme.source[0] : theme.source;
                      if(typeof sourceSeed === 'number')
                         seedColorsDisplayContainer.innerHTML = createSwatchHtml(`Source`, sourceSeed, "seed-swatch");
                  }

                  if (!seedColorsDisplayContainer.hasChildNodes()) {
                       seedColorsDisplayContainer.innerHTML = '<p style="font-size:0.9em;color:var(--md-sys-color-outline-light);">Seed colors unavailable.</p>';
                  }
                  displayTheme(theme); // This handles displaying palettes and updating minimap to result
              } else {
                  showError("Theme generation failed. No theme object was returned.");
              }

          } catch (error) {
            showError(`Generation Error: ${error.message}`);
            paletteDisplay.innerHTML = '<p class="placeholder error">Error generating theme.</p>';
            console.error("Generation Process Error:", error);
          } finally {
            setUILoading(false);
             updateMinimap(workflowSteps.MCP_WRAP_GENERATE, 'mcp'); // Exiting MCP abstraction
          }
      });

      generateMwcComponentsButton.addEventListener("click", () => generateMwcComponents(true)); // Explicit click generates MWC
      generateGeminiComponentsButton.addEventListener("click", generateGeminiComponents); // Explicit click generates Gemini

  }

  initializeApp();
});
    </script>
  </body>
</html>
