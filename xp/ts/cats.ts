/**
 * @license
 * MIT License
 *
 * Copyright (c) 2025 dream
 *
 * This software, "dream", is a fork of Google's material-color-utilities
 * (https://github.com/material-foundation/material-color-utilities).
 * While based on and incorporating concepts and code from the original
 * material-color-utilities project, "hctjs" is maintained and distributed
 * under the terms of the MIT License as set forth below.
 *
 * The original material-color-utilities project is licensed under the
 * Apache License 2.0.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice, including the
 * acknowledgement of the original material-color-utilities project, shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


// --- Exported Namespace Alias Objects ---
export const math = { clampDouble, clampInt, differenceDegrees, lerp, matrixMultiply, rotationDirection, sanitizeDegreesDouble, sanitizeDegreesInt, signum };
export const utils = { alphaFromArgb, argbFromLab, argbFromLinrgb, argbFromLstar, argbFromRgb, argbFromXyz, blueFromArgb, delinearized, greenFromArgb, isOpaque, labFromArgb, linearized, lstarFromArgb, lstarFromY, redFromArgb, whitePointD65, xyzFromArgb, yFromLstar };
// --- End Exported Namespace Alias Objects ---



// --- BEGIN FILE: blend/blend.ts ---
// This file is automatically generated. Do not modify it.


// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable:class-as-namespace

/**
 * Functions for blending in HCT and CAM16.
 */
export class Blend {
  /**
   * Blend the design color's HCT hue towards the key color's HCT
   * hue, in a way that leaves the original color recognizable and
   * recognizably shifted towards the key color.
   *
   * @param designColor ARGB representation of an arbitrary color.
   * @param sourceColor ARGB representation of the main theme color.
   * @return The design color with a hue shifted towards the
   * system's color, a slightly warmer/cooler variant of the design
   * color's hue.
   */
  static harmonize(designColor: number, sourceColor: number): number {
    const fromHct = Hct.fromInt(designColor);
    const toHct = Hct.fromInt(sourceColor);
    const differenceDegrees =
      math.differenceDegrees(fromHct.hue, toHct.hue);
    const rotationDegrees = Math.min(differenceDegrees * 0.5, 15.0);
    const outputHue = math.sanitizeDegreesDouble(
      fromHct.hue +
      rotationDegrees * math.rotationDirection(fromHct.hue, toHct.hue));
    return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
  }

  /**
   * Blends hue from one color into another. The chroma and tone of
   * the original color are maintained.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, with a hue blended towards to. Chroma and tone
   * are constant.
   */
  static hctHue(from: number, to: number, amount: number): number {
    const ucs = Blend.cam16Ucs(from, to, amount);
    const ucsCam = Cam16.fromInt(ucs);
    const fromCam = Cam16.fromInt(from);
    const blended = Hct.from(
      ucsCam.hue,
      fromCam.chroma,
      utils.lstarFromArgb(from),
    );
    return blended.toInt();
  }

  /**
   * Blend in CAM16-UCS space.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, blended towards to. Hue, chroma, and tone will
   * change.
   */
  static cam16Ucs(from: number, to: number, amount: number): number {
    const fromCam = Cam16.fromInt(from);
    const toCam = Cam16.fromInt(to);
    const fromJ = fromCam.jstar;
    const fromA = fromCam.astar;
    const fromB = fromCam.bstar;
    const toJ = toCam.jstar;
    const toA = toCam.astar;
    const toB = toCam.bstar;
    const jstar = fromJ + (toJ - fromJ) * amount;
    const astar = fromA + (toA - fromA) * amount;
    const bstar = fromB + (toB - fromB) * amount;
    return Cam16.fromUcs(jstar, astar, bstar).toInt();
  }
}
// --- END FILE: blend/blend.ts ---


// --- BEGIN FILE: contrast/contrast.ts ---
// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable:class-as-namespace



/**
 * Utility methods for calculating contrast given two colors, or calculating a
 * color given one color and a contrast ratio.
 *
 * Contrast ratio is calculated using XYZ's Y. When linearized to match human
 * perception, Y becomes HCT's tone and L*a*b*'s' L*. Informally, this is the
 * lightness of a color.
 *
 * Methods refer to tone, T in the the HCT color space.
 * Tone is equivalent to L* in the L*a*b* color space, or L in the LCH color
 * space.
 */
export class Contrast {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(toneA: number, toneB: number): number {
    toneA = math.clampDouble(0.0, 100.0, toneA);
    toneB = math.clampDouble(0.0, 100.0, toneB);
    return Contrast.ratioOfYs(utils.yFromLstar(toneA), utils.yFromLstar(toneB));
  }

  static ratioOfYs(y1: number, y2: number): number {
    const lighter = y1 > y2 ? y1 : y2;
    const darker = (lighter === y2) ? y1 : y2;
    return (lighter + 5.0) / (darker + 5.0);
  }

  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(tone: number, ratio: number): number {
    if (tone < 0.0 || tone > 100.0) {
      return -1.0;
    }

    const darkY = utils.yFromLstar(tone);
    const lightY = ratio * (darkY + 5.0) - 5.0;
    const realContrast = Contrast.ratioOfYs(lightY, darkY);
    const delta = Math.abs(realContrast - ratio);
    if (realContrast < ratio && delta > 0.04) {
      return -1;
    }

    // Ensure gamut mapping, which requires a 'range' on tone, will still result
    // the correct ratio by darkening slightly.
    const returnValue = utils.lstarFromY(lightY) + 0.4;
    if (returnValue < 0 || returnValue > 100) {
      return -1;
    }
    return returnValue;
  }

  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(tone: number, ratio: number): number {
    if (tone < 0.0 || tone > 100.0) {
      return -1.0;
    }

    const lightY = utils.yFromLstar(tone);
    const darkY = ((lightY + 5.0) / ratio) - 5.0;
    const realContrast = Contrast.ratioOfYs(lightY, darkY);

    const delta = Math.abs(realContrast - ratio);
    if (realContrast < ratio && delta > 0.04) {
      return -1;
    }

    // Ensure gamut mapping, which requires a 'range' on tone, will still result
    // the correct ratio by darkening slightly.
    const returnValue = utils.lstarFromY(darkY) - 0.4;
    if (returnValue < 0 || returnValue > 100) {
      return -1;
    }
    return returnValue;
  }

  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(tone: number, ratio: number): number {
    const lighterSafe = Contrast.lighter(tone, ratio);
    return (lighterSafe < 0.0) ? 100.0 : lighterSafe;
  }

  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(tone: number, ratio: number): number {
    const darkerSafe = Contrast.darker(tone, ratio);
    return (darkerSafe < 0.0) ? 0.0 : darkerSafe;
  }
}
// --- END FILE: contrast/contrast.ts ---


// --- BEGIN FILE: dislike/dislike_analyzer.ts ---
// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable:class-as-namespace

/**
 * Check and/or fix universally disliked colors.
 * Color science studies of color preference indicate universal distaste for
 * dark yellow-greens, and also show this is correlated to distate for
 * biological waste and rotting food.
 *
 * See Palmer and Schloss, 2010 or Schloss and Palmer's Chapter 21 in Handbook
 * of Color Psychology (2015).
 */
export class DislikeAnalyzer {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(hct: Hct): boolean {
    const huePasses =
      Math.round(hct.hue) >= 90.0 && Math.round(hct.hue) <= 111.0;
    const chromaPasses = Math.round(hct.chroma) > 16.0;
    const tonePasses = Math.round(hct.tone) < 65.0;

    return huePasses && chromaPasses && tonePasses;
  }

  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(hct: Hct): Hct {
    if (DislikeAnalyzer.isDisliked(hct)) {
      return Hct.from(
        hct.hue,
        hct.chroma,
        70.0,
      );
    }

    return hct;
  }
}
// --- END FILE: dislike/dislike_analyzer.ts ---


// --- BEGIN FILE: dynamiccolor/contrast_curve.ts ---
/**
 * A class containing a value that changes with the contrast level.
 *
 * Usually represents the contrast requirements for a dynamic color on its
 * background. The four values correspond to values for contrast levels -1.0,
 * 0.0, 0.5, and 1.0, respectively.
 */
export class ContrastCurve {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(
    readonly low: number,
    readonly normal: number,
    readonly medium: number,
    readonly high: number,
  ) { }

  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(contrastLevel: number): number {
    if (contrastLevel <= -1.0) {
      return this.low;
    } else if (contrastLevel < 0.0) {
      return math.lerp(this.low, this.normal, (contrastLevel - (-1)) / 1);
    } else if (contrastLevel < 0.5) {
      return math.lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5);
    } else if (contrastLevel < 1.0) {
      return math.lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);
    } else {
      return this.high;
    }
  }
}
// --- END FILE: dynamiccolor/contrast_curve.ts ---


// --- BEGIN FILE: dynamiccolor/dynamic_color.ts ---
/**
 * @param name The name of the dynamic color. Defaults to empty.
 * @param palette Function that provides a TonalPalette given
 * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
 * replaces the need to specify hue/chroma. By providing a tonal palette, when
 * contrast adjustments are made, intended chroma can be preserved.
 * @param tone Function that provides a tone given DynamicScheme.
 * @param isBackground Whether this dynamic color is a background, with
 * some other color as the foreground. Defaults to false.
 * @param background The background of the dynamic color (as a function of a
 *     `DynamicScheme`), if it exists.
 * @param secondBackground A second background of the dynamic color (as a
 *     function of a `DynamicScheme`), if it
 * exists.
 * @param contrastCurve A `ContrastCurve` object specifying how its contrast
 * against its background should behave in various contrast levels options.
 * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
 * constraint between two colors. One of them must be the color being
 * constructed.
 */
export interface FromPaletteOptions {
  name?: string;
  palette: (scheme: DynamicScheme) => TonalPalette;
  tone: (scheme: DynamicScheme) => number;
  isBackground?: boolean;
  background?: (scheme: DynamicScheme) => DynamicColor;
  secondBackground?: (scheme: DynamicScheme) => DynamicColor;
  contrastCurve?: ContrastCurve;
  toneDeltaPair?: (scheme: DynamicScheme) => ToneDeltaPair;
}

/**
 * A color that adjusts itself based on UI state provided by DynamicScheme.
 *
 * Colors without backgrounds do not change tone when contrast changes. Colors
 * with backgrounds become closer to their background as contrast lowers, and
 * further when contrast increases.
 *
 * Prefer static constructors. They require either a hexcode, a palette and
 * tone, or a hue and chroma. Optionally, they can provide a background
 * DynamicColor.
 */
export class DynamicColor {
  private readonly hctCache = new Map<DynamicScheme, Hct>();

  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(args: FromPaletteOptions): DynamicColor {
    return new DynamicColor(
      args.name ?? '',
      args.palette,
      args.tone,
      args.isBackground ?? false,
      args.background,
      args.secondBackground,
      args.contrastCurve,
      args.toneDeltaPair,
    );
  }

  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(
    readonly name: string,
    readonly palette: (scheme: DynamicScheme) => TonalPalette,
    readonly tone: (scheme: DynamicScheme) => number,
    readonly isBackground: boolean,
    readonly background?: (scheme: DynamicScheme) => DynamicColor,
    readonly secondBackground?: (scheme: DynamicScheme) => DynamicColor,
    readonly contrastCurve?: ContrastCurve,
    readonly toneDeltaPair?: (scheme: DynamicScheme) => ToneDeltaPair,
  ) {
    if ((!background) && secondBackground) {
      throw new Error(
        `Color ${name} has secondBackground` +
        `defined, but background is not defined.`);
    }
    if ((!background) && contrastCurve) {
      throw new Error(
        `Color ${name} has contrastCurve` +
        `defined, but background is not defined.`);
    }
    if (background && !contrastCurve) {
      throw new Error(
        `Color ${name} has background` +
        `defined, but contrastCurve is not defined.`);
    }
  }

  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(scheme: DynamicScheme): number {
    return this.getHct(scheme).toInt();
  }

  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(scheme: DynamicScheme): Hct {
    const cachedAnswer = this.hctCache.get(scheme);
    if (cachedAnswer != null) {
      return cachedAnswer;
    }
    const tone = this.getTone(scheme);
    const answer = this.palette(scheme).getHct(tone);
    if (this.hctCache.size > 4) {
      this.hctCache.clear();
    }
    this.hctCache.set(scheme, answer);
    return answer;
  }

  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(scheme: DynamicScheme): number {
    const decreasingContrast = scheme.contrastLevel < 0;

    // Case 1: dual foreground, pair of colors with delta constraint.
    if (this.toneDeltaPair) {
      const toneDeltaPair = this.toneDeltaPair(scheme);
      const roleA = toneDeltaPair.roleA;
      const roleB = toneDeltaPair.roleB;
      const delta = toneDeltaPair.delta;
      const polarity = toneDeltaPair.polarity;
      const stayTogether = toneDeltaPair.stayTogether;

      const bg = this.background!(scheme);
      const bgTone = bg.getTone(scheme);

      const aIsNearer =
        (polarity === 'nearer' ||
          (polarity === 'lighter' && !scheme.isDark) ||
          (polarity === 'darker' && scheme.isDark));
      const nearer = aIsNearer ? roleA : roleB;
      const farther = aIsNearer ? roleB : roleA;
      const amNearer = this.name === nearer.name;
      const expansionDir = scheme.isDark ? 1 : -1;

      // 1st round: solve to min, each
      const nContrast = nearer.contrastCurve!.get(scheme.contrastLevel);
      const fContrast = farther.contrastCurve!.get(scheme.contrastLevel);

      // If a color is good enough, it is not adjusted.
      // Initial and adjusted tones for `nearer`
      const nInitialTone = nearer.tone(scheme);
      let nTone = Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast ?
        nInitialTone :
        DynamicColor.foregroundTone(bgTone, nContrast);
      // Initial and adjusted tones for `farther`
      const fInitialTone = farther.tone(scheme);
      let fTone = Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast ?
        fInitialTone :
        DynamicColor.foregroundTone(bgTone, fContrast);

      if (decreasingContrast) {
        // If decreasing contrast, adjust color to the "bare minimum"
        // that satisfies contrast.
        nTone = DynamicColor.foregroundTone(bgTone, nContrast);
        fTone = DynamicColor.foregroundTone(bgTone, fContrast);
      }

      if ((fTone - nTone) * expansionDir >= delta) {
        // Good! Tones satisfy the constraint; no change needed.
      } else {
        // 2nd round: expand farther to match delta.
        fTone = math.clampDouble(0, 100, nTone + delta * expansionDir);
        if ((fTone - nTone) * expansionDir >= delta) {
          // Good! Tones now satisfy the constraint; no change needed.
        } else {
          // 3rd round: contract nearer to match delta.
          nTone = math.clampDouble(0, 100, fTone - delta * expansionDir);
        }
      }

      // Avoids the 50-59 awkward zone.
      if (50 <= nTone && nTone < 60) {
        // If `nearer` is in the awkward zone, move it away, together with
        // `farther`.
        if (expansionDir > 0) {
          nTone = 60;
          fTone = Math.max(fTone, nTone + delta * expansionDir);
        } else {
          nTone = 49;
          fTone = Math.min(fTone, nTone + delta * expansionDir);
        }
      } else if (50 <= fTone && fTone < 60) {
        if (stayTogether) {
          // Fixes both, to avoid two colors on opposite sides of the "awkward
          // zone".
          if (expansionDir > 0) {
            nTone = 60;
            fTone = Math.max(fTone, nTone + delta * expansionDir);
          } else {
            nTone = 49;
            fTone = Math.min(fTone, nTone + delta * expansionDir);
          }
        } else {
          // Not required to stay together; fixes just one.
          if (expansionDir > 0) {
            fTone = 60;
          } else {
            fTone = 49;
          }
        }
      }

      // Returns `nTone` if this color is `nearer`, otherwise `fTone`.
      return amNearer ? nTone : fTone;
    }

    else {
      // Case 2: No contrast pair; just solve for itself.
      let answer = this.tone(scheme);

      if (this.background == null) {
        return answer;  // No adjustment for colors with no background.
      }

      const bgTone = this.background(scheme).getTone(scheme);

      const desiredRatio = this.contrastCurve!.get(scheme.contrastLevel);

      if (Contrast.ratioOfTones(bgTone, answer) >= desiredRatio) {
        // Don't "improve" what's good enough.
      } else {
        // Rough improvement.
        answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
      }

      if (decreasingContrast) {
        answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
      }

      if (this.isBackground && 50 <= answer && answer < 60) {
        // Must adjust
        if (Contrast.ratioOfTones(49, bgTone) >= desiredRatio) {
          answer = 49;
        } else {
          answer = 60;
        }
      }

      if (this.secondBackground) {
        // Case 3: Adjust for dual backgrounds.

        const [bg1, bg2] = [this.background, this.secondBackground];
        const [bgTone1, bgTone2] =
          [bg1(scheme).getTone(scheme), bg2(scheme).getTone(scheme)];
        const [upper, lower] =
          [Math.max(bgTone1, bgTone2), Math.min(bgTone1, bgTone2)];

        if (Contrast.ratioOfTones(upper, answer) >= desiredRatio &&
          Contrast.ratioOfTones(lower, answer) >= desiredRatio) {
          return answer;
        }

        // The darkest light tone that satisfies the desired ratio,
        // or -1 if such ratio cannot be reached.
        const lightOption = Contrast.lighter(upper, desiredRatio);

        // The lightest dark tone that satisfies the desired ratio,
        // or -1 if such ratio cannot be reached.
        const darkOption = Contrast.darker(lower, desiredRatio);

        // Tones suitable for the foreground.
        const availables: number[] = [];
        if (lightOption !== -1) availables.push(lightOption);
        if (darkOption !== -1) availables.push(darkOption);

        const prefersLight = DynamicColor.tonePrefersLightForeground(bgTone1) ||
          DynamicColor.tonePrefersLightForeground(bgTone2);
        if (prefersLight) {
          return (lightOption < 0) ? 100 : lightOption;
        }
        if (availables.length === 1) {
          return availables[0];
        }
        return (darkOption < 0) ? 0 : darkOption;
      }

      return answer;
    }
  }

  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(bgTone: number, ratio: number): number {
    const lighterTone = Contrast.lighterUnsafe(bgTone, ratio);
    const darkerTone = Contrast.darkerUnsafe(bgTone, ratio);
    const lighterRatio = Contrast.ratioOfTones(lighterTone, bgTone);
    const darkerRatio = Contrast.ratioOfTones(darkerTone, bgTone);
    const preferLighter = DynamicColor.tonePrefersLightForeground(bgTone);

    if (preferLighter) {
      // This handles an edge case where the initial contrast ratio is high
      // (ex. 13.0), and the ratio passed to the function is that high
      // ratio, and both the lighter and darker ratio fails to pass that
      // ratio.
      //
      // This was observed with Tonal Spot's On Primary Container turning
      // black momentarily between high and max contrast in light mode. PC's
      // standard tone was T90, OPC's was T10, it was light mode, and the
      // contrast value was 0.6568521221032331.
      const negligibleDifference = Math.abs(lighterRatio - darkerRatio) < 0.1 &&
        lighterRatio < ratio && darkerRatio < ratio;
      return lighterRatio >= ratio || lighterRatio >= darkerRatio ||
        negligibleDifference ?
        lighterTone :
        darkerTone;
    } else {
      return darkerRatio >= ratio || darkerRatio >= lighterRatio ? darkerTone :
        lighterTone;
    }
  }

  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(tone: number): boolean {
    return Math.round(tone) < 60.0;
  }

  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(tone: number): boolean {
    return Math.round(tone) <= 49.0;
  }

  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(tone: number): number {
    if (DynamicColor.tonePrefersLightForeground(tone) &&
      !DynamicColor.toneAllowsLightForeground(tone)) {
      return 49.0;
    }
    return tone;
  }
}
// --- END FILE: dynamiccolor/dynamic_color.ts ---


// --- BEGIN FILE: dynamiccolor/dynamic_scheme.ts ---
/**
 * @param sourceColorArgb The source color of the theme as an ARGB 32-bit
 *     integer.
 * @param variant The variant, or style, of the theme.
 * @param contrastLevel Value from -1 to 1. -1 represents minimum contrast,
 * 0 represents standard (i.e. the design as spec'd), and 1 represents maximum
 * contrast.
 * @param isDark Whether the scheme is in dark mode or light mode.
 * @param primaryPalette Given a tone, produces a color. Hue and chroma of the
 * color are specified in the design specification of the variant. Usually
 * colorful.
 * @param secondaryPalette Given a tone, produces a color. Hue and chroma of
 * the color are specified in the design specification of the variant. Usually
 * less colorful.
 * @param tertiaryPalette Given a tone, produces a color. Hue and chroma of
 * the color are specified in the design specification of the variant. Usually
 * a different hue from primary and colorful.
 * @param neutralPalette Given a tone, produces a color. Hue and chroma of the
 * color are specified in the design specification of the variant. Usually not
 * colorful at all, intended for background & surface colors.
 * @param neutralVariantPalette Given a tone, produces a color. Hue and chroma
 * of the color are specified in the design specification of the variant.
 * Usually not colorful, but slightly more colorful than Neutral. Intended for
 * backgrounds & surfaces.
 */
export interface DynamicSchemeOptions {
  sourceColorHct: Hct;
  variant: Variant;
  contrastLevel: number;
  isDark: boolean;
  primaryPalette: TonalPalette;
  secondaryPalette: TonalPalette;
  tertiaryPalette: TonalPalette;
  neutralPalette: TonalPalette;
  neutralVariantPalette: TonalPalette;
  errorPalette?: TonalPalette;
}

/**
 * Constructed by a set of values representing the current UI state (such as
 * whether or not its dark theme, what the theme style is, etc.), and
 * provides a set of TonalPalettes that can create colors that fit in
 * with the theme style. Used by DynamicColor to resolve into a color.
 */
export class DynamicScheme {
  /**
   * The source color of the theme as an HCT color.
   */
  sourceColorHct: Hct;
  /**
   * Given a tone, produces a reddish, colorful, color.
   */
  errorPalette: TonalPalette;

  /** The source color of the theme as an ARGB 32-bit integer. */
  readonly sourceColorArgb: number;

  /** The variant, or style, of the theme. */
  readonly variant: Variant;

  /**
   * Value from -1 to 1. -1 represents minimum contrast. 0 represents standard
   * (i.e. the design as spec'd), and 1 represents maximum contrast.
   */
  readonly contrastLevel: number;

  /** Whether the scheme is in dark mode or light mode. */
  readonly isDark: boolean;

  /**
   * Given a tone, produces a color. Hue and chroma of the
   * color are specified in the design specification of the variant. Usually
   * colorful.
   */
  readonly primaryPalette: TonalPalette;

  /**
   * Given a tone, produces a color. Hue and chroma of
   * the color are specified in the design specification of the variant. Usually
   * less colorful.
   */
  readonly secondaryPalette: TonalPalette;

  /**
   * Given a tone, produces a color. Hue and chroma of
   * the color are specified in the design specification of the variant. Usually
   * a different hue from primary and colorful.
   */
  readonly tertiaryPalette: TonalPalette;

  /**
   * Given a tone, produces a color. Hue and chroma of the
   * color are specified in the design specification of the variant. Usually not
   * colorful at all, intended for background & surface colors.
   */
  readonly neutralPalette: TonalPalette;

  /**
   * Given a tone, produces a color. Hue and chroma
   * of the color are specified in the design specification of the variant.
   * Usually not colorful, but slightly more colorful than Neutral. Intended for
   * backgrounds & surfaces.
   */
  readonly neutralVariantPalette: TonalPalette;

  constructor(args: DynamicSchemeOptions) {
    this.sourceColorArgb = args.sourceColorHct.toInt();
    this.variant = args.variant;
    this.contrastLevel = args.contrastLevel;
    this.isDark = args.isDark;
    this.sourceColorHct = args.sourceColorHct;
    this.primaryPalette = args.primaryPalette;
    this.secondaryPalette = args.secondaryPalette;
    this.tertiaryPalette = args.tertiaryPalette;
    this.neutralPalette = args.neutralPalette;
    this.neutralVariantPalette = args.neutralVariantPalette;
    this.errorPalette =
      args.errorPalette ?? TonalPalette.fromHueAndChroma(25.0, 84.0);
  }

  /**
   * Support design spec'ing Dynamic Color by schemes that specify hue
   * rotations that should be applied at certain breakpoints.
   * @param sourceColor the source color of the theme, in HCT.
   * @param hues The "breakpoints", i.e. the hues at which a rotation should
   * be apply.
   * @param rotations The rotation that should be applied when source color's
   * hue is >= the same index in hues array, and <= the hue at the next index
   * in hues array.
   */
  static getRotatedHue(sourceColor: Hct, hues: number[], rotations: number[]):
    number {
    const sourceHue = sourceColor.hue;
    if (hues.length !== rotations.length) {
      throw new Error(`mismatch between hue length ${hues.length} & rotations ${rotations.length}`);
    }
    if (rotations.length === 1) {
      return math.sanitizeDegreesDouble(sourceColor.hue + rotations[0]);
    }
    const size = hues.length;
    for (let i = 0; i <= size - 2; i++) {
      const thisHue = hues[i];
      const nextHue = hues[i + 1];
      if (thisHue < sourceHue && sourceHue < nextHue) {
        return math.sanitizeDegreesDouble(sourceHue + rotations[i]);
      }
    }
    // If this statement executes, something is wrong, there should have been a
    // rotation found using the arrays.
    return sourceHue;
  }


  getArgb(dynamicColor: DynamicColor): number {
    return dynamicColor.getArgb(this);
  }

  getHct(dynamicColor: DynamicColor): Hct {
    return dynamicColor.getHct(this);
  }

  get primaryPaletteKeyColor(): number {
    return this.getArgb(MaterialDynamicColors.primaryPaletteKeyColor);
  }

  get secondaryPaletteKeyColor(): number {
    return this.getArgb(MaterialDynamicColors.secondaryPaletteKeyColor);
  }

  get tertiaryPaletteKeyColor(): number {
    return this.getArgb(MaterialDynamicColors.tertiaryPaletteKeyColor);
  }

  get neutralPaletteKeyColor(): number {
    return this.getArgb(MaterialDynamicColors.neutralPaletteKeyColor);
  }

  get neutralVariantPaletteKeyColor(): number {
    return this.getArgb(MaterialDynamicColors.neutralVariantPaletteKeyColor);
  }

  get background(): number {
    return this.getArgb(MaterialDynamicColors.background);
  }

  get onBackground(): number {
    return this.getArgb(MaterialDynamicColors.onBackground);
  }

  get surface(): number {
    return this.getArgb(MaterialDynamicColors.surface);
  }

  get surfaceDim(): number {
    return this.getArgb(MaterialDynamicColors.surfaceDim);
  }

  get surfaceBright(): number {
    return this.getArgb(MaterialDynamicColors.surfaceBright);
  }

  get surfaceContainerLowest(): number {
    return this.getArgb(MaterialDynamicColors.surfaceContainerLowest);
  }

  get surfaceContainerLow(): number {
    return this.getArgb(MaterialDynamicColors.surfaceContainerLow);
  }

  get surfaceContainer(): number {
    return this.getArgb(MaterialDynamicColors.surfaceContainer);
  }

  get surfaceContainerHigh(): number {
    return this.getArgb(MaterialDynamicColors.surfaceContainerHigh);
  }

  get surfaceContainerHighest(): number {
    return this.getArgb(MaterialDynamicColors.surfaceContainerHighest);
  }

  get onSurface(): number {
    return this.getArgb(MaterialDynamicColors.onSurface);
  }

  get surfaceVariant(): number {
    return this.getArgb(MaterialDynamicColors.surfaceVariant);
  }

  get onSurfaceVariant(): number {
    return this.getArgb(MaterialDynamicColors.onSurfaceVariant);
  }

  get inverseSurface(): number {
    return this.getArgb(MaterialDynamicColors.inverseSurface);
  }

  get inverseOnSurface(): number {
    return this.getArgb(MaterialDynamicColors.inverseOnSurface);
  }

  get outline(): number {
    return this.getArgb(MaterialDynamicColors.outline);
  }

  get outlineVariant(): number {
    return this.getArgb(MaterialDynamicColors.outlineVariant);
  }

  get shadow(): number {
    return this.getArgb(MaterialDynamicColors.shadow);
  }

  get scrim(): number {
    return this.getArgb(MaterialDynamicColors.scrim);
  }

  get surfaceTint(): number {
    return this.getArgb(MaterialDynamicColors.surfaceTint);
  }

  get primary(): number {
    return this.getArgb(MaterialDynamicColors.primary);
  }

  get onPrimary(): number {
    return this.getArgb(MaterialDynamicColors.onPrimary);
  }

  get primaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.primaryContainer);
  }

  get onPrimaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.onPrimaryContainer);
  }

  get inversePrimary(): number {
    return this.getArgb(MaterialDynamicColors.inversePrimary);
  }

  get secondary(): number {
    return this.getArgb(MaterialDynamicColors.secondary);
  }

  get onSecondary(): number {
    return this.getArgb(MaterialDynamicColors.onSecondary);
  }

  get secondaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.secondaryContainer);
  }

  get onSecondaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.onSecondaryContainer);
  }

  get tertiary(): number {
    return this.getArgb(MaterialDynamicColors.tertiary);
  }

  get onTertiary(): number {
    return this.getArgb(MaterialDynamicColors.onTertiary);
  }

  get tertiaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.tertiaryContainer);
  }

  get onTertiaryContainer(): number {
    return this.getArgb(MaterialDynamicColors.onTertiaryContainer);
  }

  get error(): number {
    return this.getArgb(MaterialDynamicColors.error);
  }

  get onError(): number {
    return this.getArgb(MaterialDynamicColors.onError);
  }

  get errorContainer(): number {
    return this.getArgb(MaterialDynamicColors.errorContainer);
  }

  get onErrorContainer(): number {
    return this.getArgb(MaterialDynamicColors.onErrorContainer);
  }

  get primaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.primaryFixed);
  }

  get primaryFixedDim(): number {
    return this.getArgb(MaterialDynamicColors.primaryFixedDim);
  }

  get onPrimaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.onPrimaryFixed);
  }

  get onPrimaryFixedVariant(): number {
    return this.getArgb(MaterialDynamicColors.onPrimaryFixedVariant);
  }

  get secondaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.secondaryFixed);
  }

  get secondaryFixedDim(): number {
    return this.getArgb(MaterialDynamicColors.secondaryFixedDim);
  }

  get onSecondaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.onSecondaryFixed);
  }

  get onSecondaryFixedVariant(): number {
    return this.getArgb(MaterialDynamicColors.onSecondaryFixedVariant);
  }

  get tertiaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.tertiaryFixed);
  }

  get tertiaryFixedDim(): number {
    return this.getArgb(MaterialDynamicColors.tertiaryFixedDim);
  }

  get onTertiaryFixed(): number {
    return this.getArgb(MaterialDynamicColors.onTertiaryFixed);
  }

  get onTertiaryFixedVariant(): number {
    return this.getArgb(MaterialDynamicColors.onTertiaryFixedVariant);
  }
}
// --- END FILE: dynamiccolor/dynamic_scheme.ts ---


// --- BEGIN FILE: dynamiccolor/material_dynamic_colors.ts ---
function isFidelity(scheme: DynamicScheme): boolean {
  return scheme.variant === Variant.FIDELITY ||
    scheme.variant === Variant.CONTENT;
}

function isMonochrome(scheme: DynamicScheme): boolean {
  return scheme.variant === Variant.MONOCHROME;
}

function findDesiredChromaByTone(
  hue: number, chroma: number, tone: number,
  byDecreasingTone: boolean): number {
  let answer = tone;

  let closestToChroma = Hct.from(hue, chroma, tone);
  if (closestToChroma.chroma < chroma) {
    let chromaPeak = closestToChroma.chroma;
    while (closestToChroma.chroma < chroma) {
      answer += byDecreasingTone ? -1.0 : 1.0;
      const potentialSolution = Hct.from(hue, chroma, answer);
      if (chromaPeak > potentialSolution.chroma) {
        break;
      }
      if (Math.abs(potentialSolution.chroma - chroma) < 0.4) {
        break;
      }

      const potentialDelta = Math.abs(potentialSolution.chroma - chroma);
      const currentDelta = Math.abs(closestToChroma.chroma - chroma);
      if (potentialDelta < currentDelta) {
        closestToChroma = potentialSolution;
      }
      chromaPeak = Math.max(chromaPeak, potentialSolution.chroma);
    }
  }

  return answer;
}

/**
 * DynamicColors for the colors in the Material Design system.
 */
// Material Color Utilities namespaces the various utilities it provides.
// tslint:disable-next-line:class-as-namespace
export class MaterialDynamicColors {
  static contentAccentToneDelta = 15.0;
  static highestSurface(s: DynamicScheme): DynamicColor {
    return s.isDark ? MaterialDynamicColors.surfaceBright :
      MaterialDynamicColors.surfaceDim;
  }

  static primaryPaletteKeyColor = DynamicColor.fromPalette({
    name: 'primary_palette_key_color',
    palette: (s) => s.primaryPalette,
    tone: (s) => s.primaryPalette.keyColor.tone,
  });

  static secondaryPaletteKeyColor = DynamicColor.fromPalette({
    name: 'secondary_palette_key_color',
    palette: (s) => s.secondaryPalette,
    tone: (s) => s.secondaryPalette.keyColor.tone,
  });

  static tertiaryPaletteKeyColor = DynamicColor.fromPalette({
    name: 'tertiary_palette_key_color',
    palette: (s) => s.tertiaryPalette,
    tone: (s) => s.tertiaryPalette.keyColor.tone,
  });

  static neutralPaletteKeyColor = DynamicColor.fromPalette({
    name: 'neutral_palette_key_color',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.neutralPalette.keyColor.tone,
  });

  static neutralVariantPaletteKeyColor = DynamicColor.fromPalette({
    name: 'neutral_variant_palette_key_color',
    palette: (s) => s.neutralVariantPalette,
    tone: (s) => s.neutralVariantPalette.keyColor.tone,
  });

  static background = DynamicColor.fromPalette({
    name: 'background',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 6 : 98,
    isBackground: true,
  });

  static onBackground = DynamicColor.fromPalette({
    name: 'on_background',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 90 : 10,
    background: (s) => MaterialDynamicColors.background,
    contrastCurve: new ContrastCurve(3, 3, 4.5, 7),
  });

  static surface = DynamicColor.fromPalette({
    name: 'surface',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 6 : 98,
    isBackground: true,
  });

  static surfaceDim = DynamicColor.fromPalette({
    name: 'surface_dim',
    palette: (s) => s.neutralPalette,
    tone: (s) =>
      s.isDark ? 6 : new ContrastCurve(87, 87, 80, 75).get(s.contrastLevel),
    isBackground: true,
  });

  static surfaceBright = DynamicColor.fromPalette({
    name: 'surface_bright',
    palette: (s) => s.neutralPalette,
    tone: (s) =>
      s.isDark ? new ContrastCurve(24, 24, 29, 34).get(s.contrastLevel) : 98,
    isBackground: true,
  });

  static surfaceContainerLowest = DynamicColor.fromPalette({
    name: 'surface_container_lowest',
    palette: (s) => s.neutralPalette,
    tone: (s) =>
      s.isDark ? new ContrastCurve(4, 4, 2, 0).get(s.contrastLevel) : 100,
    isBackground: true,
  });

  static surfaceContainerLow = DynamicColor.fromPalette({
    name: 'surface_container_low',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ?
      new ContrastCurve(10, 10, 11, 12).get(s.contrastLevel) :
      new ContrastCurve(96, 96, 96, 95).get(s.contrastLevel),
    isBackground: true,
  });

  static surfaceContainer = DynamicColor.fromPalette({
    name: 'surface_container',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ?
      new ContrastCurve(12, 12, 16, 20).get(s.contrastLevel) :
      new ContrastCurve(94, 94, 92, 90).get(s.contrastLevel),
    isBackground: true,
  });

  static surfaceContainerHigh = DynamicColor.fromPalette({
    name: 'surface_container_high',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ?
      new ContrastCurve(17, 17, 21, 25).get(s.contrastLevel) :
      new ContrastCurve(92, 92, 88, 85).get(s.contrastLevel),
    isBackground: true,
  });

  static surfaceContainerHighest = DynamicColor.fromPalette({
    name: 'surface_container_highest',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ?
      new ContrastCurve(22, 22, 26, 30).get(s.contrastLevel) :
      new ContrastCurve(90, 90, 84, 80).get(s.contrastLevel),
    isBackground: true,
  });

  static onSurface = DynamicColor.fromPalette({
    name: 'on_surface',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 90 : 10,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static surfaceVariant = DynamicColor.fromPalette({
    name: 'surface_variant',
    palette: (s) => s.neutralVariantPalette,
    tone: (s) => s.isDark ? 30 : 90,
    isBackground: true,
  });

  static onSurfaceVariant = DynamicColor.fromPalette({
    name: 'on_surface_variant',
    palette: (s) => s.neutralVariantPalette,
    tone: (s) => s.isDark ? 80 : 30,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static inverseSurface = DynamicColor.fromPalette({
    name: 'inverse_surface',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 90 : 20,
  });

  static inverseOnSurface = DynamicColor.fromPalette({
    name: 'inverse_on_surface',
    palette: (s) => s.neutralPalette,
    tone: (s) => s.isDark ? 20 : 95,
    background: (s) => MaterialDynamicColors.inverseSurface,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static outline = DynamicColor.fromPalette({
    name: 'outline',
    palette: (s) => s.neutralVariantPalette,
    tone: (s) => s.isDark ? 60 : 50,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1.5, 3, 4.5, 7),
  });

  static outlineVariant = DynamicColor.fromPalette({
    name: 'outline_variant',
    palette: (s) => s.neutralVariantPalette,
    tone: (s) => s.isDark ? 30 : 80,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
  });

  static shadow = DynamicColor.fromPalette({
    name: 'shadow',
    palette: (s) => s.neutralPalette,
    tone: (s) => 0,
  });

  static scrim = DynamicColor.fromPalette({
    name: 'scrim',
    palette: (s) => s.neutralPalette,
    tone: (s) => 0,
  });

  static surfaceTint = DynamicColor.fromPalette({
    name: 'surface_tint',
    palette: (s) => s.primaryPalette,
    tone: (s) => s.isDark ? 80 : 40,
    isBackground: true,
  });

  static primary = DynamicColor.fromPalette({
    name: 'primary',
    palette: (s) => s.primaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 100 : 0;
        }
        return s.isDark ? 80 : 40;
      },
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(3, 4.5, 7, 7),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary,
      10, 'nearer', false),
  });

  static onPrimary = DynamicColor.fromPalette({
    name: 'on_primary',
    palette: (s) => s.primaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 10 : 90;
        }
        return s.isDark ? 20 : 100;
      },
    background: (s) => MaterialDynamicColors.primary,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static primaryContainer = DynamicColor.fromPalette({
    name: 'primary_container',
    palette: (s) => s.primaryPalette,
    tone:
      (s) => {
        if (isFidelity(s)) {
          return s.sourceColorHct.tone;
        }
        if (isMonochrome(s)) {
          return s.isDark ? 85 : 25;
        }
        return s.isDark ? 30 : 90;
      },
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary,
      10, 'nearer', false),
  });

  static onPrimaryContainer = DynamicColor.fromPalette({
    name: 'on_primary_container',
    palette: (s) => s.primaryPalette,
    tone:
      (s) => {
        if (isFidelity(s)) {
          return DynamicColor.foregroundTone(
            MaterialDynamicColors.primaryContainer.tone(s), 4.5);
        }
        if (isMonochrome(s)) {
          return s.isDark ? 0 : 100;
        }
        return s.isDark ? 90 : 30;
      },
    background: (s) => MaterialDynamicColors.primaryContainer,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static inversePrimary = DynamicColor.fromPalette({
    name: 'inverse_primary',
    palette: (s) => s.primaryPalette,
    tone: (s) => s.isDark ? 40 : 80,
    background: (s) => MaterialDynamicColors.inverseSurface,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 7),
  });

  static secondary = DynamicColor.fromPalette({
    name: 'secondary',
    palette: (s) => s.secondaryPalette,
    tone: (s) => s.isDark ? 80 : 40,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(3, 4.5, 7, 7),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.secondaryContainer,
      MaterialDynamicColors.secondary, 10, 'nearer', false),
  });

  static onSecondary = DynamicColor.fromPalette({
    name: 'on_secondary',
    palette: (s) => s.secondaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 10 : 100;
        } else {
          return s.isDark ? 20 : 100;
        }
      },
    background: (s) => MaterialDynamicColors.secondary,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static secondaryContainer = DynamicColor.fromPalette({
    name: 'secondary_container',
    palette: (s) => s.secondaryPalette,
    tone:
      (s) => {
        const initialTone = s.isDark ? 30 : 90;
        if (isMonochrome(s)) {
          return s.isDark ? 30 : 85;
        }
        if (!isFidelity(s)) {
          return initialTone;
        }
        return findDesiredChromaByTone(
          s.secondaryPalette.hue, s.secondaryPalette.chroma, initialTone,
          s.isDark ? false : true);
      },
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.secondaryContainer,
      MaterialDynamicColors.secondary, 10, 'nearer', false),
  });

  static onSecondaryContainer = DynamicColor.fromPalette({
    name: 'on_secondary_container',
    palette: (s) => s.secondaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 90 : 10;
        }
        if (!isFidelity(s)) {
          return s.isDark ? 90 : 30;
        }
        return DynamicColor.foregroundTone(
          MaterialDynamicColors.secondaryContainer.tone(s), 4.5);
      },
    background: (s) => MaterialDynamicColors.secondaryContainer,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static tertiary = DynamicColor.fromPalette({
    name: 'tertiary',
    palette: (s) => s.tertiaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 90 : 25;
        }
        return s.isDark ? 80 : 40;
      },
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(3, 4.5, 7, 7),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary,
      10, 'nearer', false),
  });

  static onTertiary = DynamicColor.fromPalette({
    name: 'on_tertiary',
    palette: (s) => s.tertiaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 10 : 90;
        }
        return s.isDark ? 20 : 100;
      },
    background: (s) => MaterialDynamicColors.tertiary,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static tertiaryContainer = DynamicColor.fromPalette({
    name: 'tertiary_container',
    palette: (s) => s.tertiaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 60 : 49;
        }
        if (!isFidelity(s)) {
          return s.isDark ? 30 : 90;
        }
        const proposedHct = s.tertiaryPalette.getHct(s.sourceColorHct.tone);
        return DislikeAnalyzer.fixIfDisliked(proposedHct).tone;
      },
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary,
      10, 'nearer', false),
  });

  static onTertiaryContainer = DynamicColor.fromPalette({
    name: 'on_tertiary_container',
    palette: (s) => s.tertiaryPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 0 : 100;
        }
        if (!isFidelity(s)) {
          return s.isDark ? 90 : 30;
        }
        return DynamicColor.foregroundTone(
          MaterialDynamicColors.tertiaryContainer.tone(s), 4.5);
      },
    background: (s) => MaterialDynamicColors.tertiaryContainer,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static error = DynamicColor.fromPalette({
    name: 'error',
    palette: (s) => s.errorPalette,
    tone: (s) => s.isDark ? 80 : 40,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(3, 4.5, 7, 7),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 10,
      'nearer', false),
  });

  static onError = DynamicColor.fromPalette({
    name: 'on_error',
    palette: (s) => s.errorPalette,
    tone: (s) => s.isDark ? 20 : 100,
    background: (s) => MaterialDynamicColors.error,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static errorContainer = DynamicColor.fromPalette({
    name: 'error_container',
    palette: (s) => s.errorPalette,
    tone: (s) => s.isDark ? 30 : 90,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 10,
      'nearer', false),
  });

  static onErrorContainer = DynamicColor.fromPalette({
    name: 'on_error_container',
    palette: (s) => s.errorPalette,
    tone:
      (s) => {
        if (isMonochrome(s)) {
          return s.isDark ? 90 : 10;
        }
        return s.isDark ? 90 : 30;
      },
    background: (s) => MaterialDynamicColors.errorContainer,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static primaryFixed = DynamicColor.fromPalette({
    name: 'primary_fixed',
    palette: (s) => s.primaryPalette,
    tone: (s) => isMonochrome(s) ? 40.0 : 90.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.primaryFixed,
      MaterialDynamicColors.primaryFixedDim, 10, 'lighter', true),
  });

  static primaryFixedDim = DynamicColor.fromPalette({
    name: 'primary_fixed_dim',
    palette: (s) => s.primaryPalette,
    tone: (s) => isMonochrome(s) ? 30.0 : 80.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.primaryFixed,
      MaterialDynamicColors.primaryFixedDim, 10, 'lighter', true),
  });

  static onPrimaryFixed = DynamicColor.fromPalette({
    name: 'on_primary_fixed',
    palette: (s) => s.primaryPalette,
    tone: (s) => isMonochrome(s) ? 100.0 : 10.0,
    background: (s) => MaterialDynamicColors.primaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.primaryFixed,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static onPrimaryFixedVariant = DynamicColor.fromPalette({
    name: 'on_primary_fixed_variant',
    palette: (s) => s.primaryPalette,
    tone: (s) => isMonochrome(s) ? 90.0 : 30.0,
    background: (s) => MaterialDynamicColors.primaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.primaryFixed,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static secondaryFixed = DynamicColor.fromPalette({
    name: 'secondary_fixed',
    palette: (s) => s.secondaryPalette,
    tone: (s) => isMonochrome(s) ? 80.0 : 90.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.secondaryFixed,
      MaterialDynamicColors.secondaryFixedDim, 10, 'lighter', true),
  });

  static secondaryFixedDim = DynamicColor.fromPalette({
    name: 'secondary_fixed_dim',
    palette: (s) => s.secondaryPalette,
    tone: (s) => isMonochrome(s) ? 70.0 : 80.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.secondaryFixed,
      MaterialDynamicColors.secondaryFixedDim, 10, 'lighter', true),
  });

  static onSecondaryFixed = DynamicColor.fromPalette({
    name: 'on_secondary_fixed',
    palette: (s) => s.secondaryPalette,
    tone: (s) => 10.0,
    background: (s) => MaterialDynamicColors.secondaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static onSecondaryFixedVariant = DynamicColor.fromPalette({
    name: 'on_secondary_fixed_variant',
    palette: (s) => s.secondaryPalette,
    tone: (s) => isMonochrome(s) ? 25.0 : 30.0,
    background: (s) => MaterialDynamicColors.secondaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });

  static tertiaryFixed = DynamicColor.fromPalette({
    name: 'tertiary_fixed',
    palette: (s) => s.tertiaryPalette,
    tone: (s) => isMonochrome(s) ? 40.0 : 90.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.tertiaryFixed,
      MaterialDynamicColors.tertiaryFixedDim, 10, 'lighter', true),
  });

  static tertiaryFixedDim = DynamicColor.fromPalette({
    name: 'tertiary_fixed_dim',
    palette: (s) => s.tertiaryPalette,
    tone: (s) => isMonochrome(s) ? 30.0 : 80.0,
    isBackground: true,
    background: (s) => MaterialDynamicColors.highestSurface(s),
    contrastCurve: new ContrastCurve(1, 1, 3, 4.5),
    toneDeltaPair: (s) => new ToneDeltaPair(
      MaterialDynamicColors.tertiaryFixed,
      MaterialDynamicColors.tertiaryFixedDim, 10, 'lighter', true),
  });

  static onTertiaryFixed = DynamicColor.fromPalette({
    name: 'on_tertiary_fixed',
    palette: (s) => s.tertiaryPalette,
    tone: (s) => isMonochrome(s) ? 100.0 : 10.0,
    background: (s) => MaterialDynamicColors.tertiaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
    contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
  });

  static onTertiaryFixedVariant = DynamicColor.fromPalette({
    name: 'on_tertiary_fixed_variant',
    palette: (s) => s.tertiaryPalette,
    tone: (s) => isMonochrome(s) ? 90.0 : 30.0,
    background: (s) => MaterialDynamicColors.tertiaryFixedDim,
    secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
    contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  });
}
// --- END FILE: dynamiccolor/material_dynamic_colors.ts ---


// --- BEGIN FILE: dynamiccolor/tone_delta_pair.ts ---
/**
 * Describes the different in tone between colors.
 */
type TonePolarity = 'darker' | 'lighter' | 'nearer' | 'farther';

/**
 * Documents a constraint between two DynamicColors, in which their tones must
 * have a certain distance from each other.
 *
 * Prefer a DynamicColor with a background, this is for special cases when
 * designers want tonal distance, literally contrast, between two colors that
 * don't have a background / foreground relationship or a contrast guarantee.
 */
export class ToneDeltaPair {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(
    readonly roleA: DynamicColor,
    readonly roleB: DynamicColor,
    readonly delta: number,
    readonly polarity: TonePolarity,
    readonly stayTogether: boolean,
  ) { }
}
// --- END FILE: dynamiccolor/tone_delta_pair.ts ---


// --- BEGIN FILE: dynamiccolor/variant.ts ---
/**
 * Set of themes supported by Dynamic Color.
 * Instantiate the corresponding subclass, ex. SchemeTonalSpot, to create
 * colors corresponding to the theme.
 */
enum Variant {
  MONOCHROME,
  NEUTRAL,
  TONAL_SPOT,
  VIBRANT,
  EXPRESSIVE,
  FIDELITY,
  CONTENT,
  RAINBOW,
  FRUIT_SALAD
}
// --- END FILE: dynamiccolor/variant.ts ---


// --- BEGIN FILE: hct/cam16.ts ---
/**
 * CAM16, a color appearance model. Colors are not just defined by their hex
 * code, but rather, a hex code and viewing conditions.
 *
 * CAM16 instances also have coordinates in the CAM16-UCS space, called J*, a*,
 * b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
 * specification, and should be used when measuring distances between colors.
 *
 * In traditional color spaces, a color can be identified solely by the
 * observer's measurement of the color. Color appearance models such as CAM16
 * also use information about the environment where the color was
 * observed, known as the viewing conditions.
 *
 * For example, white under the traditional assumption of a midday sun white
 * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
 * hue 203, chroma 3, lightness 100)
 */
export class Cam16 {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(
    readonly hue: number, readonly chroma: number, readonly j: number,
    readonly q: number, readonly m: number, readonly s: number,
    readonly jstar: number, readonly astar: number, readonly bstar: number) { }

  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(other: Cam16): number {
    const dJ = this.jstar - other.jstar;
    const dA = this.astar - other.astar;
    const dB = this.bstar - other.bstar;
    const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
    const dE = 1.41 * Math.pow(dEPrime, 0.63);
    return dE;
  }

  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(argb: number): Cam16 {
    return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
  }

  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(
    argb: number, viewingConditions: ViewingConditions): Cam16 {
    const red = (argb & 0x00ff0000) >> 16;
    const green = (argb & 0x0000ff00) >> 8;
    const blue = (argb & 0x000000ff);
    const redL = utils.linearized(red);
    const greenL = utils.linearized(green);
    const blueL = utils.linearized(blue);
    const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
    const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
    const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;

    const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
    const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
    const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;

    const rD = viewingConditions.rgbD[0] * rC;
    const gD = viewingConditions.rgbD[1] * gC;
    const bD = viewingConditions.rgbD[2] * bC;

    const rAF = Math.pow((viewingConditions.fl * Math.abs(rD)) / 100.0, 0.42);
    const gAF = Math.pow((viewingConditions.fl * Math.abs(gD)) / 100.0, 0.42);
    const bAF = Math.pow((viewingConditions.fl * Math.abs(bD)) / 100.0, 0.42);

    const rA = (math.signum(rD) * 400.0 * rAF) / (rAF + 27.13);
    const gA = (math.signum(gD) * 400.0 * gAF) / (gAF + 27.13);
    const bA = (math.signum(bD) * 400.0 * bAF) / (bAF + 27.13);

    const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
    const b = (rA + gA - 2.0 * bA) / 9.0;
    const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
    const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;
    const atan2 = Math.atan2(b, a);
    const atanDegrees = (atan2 * 180.0) / Math.PI;
    const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
      atanDegrees >= 360 ? atanDegrees - 360.0 :
        atanDegrees;
    const hueRadians = (hue * Math.PI) / 180.0;

    const ac = p2 * viewingConditions.nbb;
    const j = 100.0 *
      Math.pow(
        ac / viewingConditions.aw,
        viewingConditions.c * viewingConditions.z);
    const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
      (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
    const huePrime = hue < 20.14 ? hue + 360 : hue;
    const eHue = 0.25 * (Math.cos((huePrime * Math.PI) / 180.0 + 2.0) + 3.8);
    const p1 =
      (50000.0 / 13.0) * eHue * viewingConditions.nc * viewingConditions.ncb;
    const t = (p1 * Math.sqrt(a * a + b * b)) / (u + 0.305);
    const alpha = Math.pow(t, 0.9) *
      Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
    const c = alpha * Math.sqrt(j / 100.0);
    const m = c * viewingConditions.fLRoot;
    const s = 50.0 *
      Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
    const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
    const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
    const astar = mstar * Math.cos(hueRadians);
    const bstar = mstar * Math.sin(hueRadians);

    return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
  }

  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(j: number, c: number, h: number): Cam16 {
    return Cam16.fromJchInViewingConditions(j, c, h, ViewingConditions.DEFAULT);
  }

  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(
    j: number, c: number, h: number,
    viewingConditions: ViewingConditions): Cam16 {
    const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
      (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
    const m = c * viewingConditions.fLRoot;
    const alpha = c / Math.sqrt(j / 100.0);
    const s = 50.0 *
      Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
    const hueRadians = (h * Math.PI) / 180.0;
    const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
    const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
    const astar = mstar * Math.cos(hueRadians);
    const bstar = mstar * Math.sin(hueRadians);
    return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
  }

  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(jstar: number, astar: number, bstar: number): Cam16 {
    return Cam16.fromUcsInViewingConditions(
      jstar, astar, bstar, ViewingConditions.DEFAULT);
  }

  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(
    jstar: number, astar: number, bstar: number,
    viewingConditions: ViewingConditions): Cam16 {
    const a = astar;
    const b = bstar;
    const m = Math.sqrt(a * a + b * b);
    const M = (Math.exp(m * 0.0228) - 1.0) / 0.0228;
    const c = M / viewingConditions.fLRoot;
    let h = Math.atan2(b, a) * (180.0 / Math.PI);
    if (h < 0.0) {
      h += 360.0;
    }
    const j = jstar / (1 - (jstar - 100) * 0.007);
    return Cam16.fromJchInViewingConditions(j, c, h, viewingConditions);
  }

  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt(): number {
    return this.viewed(ViewingConditions.DEFAULT);
  }

  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(viewingConditions: ViewingConditions): number {
    const alpha = this.chroma === 0.0 || this.j === 0.0 ?
      0.0 :
      this.chroma / Math.sqrt(this.j / 100.0);

    const t = Math.pow(
      alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73),
      1.0 / 0.9);
    const hRad = (this.hue * Math.PI) / 180.0;

    const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
    const ac = viewingConditions.aw *
      Math.pow(
        this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
    const p1 =
      eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
    const p2 = ac / viewingConditions.nbb;

    const hSin = Math.sin(hRad);
    const hCos = Math.cos(hRad);

    const gamma = (23.0 * (p2 + 0.305) * t) /
      (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin);
    const a = gamma * hCos;
    const b = gamma * hSin;
    const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
    const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
    const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;

    const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
    const rC = math.signum(rA) * (100.0 / viewingConditions.fl) *
      Math.pow(rCBase, 1.0 / 0.42);
    const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
    const gC = math.signum(gA) * (100.0 / viewingConditions.fl) *
      Math.pow(gCBase, 1.0 / 0.42);
    const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
    const bC = math.signum(bA) * (100.0 / viewingConditions.fl) *
      Math.pow(bCBase, 1.0 / 0.42);
    const rF = rC / viewingConditions.rgbD[0];
    const gF = gC / viewingConditions.rgbD[1];
    const bF = bC / viewingConditions.rgbD[2];

    const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
    const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
    const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;

    const argb = utils.argbFromXyz(x, y, z);
    return argb;
  }

  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(
    x: number, y: number, z: number,
    viewingConditions: ViewingConditions): Cam16 {
    // Transform XYZ to 'cone'/'rgb' responses

    const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
    const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
    const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;

    // Discount illuminant
    const rD = viewingConditions.rgbD[0] * rC;
    const gD = viewingConditions.rgbD[1] * gC;
    const bD = viewingConditions.rgbD[2] * bC;

    // chromatic adaptation
    const rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100.0, 0.42);
    const gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100.0, 0.42);
    const bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100.0, 0.42);
    const rA = math.signum(rD) * 400.0 * rAF / (rAF + 27.13);
    const gA = math.signum(gD) * 400.0 * gAF / (gAF + 27.13);
    const bA = math.signum(bD) * 400.0 * bAF / (bAF + 27.13);

    // redness-greenness
    const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
    // yellowness-blueness
    const b = (rA + gA - 2.0 * bA) / 9.0;

    // auxiliary components
    const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
    const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;

    // hue
    const atan2 = Math.atan2(b, a);
    const atanDegrees = atan2 * 180.0 / Math.PI;
    const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
      atanDegrees >= 360 ? atanDegrees - 360 :
        atanDegrees;
    const hueRadians = hue * Math.PI / 180.0;

    // achromatic response to color
    const ac = p2 * viewingConditions.nbb;

    // CAM16 lightness and brightness
    const J = 100.0 *
      Math.pow(
        ac / viewingConditions.aw,
        viewingConditions.c * viewingConditions.z);
    const Q = (4.0 / viewingConditions.c) * Math.sqrt(J / 100.0) *
      (viewingConditions.aw + 4.0) * (viewingConditions.fLRoot);

    const huePrime = (hue < 20.14) ? hue + 360 : hue;
    const eHue =
      (1.0 / 4.0) * (Math.cos(huePrime * Math.PI / 180.0 + 2.0) + 3.8);
    const p1 =
      50000.0 / 13.0 * eHue * viewingConditions.nc * viewingConditions.ncb;
    const t = p1 * Math.sqrt(a * a + b * b) / (u + 0.305);
    const alpha = Math.pow(t, 0.9) *
      Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
    // CAM16 chroma, colorfulness, chroma
    const C = alpha * Math.sqrt(J / 100.0);
    const M = C * viewingConditions.fLRoot;
    const s = 50.0 *
      Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));

    // CAM16-UCS components
    const jstar = (1.0 + 100.0 * 0.007) * J / (1.0 + 0.007 * J);
    const mstar = Math.log(1.0 + 0.0228 * M) / 0.0228;
    const astar = mstar * Math.cos(hueRadians);
    const bstar = mstar * Math.sin(hueRadians);
    return new Cam16(hue, C, J, Q, M, s, jstar, astar, bstar);
  }

  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(viewingConditions: ViewingConditions): number[] {
    const alpha = (this.chroma === 0.0 || this.j === 0.0) ?
      0.0 :
      this.chroma / Math.sqrt(this.j / 100.0);

    const t = Math.pow(
      alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73),
      1.0 / 0.9);
    const hRad = this.hue * Math.PI / 180.0;

    const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
    const ac = viewingConditions.aw *
      Math.pow(
        this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
    const p1 =
      eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;

    const p2 = (ac / viewingConditions.nbb);

    const hSin = Math.sin(hRad);
    const hCos = Math.cos(hRad);

    const gamma = 23.0 * (p2 + 0.305) * t /
      (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
    const a = gamma * hCos;
    const b = gamma * hSin;
    const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
    const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
    const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;

    const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
    const rC = math.signum(rA) * (100.0 / viewingConditions.fl) *
      Math.pow(rCBase, 1.0 / 0.42);
    const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
    const gC = math.signum(gA) * (100.0 / viewingConditions.fl) *
      Math.pow(gCBase, 1.0 / 0.42);
    const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
    const bC = math.signum(bA) * (100.0 / viewingConditions.fl) *
      Math.pow(bCBase, 1.0 / 0.42);
    const rF = rC / viewingConditions.rgbD[0];
    const gF = gC / viewingConditions.rgbD[1];
    const bF = bC / viewingConditions.rgbD[2];

    const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
    const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
    const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;

    return [x, y, z];
  }
}
// --- END FILE: hct/cam16.ts ---


// --- BEGIN FILE: hct/hct.ts ---
/**
 * A color system built using CAM16 hue and chroma, and L* from
 * L*a*b*.
 *
 * Using L* creates a link between the color system, contrast, and thus
 * accessibility. Contrast ratio depends on relative luminance, or Y in the XYZ
 * color space. L*, or perceptual luminance can be calculated from Y.
 *
 * Unlike Y, L* is linear to human perception, allowing trivial creation of
 * accurate color tones.
 *
 * Unlike contrast ratio, measuring contrast in L* is linear, and simple to
 * calculate. A difference of 40 in HCT tone guarantees a contrast ratio >= 3.0,
 * and a difference of 50 guarantees a contrast ratio >= 4.5.
 */



/**
 * HCT, hue, chroma, and tone. A color system that provides a perceptually
 * accurate color measurement system that can also accurately render what colors
 * will appear as in different lighting environments.
 */
export class Hct {
  /**
   * @param hue 0 <= hue < 360; invalid values are corrected.
   * @param chroma 0 <= chroma < ?; Informally, colorfulness. The color
   *     returned may be lower than the requested chroma. Chroma has a different
   *     maximum for any given hue and tone.
   * @param tone 0 <= tone <= 100; invalid values are corrected.
   * @return HCT representation of a color in default viewing conditions.
   */

  internalHue: number;
  internalChroma: number;
  internalTone: number;

  static from(hue: number, chroma: number, tone: number) {
    return new Hct(HctSolver.solveToInt(hue, chroma, tone));
  }

  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(argb: number) {
    return new Hct(argb);
  }

  toInt(): number {
    return this.argb;
  }

  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue(): number {
    return this.internalHue;
  }

  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(newHue: number) {
    this.setInternalState(
      HctSolver.solveToInt(
        newHue,
        this.internalChroma,
        this.internalTone,
      ),
    );
  }

  get chroma(): number {
    return this.internalChroma;
  }

  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(newChroma: number) {
    this.setInternalState(
      HctSolver.solveToInt(
        this.internalHue,
        newChroma,
        this.internalTone,
      ),
    );
  }

  /** Lightness. Ranges from 0 to 100. */
  get tone(): number {
    return this.internalTone;
  }

  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(newTone: number) {
    this.setInternalState(
      HctSolver.solveToInt(
        this.internalHue,
        this.internalChroma,
        newTone,
      ),
    );
  }

  private constructor(private argb: number) {
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue;
    this.internalChroma = cam.chroma;
    this.internalTone = utils.lstarFromArgb(argb);
    this.argb = argb;
  }

  private setInternalState(argb: number) {
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue;
    this.internalChroma = cam.chroma;
    this.internalTone = utils.lstarFromArgb(argb);
    this.argb = argb;
  }

  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(vc: ViewingConditions): Hct {
    // 1. Use CAM16 to find XYZ coordinates of color in specified VC.
    const cam = Cam16.fromInt(this.toInt());
    const viewedInVc = cam.xyzInViewingConditions(vc);

    // 2. Create CAM16 of those XYZ coordinates in default VC.
    const recastInVc = Cam16.fromXyzInViewingConditions(
      viewedInVc[0],
      viewedInVc[1],
      viewedInVc[2],
      ViewingConditions.make(),
    );

    // 3. Create HCT from:
    // - CAM16 using default VC with XYZ coordinates in specified VC.
    // - L* converted from Y in XYZ coordinates in specified VC.
    const recastHct = Hct.from(
      recastInVc.hue,
      recastInVc.chroma,
      utils.lstarFromY(viewedInVc[1]),
    );
    return recastHct;
  }
}
// --- END FILE: hct/hct.ts ---


// --- BEGIN FILE: hct/hct_solver.ts ---
// This file is automatically generated. Do not modify it.


// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable:class-as-namespace
/**
 * A class that solves the HCT equation.
 */
export class HctSolver {
  static SCALED_DISCOUNT_FROM_LINRGB = [
    [
      0.001200833568784504,
      0.002389694492170889,
      0.0002795742885861124,
    ],
    [
      0.0005891086651375999,
      0.0029785502573438758,
      0.0003270666104008398,
    ],
    [
      0.00010146692491640572,
      0.0005364214359186694,
      0.0032979401770712076,
    ],
  ];

  static LINRGB_FROM_SCALED_DISCOUNT = [
    [
      1373.2198709594231,
      -1100.4251190754821,
      -7.278681089101213,
    ],
    [
      -271.815969077903,
      559.6580465940733,
      -32.46047482791194,
    ],
    [
      1.9622899599665666,
      -57.173814538844006,
      308.7233197812385,
    ],
  ];

  static Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];

  static CRITICAL_PLANES = [
    0.015176349177441876, 0.045529047532325624, 0.07588174588720938,
    0.10623444424209313, 0.13658714259697685, 0.16693984095186062,
    0.19729253930674434, 0.2276452376616281, 0.2579979360165119,
    0.28835063437139563, 0.3188300904430532, 0.350925934958123,
    0.3848314933096426, 0.42057480301049466, 0.458183274052838,
    0.4976837250274023, 0.5391024159806381, 0.5824650784040898,
    0.6277969426914107, 0.6751227633498623, 0.7244668422128921,
    0.775853049866786, 0.829304845476233, 0.8848452951698498,
    0.942497089126609, 1.0022825574869039, 1.0642236851973577,
    1.1283421258858297, 1.1946592148522128, 1.2631959812511864,
    1.3339731595349034, 1.407011200216447, 1.4823302800086415,
    1.5599503113873272, 1.6398909516233677, 1.7221716113234105,
    1.8068114625156377, 1.8938294463134073, 1.9832442801866852,
    2.075074464868551, 2.1693382909216234, 2.2660538449872063,
    2.36523901573795, 2.4669114995532007, 2.5710888059345764,
    2.6777882626779785, 2.7870270208169257, 2.898822059350997,
    3.0131901897720907, 3.1301480604002863, 3.2497121605402226,
    3.3718988244681087, 3.4967242352587946, 3.624204428461639,
    3.754355295633311, 3.887192587735158, 4.022731918402185,
    4.160988767090289, 4.301978482107941, 4.445716283538092,
    4.592217266055746, 4.741496401646282, 4.893568542229298,
    5.048448422192488, 5.20615066083972, 5.3666897647573375,
    5.5300801301023865, 5.696336044816294, 5.865471690767354,
    6.037501145825082, 6.212438385869475, 6.390297286737924,
    6.571091626112461, 6.7548350853498045, 6.941541251256611,
    7.131223617812143, 7.323895587840543, 7.5195704746346665,
    7.7182615035334345, 7.919981813454504, 8.124744458384042,
    8.332562408825165, 8.543448553206703, 8.757415699253682,
    8.974476575321063, 9.194643831691977, 9.417930041841839,
    9.644347703669503, 9.873909240696694, 10.106627003236781,
    10.342513269534024, 10.58158024687427, 10.8238400726681,
    11.069304815507364, 11.317986476196008, 11.569896988756009,
    11.825048221409341, 12.083451977536606, 12.345119996613247,
    12.610063955123938, 12.878295467455942, 13.149826086772048,
    13.42466730586372, 13.702830557985108, 13.984327217668513,
    14.269168601521828, 14.55736596900856, 14.848930523210871,
    15.143873411576273, 15.44220572664832, 15.743938506781891,
    16.04908273684337, 16.35764934889634, 16.66964922287304,
    16.985093187232053, 17.30399201960269, 17.62635644741625,
    17.95219714852476, 18.281524751807332, 18.614349837764564,
    18.95068293910138, 19.290534541298456, 19.633915083172692,
    19.98083495742689, 20.331304511189067, 20.685334046541502,
    21.042933821039977, 21.404114048223256, 21.76888489811322,
    22.137256497705877, 22.50923893145328, 22.884842241736916,
    23.264076429332462, 23.6469514538663, 24.033477234264016,
    24.42366364919083, 24.817520537484558, 25.21505769858089,
    25.61628489293138, 26.021211842414342, 26.429848230738664,
    26.842203703840827, 27.258287870275353, 27.678110301598522,
    28.10168053274597, 28.529008062403893, 28.96010235337422,
    29.39497283293396, 29.83362889318845, 30.276079891419332,
    30.722335150426627, 31.172403958865512, 31.62629557157785,
    32.08401920991837, 32.54558406207592, 33.010999283389665,
    33.4802739966603, 33.953417292456834, 34.430438229418264,
    34.911345834551085, 35.39614910352207, 35.88485700094671,
    36.37747846067349, 36.87402238606382, 37.37449765026789,
    37.87891309649659, 38.38727753828926, 38.89959975977785,
    39.41588851594697, 39.93615253289054, 40.460400508064545,
    40.98864111053629, 41.520882981230194, 42.05713473317016,
    42.597404951718396, 43.141702194811224, 43.6900349931913,
    44.24241185063697, 44.798841244188324, 45.35933162437017,
    45.92389141541209, 46.49252901546552, 47.065252796817916,
    47.64207110610409, 48.22299226451468, 48.808024568002054,
    49.3971762874833, 49.9904556690408, 50.587870934119984,
    51.189430279724725, 51.79514187861014, 52.40501387947288,
    53.0190544071392, 53.637271562750364, 54.259673423945976,
    54.88626804504493, 55.517063457223934, 56.15206766869424,
    56.79128866487574, 57.43473440856916, 58.08241284012621,
    58.734331877617365, 59.39049941699807, 60.05092333227251,
    60.715611475655585, 61.38457167773311, 62.057811747619894,
    62.7353394731159, 63.417162620860914, 64.10328893648692,
    64.79372614476921, 65.48848194977529, 66.18756403501224,
    66.89098006357258, 67.59873767827808, 68.31084450182222,
    69.02730813691093, 69.74813616640164, 70.47333615344107,
    71.20291564160104, 71.93688215501312, 72.67524319850172,
    73.41800625771542, 74.16517879925733, 74.9167682708136,
    75.67278210128072, 76.43322770089146, 77.1981124613393,
    77.96744375590167, 78.74122893956174, 79.51947534912904,
    80.30219030335869, 81.08938110306934, 81.88105503125999,
    82.67721935322541, 83.4778813166706, 84.28304815182372,
    85.09272707154808, 85.90692527145302, 86.72564993000343,
    87.54890820862819, 88.3767072518277, 89.2090541872801,
    90.04595612594655, 90.88742016217518, 91.73345337380438,
    92.58406282226491, 93.43925555268066, 94.29903859396902,
    95.16341895893969, 96.03240364439274, 96.9059996312159,
    97.78421388448044, 98.6670533535366, 99.55452497210776,
  ];

  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  private static sanitizeRadians(angle: number): number {
    return (angle + Math.PI * 8) % (Math.PI * 2);
  }

  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  private static trueDelinearized(rgbComponent: number): number {
    const normalized = rgbComponent / 100.0;
    let delinearized = 0.0;
    if (normalized <= 0.0031308) {
      delinearized = normalized * 12.92;
    } else {
      delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
    }
    return delinearized * 255.0;
  }

  private static chromaticAdaptation(component: number): number {
    const af = Math.pow(Math.abs(component), 0.42);
    return math.signum(component) * 400.0 * af / (af + 27.13);
  }

  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  private static hueOf(linrgb: number[]): number {
    const scaledDiscount =
      math.matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB);
    const rA = HctSolver.chromaticAdaptation(scaledDiscount[0]);
    const gA = HctSolver.chromaticAdaptation(scaledDiscount[1]);
    const bA = HctSolver.chromaticAdaptation(scaledDiscount[2]);
    // redness-greenness
    const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
    // yellowness-blueness
    const b = (rA + gA - 2.0 * bA) / 9.0;
    return Math.atan2(b, a);
  }

  private static areInCyclicOrder(a: number, b: number, c: number): boolean {
    const deltaAB = HctSolver.sanitizeRadians(b - a);
    const deltaAC = HctSolver.sanitizeRadians(c - a);
    return deltaAB < deltaAC;
  }

  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  private static intercept(source: number, mid: number, target: number):
    number {
    return (mid - source) / (target - source);
  }

  private static lerpPoint(source: number[], t: number, target: number[]):
    number[] {
    return [
      source[0] + (target[0] - source[0]) * t,
      source[1] + (target[1] - source[1]) * t,
      source[2] + (target[2] - source[2]) * t,
    ];
  }

  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  private static setCoordinate(
    source: number[],
    coordinate: number,
    target: number[],
    axis: number,
  ): number[] {
    const t = HctSolver.intercept(source[axis], coordinate, target[axis]);
    return HctSolver.lerpPoint(source, t, target);
  }

  private static isBounded(x: number): boolean {
    return 0.0 <= x && x <= 100.0;
  }

  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  private static nthVertex(y: number, n: number): number[] {
    const kR = HctSolver.Y_FROM_LINRGB[0];
    const kG = HctSolver.Y_FROM_LINRGB[1];
    const kB = HctSolver.Y_FROM_LINRGB[2];
    const coordA = n % 4 <= 1 ? 0.0 : 100.0;
    const coordB = n % 2 === 0 ? 0.0 : 100.0;
    if (n < 4) {
      const g = coordA;
      const b = coordB;
      const r = (y - g * kG - b * kB) / kR;
      if (HctSolver.isBounded(r)) {
        return [r, g, b];
      } else {
        return [-1.0, -1.0, -1.0];
      }
    } else if (n < 8) {
      const b = coordA;
      const r = coordB;
      const g = (y - r * kR - b * kB) / kG;
      if (HctSolver.isBounded(g)) {
        return [r, g, b];
      } else {
        return [-1.0, -1.0, -1.0];
      }
    } else {
      const r = coordA;
      const g = coordB;
      const b = (y - r * kR - g * kG) / kB;
      if (HctSolver.isBounded(b)) {
        return [r, g, b];
      } else {
        return [-1.0, -1.0, -1.0];
      }
    }
  }

  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  private static bisectToSegment(y: number, targetHue: number): number[][] {
    let left = [-1.0, -1.0, -1.0];
    let right = left;
    let leftHue = 0.0;
    let rightHue = 0.0;
    let initialized = false;
    let uncut = true;
    for (let n = 0; n < 12; n++) {
      const mid = HctSolver.nthVertex(y, n);
      if (mid[0] < 0) {
        continue;
      }
      const midHue = HctSolver.hueOf(mid);
      if (!initialized) {
        left = mid;
        right = mid;
        leftHue = midHue;
        rightHue = midHue;
        initialized = true;
        continue;
      }
      if (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) {
        uncut = false;
        if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
          right = mid;
          rightHue = midHue;
        } else {
          left = mid;
          leftHue = midHue;
        }
      }
    }
    return [left, right];
  }

  private static midpoint(a: number[], b: number[]): number[] {
    return [
      (a[0] + b[0]) / 2,
      (a[1] + b[1]) / 2,
      (a[2] + b[2]) / 2,
    ];
  }

  private static criticalPlaneBelow(x: number): number {
    return Math.floor(x - 0.5);
  }

  private static criticalPlaneAbove(x: number): number {
    return Math.ceil(x - 0.5);
  }

  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  private static bisectToLimit(y: number, targetHue: number): number[] {
    const segment = HctSolver.bisectToSegment(y, targetHue);
    let left = segment[0];
    let leftHue = HctSolver.hueOf(left);
    let right = segment[1];
    for (let axis = 0; axis < 3; axis++) {
      if (left[axis] !== right[axis]) {
        let lPlane = -1;
        let rPlane = 255;
        if (left[axis] < right[axis]) {
          lPlane = HctSolver.criticalPlaneBelow(
            HctSolver.trueDelinearized(left[axis]));
          rPlane = HctSolver.criticalPlaneAbove(
            HctSolver.trueDelinearized(right[axis]));
        } else {
          lPlane = HctSolver.criticalPlaneAbove(
            HctSolver.trueDelinearized(left[axis]));
          rPlane = HctSolver.criticalPlaneBelow(
            HctSolver.trueDelinearized(right[axis]));
        }
        for (let i = 0; i < 8; i++) {
          if (Math.abs(rPlane - lPlane) <= 1) {
            break;
          } else {
            const mPlane = Math.floor((lPlane + rPlane) / 2.0);
            const midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane];
            const mid =
              HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis);
            const midHue = HctSolver.hueOf(mid);
            if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
              right = mid;
              rPlane = mPlane;
            } else {
              left = mid;
              leftHue = midHue;
              lPlane = mPlane;
            }
          }
        }
      }
    }
    return HctSolver.midpoint(left, right);
  }

  private static inverseChromaticAdaptation(adapted: number): number {
    const adaptedAbs = Math.abs(adapted);
    const base = Math.max(0, 27.13 * adaptedAbs / (400.0 - adaptedAbs));
    return math.signum(adapted) * Math.pow(base, 1.0 / 0.42);
  }

  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  private static findResultByJ(hueRadians: number, chroma: number, y: number):
    number {
    // Initial estimate of j.
    let j = Math.sqrt(y) * 11.0;
    // ===========================================================
    // Operations inlined from Cam16 to avoid repeated calculation
    // ===========================================================
    const viewingConditions = ViewingConditions.DEFAULT;
    const tInnerCoeff =
      1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
    const eHue = 0.25 * (Math.cos(hueRadians + 2.0) + 3.8);
    const p1 =
      eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
    const hSin = Math.sin(hueRadians);
    const hCos = Math.cos(hueRadians);
    for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
      // ===========================================================
      // Operations inlined from Cam16 to avoid repeated calculation
      // ===========================================================
      const jNormalized = j / 100.0;
      const alpha =
        chroma === 0.0 || j === 0.0 ? 0.0 : chroma / Math.sqrt(jNormalized);
      const t = Math.pow(alpha * tInnerCoeff, 1.0 / 0.9);
      const ac = viewingConditions.aw *
        Math.pow(
          jNormalized,
          1.0 / viewingConditions.c / viewingConditions.z,
        );
      const p2 = ac / viewingConditions.nbb;
      const gamma = 23.0 * (p2 + 0.305) * t /
        (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
      const a = gamma * hCos;
      const b = gamma * hSin;
      const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
      const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
      const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
      const rCScaled = HctSolver.inverseChromaticAdaptation(rA);
      const gCScaled = HctSolver.inverseChromaticAdaptation(gA);
      const bCScaled = HctSolver.inverseChromaticAdaptation(bA);
      const linrgb = math.matrixMultiply(
        [rCScaled, gCScaled, bCScaled],
        HctSolver.LINRGB_FROM_SCALED_DISCOUNT,
      );
      // ===========================================================
      // Operations inlined from Cam16 to avoid repeated calculation
      // ===========================================================
      if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
        return 0;
      }
      const kR = HctSolver.Y_FROM_LINRGB[0];
      const kG = HctSolver.Y_FROM_LINRGB[1];
      const kB = HctSolver.Y_FROM_LINRGB[2];
      const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
      if (fnj <= 0) {
        return 0;
      }
      if (iterationRound === 4 || Math.abs(fnj - y) < 0.002) {
        if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
          return 0;
        }
        return utils.argbFromLinrgb(linrgb);
      }
      // Iterates with Newton method,
      // Using 2 * fn(j) / j as the approximation of fn'(j)
      j = j - (fnj - y) * j / (2 * fnj);
    }
    return 0;
  }

  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(hueDegrees: number, chroma: number, lstar: number): number {
    if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) {
      return utils.argbFromLstar(lstar);
    }
    hueDegrees = math.sanitizeDegreesDouble(hueDegrees);
    const hueRadians = hueDegrees / 180 * Math.PI;
    const y = utils.yFromLstar(lstar);
    const exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y);
    if (exactAnswer !== 0) {
      return exactAnswer;
    }
    const linrgb = HctSolver.bisectToLimit(y, hueRadians);
    return utils.argbFromLinrgb(linrgb);
  }

  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(hueDegrees: number, chroma: number, lstar: number): Cam16 {
    return Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
  }
}
// --- END FILE: hct/hct_solver.ts ---


// --- BEGIN FILE: hct/viewing_conditions.ts ---
/**
 * In traditional color spaces, a color can be identified solely by the
 * observer's measurement of the color. Color appearance models such as CAM16
 * also use information about the environment where the color was
 * observed, known as the viewing conditions.
 *
 * For example, white under the traditional assumption of a midday sun white
 * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
 * hue 203, chroma 3, lightness 100)
 *
 * This class caches intermediate values of the CAM16 conversion process that
 * depend only on viewing conditions, enabling speed ups.
 */
export class ViewingConditions {
  /** sRGB-like viewing conditions.  */
  static DEFAULT = ViewingConditions.make();

  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(
    whitePoint = utils.whitePointD65(),
    adaptingLuminance = (200.0 / Math.PI) * utils.yFromLstar(50.0) / 100.0,
    backgroundLstar = 50.0, surround = 2.0,
    discountingIlluminant = false): ViewingConditions {
    const xyz = whitePoint;
    const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
    const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
    const bW = xyz[0] * -0.002079 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
    const f = 0.8 + surround / 10.0;
    const c = f >= 0.9 ? math.lerp(0.59, 0.69, (f - 0.9) * 10.0) :
      math.lerp(0.525, 0.59, (f - 0.8) * 10.0);
    let d = discountingIlluminant ?
      1.0 :
      f * (1.0 - (1.0 / 3.6) * Math.exp((-adaptingLuminance - 42.0) / 92.0));
    d = d > 1.0 ? 1.0 : d < 0.0 ? 0.0 : d;
    const nc = f;
    const rgbD = [
      d * (100.0 / rW) + 1.0 - d,
      d * (100.0 / gW) + 1.0 - d,
      d * (100.0 / bW) + 1.0 - d,
    ];
    const k = 1.0 / (5.0 * adaptingLuminance + 1.0);
    const k4 = k * k * k * k;
    const k4F = 1.0 - k4;
    const fl = k4 * adaptingLuminance +
      0.1 * k4F * k4F * Math.cbrt(5.0 * adaptingLuminance);
    const n = utils.yFromLstar(backgroundLstar) / whitePoint[1];
    const z = 1.48 + Math.sqrt(n);
    const nbb = 0.725 / Math.pow(n, 0.2);
    const ncb = nbb;
    const rgbAFactors = [
      Math.pow((fl * rgbD[0] * rW) / 100.0, 0.42),
      Math.pow((fl * rgbD[1] * gW) / 100.0, 0.42),
      Math.pow((fl * rgbD[2] * bW) / 100.0, 0.42),
    ];
    const rgbA = [
      (400.0 * rgbAFactors[0]) / (rgbAFactors[0] + 27.13),
      (400.0 * rgbAFactors[1]) / (rgbAFactors[1] + 27.13),
      (400.0 * rgbAFactors[2]) / (rgbAFactors[2] + 27.13),
    ];
    const aw = (2.0 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
    return new ViewingConditions(
      n, aw, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
  }

  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  private constructor(
    public n: number, public aw: number, public nbb: number,
    public ncb: number, public c: number, public nc: number,
    public rgbD: number[], public fl: number, public fLRoot: number,
    public z: number) { }
}
// --- END FILE: hct/viewing_conditions.ts ---


// --- BEGIN FILE: palettes/core_palette.ts ---
/**
 * @deprecated Use {@link DynamicScheme} for color scheme generation.
 * Use {@link CorePalettes} for core palettes container class.
 */
export interface CorePaletteColors {
  primary: number;
  secondary?: number;
  tertiary?: number;
  neutral?: number;
  neutralVariant?: number;
  error?: number;
}

/**
 * An intermediate concept between the key color for a UI theme, and a full
 * color scheme. 5 sets of tones are generated, all except one use the same hue
 * as the key color, and all vary in chroma.
 *
 * @deprecated Use {@link DynamicScheme} for color scheme generation.
 * Use {@link CorePalettes} for core palettes container class.
 */
export class CorePalette {
  a1: TonalPalette;
  a2: TonalPalette;
  a3: TonalPalette;
  n1: TonalPalette;
  n2: TonalPalette;
  error: TonalPalette;

  /**
   * @param argb ARGB representation of a color
   *
   * @deprecated Use {@link DynamicScheme} for color scheme generation.
   * Use {@link CorePalettes} for core palettes container class.
   */
  static of(argb: number): CorePalette {
    return new CorePalette(argb, false);
  }

  /**
   * @param argb ARGB representation of a color
   *
   * @deprecated Use {@link DynamicScheme} for color scheme generation.
   * Use {@link CorePalettes} for core palettes container class.
   */
  static contentOf(argb: number): CorePalette {
    return new CorePalette(argb, true);
  }

  /**
   * Create a [CorePalette] from a set of colors
   *
   * @deprecated Use {@link DynamicScheme} for color scheme generation.
   * Use {@link CorePalettes} for core palettes container class.
   */
  static fromColors(colors: CorePaletteColors): CorePalette {
    return CorePalette.createPaletteFromColors(false, colors);
  }

  /**
   * Create a content [CorePalette] from a set of colors
   *
   * @deprecated Use {@link DynamicScheme} for color scheme generation.
   * Use {@link CorePalettes} for core palettes container class.
   */
  static contentFromColors(colors: CorePaletteColors): CorePalette {
    return CorePalette.createPaletteFromColors(true, colors);
  }

  private static createPaletteFromColors(
    content: boolean,
    colors: CorePaletteColors,
  ) {
    const palette = new CorePalette(colors.primary, content);
    if (colors.secondary) {
      const p = new CorePalette(colors.secondary, content);
      palette.a2 = p.a1;
    }
    if (colors.tertiary) {
      const p = new CorePalette(colors.tertiary, content);
      palette.a3 = p.a1;
    }
    if (colors.error) {
      const p = new CorePalette(colors.error, content);
      palette.error = p.a1;
    }
    if (colors.neutral) {
      const p = new CorePalette(colors.neutral, content);
      palette.n1 = p.n1;
    }
    if (colors.neutralVariant) {
      const p = new CorePalette(colors.neutralVariant, content);
      palette.n2 = p.n2;
    }
    return palette;
  }

  private constructor(argb: number, isContent: boolean) {
    const hct = Hct.fromInt(argb);
    const hue = hct.hue;
    const chroma = hct.chroma;
    if (isContent) {
      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);
      this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3);
      this.a3 = TonalPalette.fromHueAndChroma(hue + 60, chroma / 2);
      this.n1 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4));
      this.n2 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8));
    } else {
      this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma));
      this.a2 = TonalPalette.fromHueAndChroma(hue, 16);
      this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24);
      this.n1 = TonalPalette.fromHueAndChroma(hue, 4);
      this.n2 = TonalPalette.fromHueAndChroma(hue, 8);
    }
    this.error = TonalPalette.fromHueAndChroma(25, 84);
  }
}
// --- END FILE: palettes/core_palette.ts ---


// --- BEGIN FILE: palettes/core_palettes.ts ---
/**
 * Comprises foundational palettes to build a color scheme. Generated from a
 * source color, these palettes will then be part of a [DynamicScheme] together
 * with appearance preferences.
 */
export class CorePalettes {
  constructor(
    public primary: TonalPalette, public secondary: TonalPalette,
    public tertiary: TonalPalette, public neutral: TonalPalette,
    public neutralVariant: TonalPalette) { }
}
// --- END FILE: palettes/core_palettes.ts ---


// --- BEGIN FILE: palettes/tonal_palette.ts ---
/**
 *  A convenience class for retrieving colors that are constant in hue and
 *  chroma, but vary in tone.
 */
export class TonalPalette {
  private readonly cache = new Map<number, number>();

  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(argb: number): TonalPalette {
    const hct = Hct.fromInt(argb);
    return TonalPalette.fromHct(hct);
  }

  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(hct: Hct) {
    return new TonalPalette(hct.hue, hct.chroma, hct);
  }

  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(hue: number, chroma: number): TonalPalette {
    const keyColor = new KeyColor(hue, chroma).create();
    return new TonalPalette(hue, chroma, keyColor);
  }

  private constructor(readonly hue: number, readonly chroma: number, readonly keyColor: Hct) { }

  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(tone: number): number {
    let argb = this.cache.get(tone);
    if (argb === undefined) {
      argb = Hct.from(this.hue, this.chroma, tone).toInt();
      this.cache.set(tone, argb);
    }
    return argb;
  }

  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(tone: number): Hct {
    return Hct.fromInt(this.tone(tone));
  }
}

/**
 * Key color is a color that represents the hue and chroma of a tonal palette
 */
export class KeyColor {
  // Cache that maps tone to max chroma to avoid duplicated HCT calculation.
  private readonly chromaCache = new Map<number, number>();
  private readonly maxChromaValue = 200.0;

  constructor(readonly hue: number, readonly requestedChroma: number) { }

  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create(): Hct {
    // Pivot around T50 because T50 has the most chroma available, on
    // average. Thus it is most likely to have a direct answer.
    const pivotTone = 50;
    const toneStepSize = 1;
    // Epsilon to accept values slightly higher than the requested chroma.
    const epsilon = 0.01;

    // Binary search to find the tone that can provide a chroma that is closest
    // to the requested chroma.
    let lowerTone = 0;
    let upperTone = 100;
    while (lowerTone < upperTone) {
      const midTone = Math.floor((lowerTone + upperTone) / 2);
      const isAscending =
        this.maxChroma(midTone) < this.maxChroma(midTone + toneStepSize);
      const sufficientChroma =
        this.maxChroma(midTone) >= this.requestedChroma - epsilon;

      if (sufficientChroma) {
        // Either range [lowerTone, midTone] or [midTone, upperTone] has
        // the answer, so search in the range that is closer the pivot tone.
        if (Math.abs(lowerTone - pivotTone) < Math.abs(upperTone - pivotTone)) {
          upperTone = midTone;
        } else {
          if (lowerTone === midTone) {
            return Hct.from(this.hue, this.requestedChroma, lowerTone);
          }
          lowerTone = midTone;
        }
      } else {
        // As there is no sufficient chroma in the midTone, follow the direction
        // to the chroma peak.
        if (isAscending) {
          lowerTone = midTone + toneStepSize;
        } else {
          // Keep midTone for potential chroma peak.
          upperTone = midTone;
        }
      }
    }

    return Hct.from(this.hue, this.requestedChroma, lowerTone);
  }

  // Find the maximum chroma for a given tone
  private maxChroma(tone: number): number {
    if (this.chromaCache.has(tone)) {
      return this.chromaCache.get(tone)!;
    }
    const chroma = Hct.from(this.hue, this.maxChromaValue, tone).chroma;
    this.chromaCache.set(tone, chroma);
    return chroma;
  }
}
// --- END FILE: palettes/tonal_palette.ts ---


// --- BEGIN FILE: quantize/lab_point_provider.ts ---
/**
 * Provides conversions needed for K-Means quantization. Converting input to
 * points, and converting the final state of the K-Means algorithm to colors.
 */
export class LabPointProvider implements PointProvider {
  /**
   * Convert a color represented in ARGB to a 3-element array of L*a*b*
   * coordinates of the color.
   */
  fromInt(argb: number): number[] {
    return utils.labFromArgb(argb);
  }

  /**
   * Convert a 3-element array to a color represented in ARGB.
   */
  toInt(point: number[]): number {
    return utils.argbFromLab(point[0], point[1], point[2]);
  }

  /**
   * Standard CIE 1976 delta E formula also takes the square root, unneeded
   * here. This method is used by quantization algorithms to compare distance,
   * and the relative ordering is the same, with or without a square root.
   *
   * This relatively minor optimization is helpful because this method is
   * called at least once for each pixel in an image.
   */
  distance(from: number[], to: number[]): number {
    const dL = from[0] - to[0];
    const dA = from[1] - to[1];
    const dB = from[2] - to[2];
    return dL * dL + dA * dA + dB * dB;
  }
}
// --- END FILE: quantize/lab_point_provider.ts ---


// --- BEGIN FILE: quantize/point_provider.ts ---
/**
 * An interface to allow use of different color spaces by
 * quantizers.
 */

declare interface PointProvider {
  toInt(point: number[]): number;
  fromInt(argb: number): number[];
  distance(from: number[], to: number[]): number;
}
// --- END FILE: quantize/point_provider.ts ---


// --- BEGIN FILE: quantize/quantizer_celebi.ts ---
/**
 * An image quantizer that improves on the quality of a standard K-Means
 * algorithm by setting the K-Means initial state to the output of a Wu
 * quantizer, instead of random centroids. Improves on speed by several
 * optimizations, as implemented in Wsmeans, or Weighted Square Means, K-Means
 * with those optimizations.
 *
 * This algorithm was designed by M. Emre Celebi, and was found in their 2011
 * paper, Improving the Performance of K-Means for Color Quantization.
 * https://arxiv.org/abs/1101.0395
 */
// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable-next-line:class-as-namespace
export class QuantizerCelebi {
  /**
   * @param pixels Colors in ARGB format.
   * @param maxColors The number of colors to divide the image into. A lower
   *     number of colors may be returned.
   * @return Map with keys of colors in ARGB format, and values of number of
   *     pixels in the original image that correspond to the color in the
   *     quantized image.
   */
  static quantize(pixels: number[], maxColors: number): Map<number, number> {
    const wu = new QuantizerWu();
    const wuResult = wu.quantize(pixels, maxColors);
    return QuantizerWsmeans.quantize(pixels, wuResult, maxColors);
  }
}
// --- END FILE: quantize/quantizer_celebi.ts ---


// --- BEGIN FILE: quantize/quantizer_map.ts ---
/**
 * Quantizes an image into a map, with keys of ARGB colors, and values of the
 * number of times that color appears in the image.
 */
// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable-next-line:class-as-namespace
export class QuantizerMap {
  /**
   * @param pixels Colors in ARGB format.
   * @return A Map with keys of ARGB colors, and values of the number of times
   *     the color appears in the image.
   */
  static quantize(pixels: number[]): Map<number, number> {
    const countByColor = new Map<number, number>();
    for (let i = 0; i < pixels.length; i++) {
      const pixel = pixels[i];
      const alpha = utils.alphaFromArgb(pixel);
      if (alpha < 255) {
        continue;
      }
      countByColor.set(pixel, (countByColor.get(pixel) ?? 0) + 1);
    }
    return countByColor;
  }
}
// --- END FILE: quantize/quantizer_map.ts ---


// --- BEGIN FILE: quantize/quantizer_wsmeans.ts ---
const MAX_ITERATIONS = 10;
const MIN_MOVEMENT_DISTANCE = 3.0;

/**
 * An image quantizer that improves on the speed of a standard K-Means algorithm
 * by implementing several optimizations, including deduping identical pixels
 * and a triangle inequality rule that reduces the number of comparisons needed
 * to identify which cluster a point should be moved to.
 *
 * Wsmeans stands for Weighted Square Means.
 *
 * This algorithm was designed by M. Emre Celebi, and was found in their 2011
 * paper, Improving the Performance of K-Means for Color Quantization.
 * https://arxiv.org/abs/1101.0395
 */
// material_color_utilities is designed to have a consistent API across
// platforms and modular components that can be moved around easily. Using a
// class as a namespace facilitates this.
//
// tslint:disable-next-line:class-as-namespace
export class QuantizerWsmeans {
  /**
   * @param inputPixels Colors in ARGB format.
   * @param startingClusters Defines the initial state of the quantizer. Passing
   *     an empty array is fine, the implementation will create its own initial
   *     state that leads to reproducible results for the same inputs.
   *     Passing an array that is the result of Wu quantization leads to higher
   *     quality results.
   * @param maxColors The number of colors to divide the image into. A lower
   *     number of colors may be returned.
   * @return Colors in ARGB format.
   */
  static quantize(
    inputPixels: number[], startingClusters: number[],
    maxColors: number): Map<number, number> {
    const pixelToCount = new Map<number, number>();
    const points = new Array<number[]>();
    const pixels = new Array<number>();
    const pointProvider = new LabPointProvider();
    let pointCount = 0;
    for (let i = 0; i < inputPixels.length; i++) {
      const inputPixel = inputPixels[i];
      const pixelCount = pixelToCount.get(inputPixel);
      if (pixelCount === undefined) {
        pointCount++;
        points.push(pointProvider.fromInt(inputPixel));
        pixels.push(inputPixel);
        pixelToCount.set(inputPixel, 1);
      } else {
        pixelToCount.set(inputPixel, pixelCount + 1);
      }
    }

    const counts = new Array<number>();
    for (let i = 0; i < pointCount; i++) {
      const pixel = pixels[i];
      const count = pixelToCount.get(pixel);
      if (count !== undefined) {
        counts[i] = count;
      }
    }

    let clusterCount = Math.min(maxColors, pointCount);
    if (startingClusters.length > 0) {
      clusterCount = Math.min(clusterCount, startingClusters.length);
    }

    const clusters = new Array<number[]>();
    for (let i = 0; i < startingClusters.length; i++) {
      clusters.push(pointProvider.fromInt(startingClusters[i]));
    }
    const additionalClustersNeeded = clusterCount - clusters.length;
    if (startingClusters.length === 0 && additionalClustersNeeded > 0) {
      for (let i = 0; i < additionalClustersNeeded; i++) {
        const l = Math.random() * 100.0;
        const a = Math.random() * (100.0 - (-100.0) + 1) + -100;
        const b = Math.random() * (100.0 - (-100.0) + 1) + -100;

        clusters.push(new Array(l, a, b));
      }
    }

    const clusterIndices = new Array<number>();
    for (let i = 0; i < pointCount; i++) {
      clusterIndices.push(Math.floor(Math.random() * clusterCount));
    }

    const indexMatrix = new Array<number[]>();
    for (let i = 0; i < clusterCount; i++) {
      indexMatrix.push(new Array<number>());
      for (let j = 0; j < clusterCount; j++) {
        indexMatrix[i].push(0);
      }
    }

    const distanceToIndexMatrix = new Array<DistanceAndIndex[]>();
    for (let i = 0; i < clusterCount; i++) {
      distanceToIndexMatrix.push(new Array<DistanceAndIndex>());
      for (let j = 0; j < clusterCount; j++) {
        distanceToIndexMatrix[i].push(new DistanceAndIndex());
      }
    }


    const pixelCountSums = new Array<number>();
    for (let i = 0; i < clusterCount; i++) {
      pixelCountSums.push(0);
    }
    for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
      for (let i = 0; i < clusterCount; i++) {
        for (let j = i + 1; j < clusterCount; j++) {
          const distance = pointProvider.distance(clusters[i], clusters[j]);
          distanceToIndexMatrix[j][i].distance = distance;
          distanceToIndexMatrix[j][i].index = i;
          distanceToIndexMatrix[i][j].distance = distance;
          distanceToIndexMatrix[i][j].index = j;
        }
        distanceToIndexMatrix[i].sort();
        for (let j = 0; j < clusterCount; j++) {
          indexMatrix[i][j] = distanceToIndexMatrix[i][j].index;
        }
      }

      let pointsMoved = 0;
      for (let i = 0; i < pointCount; i++) {
        const point = points[i];
        const previousClusterIndex = clusterIndices[i];
        const previousCluster = clusters[previousClusterIndex];
        const previousDistance = pointProvider.distance(point, previousCluster);
        let minimumDistance = previousDistance;
        let newClusterIndex = -1;
        for (let j = 0; j < clusterCount; j++) {
          if (distanceToIndexMatrix[previousClusterIndex][j].distance >=
            4 * previousDistance) {
            continue;
          }
          const distance = pointProvider.distance(point, clusters[j]);
          if (distance < minimumDistance) {
            minimumDistance = distance;
            newClusterIndex = j;
          }
        }
        if (newClusterIndex !== -1) {
          const distanceChange = Math.abs(
            (Math.sqrt(minimumDistance) - Math.sqrt(previousDistance)));
          if (distanceChange > MIN_MOVEMENT_DISTANCE) {
            pointsMoved++;
            clusterIndices[i] = newClusterIndex;
          }
        }
      }

      if (pointsMoved === 0 && iteration !== 0) {
        break;
      }

      const componentASums = new Array<number>(clusterCount).fill(0);
      const componentBSums = new Array<number>(clusterCount).fill(0);
      const componentCSums = new Array<number>(clusterCount).fill(0);

      for (let i = 0; i < clusterCount; i++) {
        pixelCountSums[i] = 0;
      }
      for (let i = 0; i < pointCount; i++) {
        const clusterIndex = clusterIndices[i];
        const point = points[i];
        const count = counts[i];
        pixelCountSums[clusterIndex] += count;
        componentASums[clusterIndex] += (point[0] * count);
        componentBSums[clusterIndex] += (point[1] * count);
        componentCSums[clusterIndex] += (point[2] * count);
      }

      for (let i = 0; i < clusterCount; i++) {
        const count = pixelCountSums[i];
        if (count === 0) {
          clusters[i] = [0.0, 0.0, 0.0];
          continue;
        }
        const a = componentASums[i] / count;
        const b = componentBSums[i] / count;
        const c = componentCSums[i] / count;
        clusters[i] = [a, b, c];
      }
    }

    const argbToPopulation = new Map<number, number>();
    for (let i = 0; i < clusterCount; i++) {
      const count = pixelCountSums[i];
      if (count === 0) {
        continue;
      }

      const possibleNewCluster = pointProvider.toInt(clusters[i]);
      if (argbToPopulation.has(possibleNewCluster)) {
        continue;
      }

      argbToPopulation.set(possibleNewCluster, count);
    }
    return argbToPopulation;
  }
}

/**
 *  A wrapper for maintaining a table of distances between K-Means clusters.
 */
export class DistanceAndIndex {
  distance: number = -1;
  index: number = -1;
}
// --- END FILE: quantize/quantizer_wsmeans.ts ---


// --- BEGIN FILE: quantize/quantizer_wu.ts ---
const INDEX_BITS = 5;
const SIDE_LENGTH = 33;    // ((1 << INDEX_INDEX_BITS) + 1)
const TOTAL_SIZE = 35937;  // SIDE_LENGTH * SIDE_LENGTH * SIDE_LENGTH

const directions = {
  RED: 'red',
  GREEN: 'green',
  BLUE: 'blue',
};

/**
 * An image quantizer that divides the image's pixels into clusters by
 * recursively cutting an RGB cube, based on the weight of pixels in each area
 * of the cube.
 *
 * The algorithm was described by Xiaolin Wu in Graphic Gems II, published in
 * 1991.
 */
export class QuantizerWu {
  constructor(
    private weights: number[] = [], private momentsR: number[] = [],
    private momentsG: number[] = [], private momentsB: number[] = [],
    private moments: number[] = [], private cubes: Box[] = []) { }

  /**
   * @param pixels Colors in ARGB format.
   * @param maxColors The number of colors to divide the image into. A lower
   *     number of colors may be returned.
   * @return Colors in ARGB format.
   */
  quantize(pixels: number[], maxColors: number): number[] {
    this.constructHistogram(pixels);
    this.computeMoments();
    const createBoxesResult = this.createBoxes(maxColors);
    const results = this.createResult(createBoxesResult.resultCount);
    return results;
  }

  private constructHistogram(pixels: number[]) {
    this.weights = Array.from<number>({ length: TOTAL_SIZE }).fill(0);
    this.momentsR = Array.from<number>({ length: TOTAL_SIZE }).fill(0);
    this.momentsG = Array.from<number>({ length: TOTAL_SIZE }).fill(0);
    this.momentsB = Array.from<number>({ length: TOTAL_SIZE }).fill(0);
    this.moments = Array.from<number>({ length: TOTAL_SIZE }).fill(0);

    const countByColor = QuantizerMap.quantize(pixels);

    for (const [pixel, count] of countByColor.entries()) {
      const red = utils.redFromArgb(pixel);
      const green = utils.greenFromArgb(pixel);
      const blue = utils.blueFromArgb(pixel);

      const bitsToRemove = 8 - INDEX_BITS;
      const iR = (red >> bitsToRemove) + 1;
      const iG = (green >> bitsToRemove) + 1;
      const iB = (blue >> bitsToRemove) + 1;
      const index = this.getIndex(iR, iG, iB);

      this.weights[index] = (this.weights[index] ?? 0) + count;
      this.momentsR[index] += count * red;
      this.momentsG[index] += count * green;
      this.momentsB[index] += count * blue;
      this.moments[index] += count * (red * red + green * green + blue * blue);
    }
  }

  private computeMoments() {
    for (let r = 1; r < SIDE_LENGTH; r++) {
      const area = Array.from<number>({ length: SIDE_LENGTH }).fill(0);
      const areaR = Array.from<number>({ length: SIDE_LENGTH }).fill(0);
      const areaG = Array.from<number>({ length: SIDE_LENGTH }).fill(0);
      const areaB = Array.from<number>({ length: SIDE_LENGTH }).fill(0);
      const area2 = Array.from<number>({ length: SIDE_LENGTH }).fill(0.0);
      for (let g = 1; g < SIDE_LENGTH; g++) {
        let line = 0;
        let lineR = 0;
        let lineG = 0;
        let lineB = 0;
        let line2 = 0.0;
        for (let b = 1; b < SIDE_LENGTH; b++) {
          const index = this.getIndex(r, g, b);
          line += this.weights[index];
          lineR += this.momentsR[index];
          lineG += this.momentsG[index];
          lineB += this.momentsB[index];
          line2 += this.moments[index];

          area[b] += line;
          areaR[b] += lineR;
          areaG[b] += lineG;
          areaB[b] += lineB;
          area2[b] += line2;

          const previousIndex = this.getIndex(r - 1, g, b);
          this.weights[index] = this.weights[previousIndex] + area[b];
          this.momentsR[index] = this.momentsR[previousIndex] + areaR[b];
          this.momentsG[index] = this.momentsG[previousIndex] + areaG[b];
          this.momentsB[index] = this.momentsB[previousIndex] + areaB[b];
          this.moments[index] = this.moments[previousIndex] + area2[b];
        }
      }
    }
  }

  private createBoxes(maxColors: number): CreateBoxesResult {
    this.cubes =
      Array.from<number>({ length: maxColors }).fill(0).map(() => new Box());
    const volumeVariance = Array.from<number>({ length: maxColors }).fill(0.0);
    this.cubes[0].r0 = 0;
    this.cubes[0].g0 = 0;
    this.cubes[0].b0 = 0;

    this.cubes[0].r1 = SIDE_LENGTH - 1;
    this.cubes[0].g1 = SIDE_LENGTH - 1;
    this.cubes[0].b1 = SIDE_LENGTH - 1;

    let generatedColorCount = maxColors;
    let next = 0;
    for (let i = 1; i < maxColors; i++) {
      if (this.cut(this.cubes[next], this.cubes[i])) {
        volumeVariance[next] =
          this.cubes[next].vol > 1 ? this.variance(this.cubes[next]) : 0.0;
        volumeVariance[i] =
          this.cubes[i].vol > 1 ? this.variance(this.cubes[i]) : 0.0;
      } else {
        volumeVariance[next] = 0.0;
        i--;
      }

      next = 0;
      let temp = volumeVariance[0];
      for (let j = 1; j <= i; j++) {
        if (volumeVariance[j] > temp) {
          temp = volumeVariance[j];
          next = j;
        }
      }
      if (temp <= 0.0) {
        generatedColorCount = i + 1;
        break;
      }
    }
    return new CreateBoxesResult(maxColors, generatedColorCount);
  }

  private createResult(colorCount: number): number[] {
    const colors: number[] = [];
    for (let i = 0; i < colorCount; ++i) {
      const cube = this.cubes[i];
      const weight = this.volume(cube, this.weights);
      if (weight > 0) {
        const r = Math.round(this.volume(cube, this.momentsR) / weight);
        const g = Math.round(this.volume(cube, this.momentsG) / weight);
        const b = Math.round(this.volume(cube, this.momentsB) / weight);
        const color = (255 << 24) | ((r & 0x0ff) << 16) | ((g & 0x0ff) << 8) |
          (b & 0x0ff);
        colors.push(color);
      }
    }
    return colors;
  }

  private variance(cube: Box) {
    const dr = this.volume(cube, this.momentsR);
    const dg = this.volume(cube, this.momentsG);
    const db = this.volume(cube, this.momentsB);
    const xx = this.moments[this.getIndex(cube.r1, cube.g1, cube.b1)] -
      this.moments[this.getIndex(cube.r1, cube.g1, cube.b0)] -
      this.moments[this.getIndex(cube.r1, cube.g0, cube.b1)] +
      this.moments[this.getIndex(cube.r1, cube.g0, cube.b0)] -
      this.moments[this.getIndex(cube.r0, cube.g1, cube.b1)] +
      this.moments[this.getIndex(cube.r0, cube.g1, cube.b0)] +
      this.moments[this.getIndex(cube.r0, cube.g0, cube.b1)] -
      this.moments[this.getIndex(cube.r0, cube.g0, cube.b0)];
    const hypotenuse = dr * dr + dg * dg + db * db;
    const volume = this.volume(cube, this.weights);
    return xx - hypotenuse / volume;
  }

  private cut(one: Box, two: Box) {
    const wholeR = this.volume(one, this.momentsR);
    const wholeG = this.volume(one, this.momentsG);
    const wholeB = this.volume(one, this.momentsB);
    const wholeW = this.volume(one, this.weights);

    const maxRResult = this.maximize(
      one, directions.RED, one.r0 + 1, one.r1, wholeR, wholeG, wholeB,
      wholeW);
    const maxGResult = this.maximize(
      one, directions.GREEN, one.g0 + 1, one.g1, wholeR, wholeG, wholeB,
      wholeW);
    const maxBResult = this.maximize(
      one, directions.BLUE, one.b0 + 1, one.b1, wholeR, wholeG, wholeB,
      wholeW);

    let direction;
    const maxR = maxRResult.maximum;
    const maxG = maxGResult.maximum;
    const maxB = maxBResult.maximum;
    if (maxR >= maxG && maxR >= maxB) {
      if (maxRResult.cutLocation < 0) {
        return false;
      }
      direction = directions.RED;
    } else if (maxG >= maxR && maxG >= maxB) {
      direction = directions.GREEN;
    } else {
      direction = directions.BLUE;
    }

    two.r1 = one.r1;
    two.g1 = one.g1;
    two.b1 = one.b1;

    switch (direction) {
      case directions.RED:
        one.r1 = maxRResult.cutLocation;
        two.r0 = one.r1;
        two.g0 = one.g0;
        two.b0 = one.b0;
        break;
      case directions.GREEN:
        one.g1 = maxGResult.cutLocation;
        two.r0 = one.r0;
        two.g0 = one.g1;
        two.b0 = one.b0;
        break;
      case directions.BLUE:
        one.b1 = maxBResult.cutLocation;
        two.r0 = one.r0;
        two.g0 = one.g0;
        two.b0 = one.b1;
        break;
      default:
        throw new Error('unexpected direction ' + direction);
    }

    one.vol = (one.r1 - one.r0) * (one.g1 - one.g0) * (one.b1 - one.b0);
    two.vol = (two.r1 - two.r0) * (two.g1 - two.g0) * (two.b1 - two.b0);
    return true;
  }

  private maximize(
    cube: Box, direction: string, first: number, last: number, wholeR: number,
    wholeG: number, wholeB: number, wholeW: number) {
    const bottomR = this.bottom(cube, direction, this.momentsR);
    const bottomG = this.bottom(cube, direction, this.momentsG);
    const bottomB = this.bottom(cube, direction, this.momentsB);
    const bottomW = this.bottom(cube, direction, this.weights);

    let max = 0.0;
    let cut = -1;

    let halfR = 0;
    let halfG = 0;
    let halfB = 0;
    let halfW = 0;
    for (let i = first; i < last; i++) {
      halfR = bottomR + this.top(cube, direction, i, this.momentsR);
      halfG = bottomG + this.top(cube, direction, i, this.momentsG);
      halfB = bottomB + this.top(cube, direction, i, this.momentsB);
      halfW = bottomW + this.top(cube, direction, i, this.weights);
      if (halfW === 0) {
        continue;
      }

      let tempNumerator = (halfR * halfR + halfG * halfG + halfB * halfB) * 1.0;
      let tempDenominator = halfW * 1.0;
      let temp = tempNumerator / tempDenominator;

      halfR = wholeR - halfR;
      halfG = wholeG - halfG;
      halfB = wholeB - halfB;
      halfW = wholeW - halfW;
      if (halfW === 0) {
        continue;
      }

      tempNumerator = (halfR * halfR + halfG * halfG + halfB * halfB) * 1.0;
      tempDenominator = halfW * 1.0;
      temp += tempNumerator / tempDenominator;

      if (temp > max) {
        max = temp;
        cut = i;
      }
    }
    return new MaximizeResult(cut, max);
  }

  private volume(cube: Box, moment: number[]) {
    return (
      moment[this.getIndex(cube.r1, cube.g1, cube.b1)] -
      moment[this.getIndex(cube.r1, cube.g1, cube.b0)] -
      moment[this.getIndex(cube.r1, cube.g0, cube.b1)] +
      moment[this.getIndex(cube.r1, cube.g0, cube.b0)] -
      moment[this.getIndex(cube.r0, cube.g1, cube.b1)] +
      moment[this.getIndex(cube.r0, cube.g1, cube.b0)] +
      moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
      moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
  }

  private bottom(cube: Box, direction: string, moment: number[]) {
    switch (direction) {
      case directions.RED:
        return (
          -moment[this.getIndex(cube.r0, cube.g1, cube.b1)] +
          moment[this.getIndex(cube.r0, cube.g1, cube.b0)] +
          moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
          moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
      case directions.GREEN:
        return (
          -moment[this.getIndex(cube.r1, cube.g0, cube.b1)] +
          moment[this.getIndex(cube.r1, cube.g0, cube.b0)] +
          moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
          moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
      case directions.BLUE:
        return (
          -moment[this.getIndex(cube.r1, cube.g1, cube.b0)] +
          moment[this.getIndex(cube.r1, cube.g0, cube.b0)] +
          moment[this.getIndex(cube.r0, cube.g1, cube.b0)] -
          moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
      default:
        throw new Error('unexpected direction $direction');
    }
  }

  private top(
    cube: Box, direction: string, position: number, moment: number[]) {
    switch (direction) {
      case directions.RED:
        return (
          moment[this.getIndex(position, cube.g1, cube.b1)] -
          moment[this.getIndex(position, cube.g1, cube.b0)] -
          moment[this.getIndex(position, cube.g0, cube.b1)] +
          moment[this.getIndex(position, cube.g0, cube.b0)]);
      case directions.GREEN:
        return (
          moment[this.getIndex(cube.r1, position, cube.b1)] -
          moment[this.getIndex(cube.r1, position, cube.b0)] -
          moment[this.getIndex(cube.r0, position, cube.b1)] +
          moment[this.getIndex(cube.r0, position, cube.b0)]);
      case directions.BLUE:
        return (
          moment[this.getIndex(cube.r1, cube.g1, position)] -
          moment[this.getIndex(cube.r1, cube.g0, position)] -
          moment[this.getIndex(cube.r0, cube.g1, position)] +
          moment[this.getIndex(cube.r0, cube.g0, position)]);
      default:
        throw new Error('unexpected direction $direction');
    }
  }

  private getIndex(r: number, g: number, b: number): number {
    return (r << (INDEX_BITS * 2)) + (r << (INDEX_BITS + 1)) + r +
      (g << INDEX_BITS) + g + b;
  }
}

/**
 * Keeps track of the state of each box created as the Wu  quantization
 * algorithm progresses through dividing the image's pixels as plotted in RGB.
 */
export class Box {
  constructor(
    public r0: number = 0, public r1: number = 0, public g0: number = 0,
    public g1: number = 0, public b0: number = 0, public b1: number = 0,
    public vol: number = 0) { }
}

/**
 * Represents final result of Wu algorithm.
 */
export class CreateBoxesResult {
  /**
   * @param requestedCount how many colors the caller asked to be returned from
   *     quantization.
   * @param resultCount the actual number of colors achieved from quantization.
   *     May be lower than the requested count.
   */
  constructor(public requestedCount: number, public resultCount: number) { }
}

/**
 * Represents the result of calculating where to cut an existing box in such
 * a way to maximize variance between the two new boxes created by a cut.
 */
export class MaximizeResult {
  constructor(public cutLocation: number, public maximum: number) { }
}
// --- END FILE: quantize/quantizer_wu.ts ---


// --- BEGIN FILE: scheme/scheme.ts ---
// This file is automatically generated. Do not modify it.

/**
 * DEPRECATED. The `Scheme` class is deprecated in favor of `DynamicScheme`.
 * Please see
 * https://github.com/material-foundation/material-color-utilities/blob/main/make_schemes.md
 * for migration guidance.
 *
 * Represents a Material color scheme, a mapping of color roles to colors.
 */
export class Scheme {
  get primary(): number {
    return this.props.primary;
  }

  get onPrimary(): number {
    return this.props.onPrimary;
  }

  get primaryContainer(): number {
    return this.props.primaryContainer;
  }

  get onPrimaryContainer(): number {
    return this.props.onPrimaryContainer;
  }

  get secondary(): number {
    return this.props.secondary;
  }

  get onSecondary(): number {
    return this.props.onSecondary;
  }

  get secondaryContainer(): number {
    return this.props.secondaryContainer;
  }

  get onSecondaryContainer(): number {
    return this.props.onSecondaryContainer;
  }

  get tertiary(): number {
    return this.props.tertiary;
  }

  get onTertiary(): number {
    return this.props.onTertiary;
  }

  get tertiaryContainer(): number {
    return this.props.tertiaryContainer;
  }

  get onTertiaryContainer(): number {
    return this.props.onTertiaryContainer;
  }

  get error(): number {
    return this.props.error;
  }

  get onError(): number {
    return this.props.onError;
  }

  get errorContainer(): number {
    return this.props.errorContainer;
  }

  get onErrorContainer(): number {
    return this.props.onErrorContainer;
  }

  get background(): number {
    return this.props.background;
  }

  get onBackground(): number {
    return this.props.onBackground;
  }

  get surface(): number {
    return this.props.surface;
  }

  get onSurface(): number {
    return this.props.onSurface;
  }

  get surfaceVariant(): number {
    return this.props.surfaceVariant;
  }

  get onSurfaceVariant(): number {
    return this.props.onSurfaceVariant;
  }

  get outline(): number {
    return this.props.outline;
  }

  get outlineVariant(): number {
    return this.props.outlineVariant;
  }

  get shadow(): number {
    return this.props.shadow;
  }

  get scrim(): number {
    return this.props.scrim;
  }

  get inverseSurface(): number {
    return this.props.inverseSurface;
  }

  get inverseOnSurface(): number {
    return this.props.inverseOnSurface;
  }

  get inversePrimary(): number {
    return this.props.inversePrimary;
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Light Material color scheme, based on the color's hue.
   */
  static light(argb: number): Scheme {
    return Scheme.lightFromCorePalette(CorePalette.of(argb));
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Dark Material color scheme, based on the color's hue.
   */
  static dark(argb: number): Scheme {
    return Scheme.darkFromCorePalette(CorePalette.of(argb));
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Light Material content color scheme, based on the color's hue.
   */
  static lightContent(argb: number): Scheme {
    return Scheme.lightFromCorePalette(CorePalette.contentOf(argb));
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Dark Material content color scheme, based on the color's hue.
   */
  static darkContent(argb: number): Scheme {
    return Scheme.darkFromCorePalette(CorePalette.contentOf(argb));
  }

  /**
   * Light scheme from core palette
   */
  static lightFromCorePalette(core: CorePalette): Scheme {
    return new Scheme({
      primary: core.a1.tone(40),
      onPrimary: core.a1.tone(100),
      primaryContainer: core.a1.tone(90),
      onPrimaryContainer: core.a1.tone(10),
      secondary: core.a2.tone(40),
      onSecondary: core.a2.tone(100),
      secondaryContainer: core.a2.tone(90),
      onSecondaryContainer: core.a2.tone(10),
      tertiary: core.a3.tone(40),
      onTertiary: core.a3.tone(100),
      tertiaryContainer: core.a3.tone(90),
      onTertiaryContainer: core.a3.tone(10),
      error: core.error.tone(40),
      onError: core.error.tone(100),
      errorContainer: core.error.tone(90),
      onErrorContainer: core.error.tone(10),
      background: core.n1.tone(99),
      onBackground: core.n1.tone(10),
      surface: core.n1.tone(99),
      onSurface: core.n1.tone(10),
      surfaceVariant: core.n2.tone(90),
      onSurfaceVariant: core.n2.tone(30),
      outline: core.n2.tone(50),
      outlineVariant: core.n2.tone(80),
      shadow: core.n1.tone(0),
      scrim: core.n1.tone(0),
      inverseSurface: core.n1.tone(20),
      inverseOnSurface: core.n1.tone(95),
      inversePrimary: core.a1.tone(80)
    });
  }

  /**
   * Dark scheme from core palette
   */
  static darkFromCorePalette(core: CorePalette): Scheme {
    return new Scheme({
      primary: core.a1.tone(80),
      onPrimary: core.a1.tone(20),
      primaryContainer: core.a1.tone(30),
      onPrimaryContainer: core.a1.tone(90),
      secondary: core.a2.tone(80),
      onSecondary: core.a2.tone(20),
      secondaryContainer: core.a2.tone(30),
      onSecondaryContainer: core.a2.tone(90),
      tertiary: core.a3.tone(80),
      onTertiary: core.a3.tone(20),
      tertiaryContainer: core.a3.tone(30),
      onTertiaryContainer: core.a3.tone(90),
      error: core.error.tone(80),
      onError: core.error.tone(20),
      errorContainer: core.error.tone(30),
      onErrorContainer: core.error.tone(80),
      background: core.n1.tone(10),
      onBackground: core.n1.tone(90),
      surface: core.n1.tone(10),
      onSurface: core.n1.tone(90),
      surfaceVariant: core.n2.tone(30),
      onSurfaceVariant: core.n2.tone(80),
      outline: core.n2.tone(60),
      outlineVariant: core.n2.tone(30),
      shadow: core.n1.tone(0),
      scrim: core.n1.tone(0),
      inverseSurface: core.n1.tone(90),
      inverseOnSurface: core.n1.tone(20),
      inversePrimary: core.a1.tone(40)
    });
  }

  private constructor(private readonly props: {
    primary: number,
    onPrimary: number,
    primaryContainer: number,
    onPrimaryContainer: number,
    secondary: number,
    onSecondary: number,
    secondaryContainer: number,
    onSecondaryContainer: number,
    tertiary: number,
    onTertiary: number,
    tertiaryContainer: number,
    onTertiaryContainer: number,
    error: number,
    onError: number,
    errorContainer: number,
    onErrorContainer: number,
    background: number,
    onBackground: number,
    surface: number,
    onSurface: number,
    surfaceVariant: number,
    onSurfaceVariant: number,
    outline: number,
    outlineVariant: number,
    shadow: number,
    scrim: number,
    inverseSurface: number,
    inverseOnSurface: number,
    inversePrimary: number
  }) { }

  toJSON() {
    return {
      ...this.props
    };
  }
}
// --- END FILE: scheme/scheme.ts ---


// --- BEGIN FILE: scheme/scheme_android.ts ---
/**
 * Represents an Android 12 color scheme, a mapping of color roles to colors.
 */
export class SchemeAndroid {
  get colorAccentPrimary(): number {
    return this.props.colorAccentPrimary;
  }

  get colorAccentPrimaryVariant(): number {
    return this.props.colorAccentPrimaryVariant;
  }

  get colorAccentSecondary(): number {
    return this.props.colorAccentSecondary;
  }

  get colorAccentSecondaryVariant(): number {
    return this.props.colorAccentSecondaryVariant;
  }

  get colorAccentTertiary(): number {
    return this.props.colorAccentTertiary;
  }

  get colorAccentTertiaryVariant(): number {
    return this.props.colorAccentTertiaryVariant;
  }

  get textColorPrimary(): number {
    return this.props.textColorPrimary;
  }

  get textColorSecondary(): number {
    return this.props.textColorSecondary;
  }

  get textColorTertiary(): number {
    return this.props.textColorTertiary;
  }

  get textColorPrimaryInverse(): number {
    return this.props.textColorPrimaryInverse;
  }

  get textColorSecondaryInverse(): number {
    return this.props.textColorSecondaryInverse;
  }

  get textColorTertiaryInverse(): number {
    return this.props.textColorTertiaryInverse;
  }

  get colorBackground(): number {
    return this.props.colorBackground;
  }

  get colorBackgroundFloating(): number {
    return this.props.colorBackgroundFloating;
  }

  get colorSurface(): number {
    return this.props.colorSurface;
  }

  get colorSurfaceVariant(): number {
    return this.props.colorSurfaceVariant;
  }

  get colorSurfaceHighlight(): number {
    return this.props.colorSurfaceHighlight;
  }

  get surfaceHeader(): number {
    return this.props.surfaceHeader;
  }

  get underSurface(): number {
    return this.props.underSurface;
  }

  get offState(): number {
    return this.props.offState;
  }

  get accentSurface(): number {
    return this.props.accentSurface;
  }

  get textPrimaryOnAccent(): number {
    return this.props.textPrimaryOnAccent;
  }

  get textSecondaryOnAccent(): number {
    return this.props.textSecondaryOnAccent;
  }

  get volumeBackground(): number {
    return this.props.volumeBackground;
  }

  get scrim(): number {
    return this.props.scrim;
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Light Material color scheme, based on the color's hue.
   */
  static light(argb: number): SchemeAndroid {
    const core = CorePalette.of(argb);
    return SchemeAndroid.lightFromCorePalette(core);
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Dark Material color scheme, based on the color's hue.
   */
  static dark(argb: number): SchemeAndroid {
    const core = CorePalette.of(argb);
    return SchemeAndroid.darkFromCorePalette(core);
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Light Android color scheme, based on the color's hue.
   */
  static lightContent(argb: number): SchemeAndroid {
    const core = CorePalette.contentOf(argb);
    return SchemeAndroid.lightFromCorePalette(core);
  }

  /**
   * @param argb ARGB representation of a color.
   * @return Dark Android color scheme, based on the color's hue.
   */
  static darkContent(argb: number): SchemeAndroid {
    const core = CorePalette.contentOf(argb);
    return SchemeAndroid.darkFromCorePalette(core);
  }

  /**
   * Light scheme from core palette
   */
  static lightFromCorePalette(core: CorePalette): SchemeAndroid {
    return new SchemeAndroid({
      colorAccentPrimary: core.a1.tone(90),
      colorAccentPrimaryVariant: core.a1.tone(40),
      colorAccentSecondary: core.a2.tone(90),
      colorAccentSecondaryVariant: core.a2.tone(40),
      colorAccentTertiary: core.a3.tone(90),
      colorAccentTertiaryVariant: core.a3.tone(40),
      textColorPrimary: core.n1.tone(10),
      textColorSecondary: core.n2.tone(30),
      textColorTertiary: core.n2.tone(50),
      textColorPrimaryInverse: core.n1.tone(95),
      textColorSecondaryInverse: core.n1.tone(80),
      textColorTertiaryInverse: core.n1.tone(60),
      colorBackground: core.n1.tone(95),
      colorBackgroundFloating: core.n1.tone(98),
      colorSurface: core.n1.tone(98),
      colorSurfaceVariant: core.n1.tone(90),
      colorSurfaceHighlight: core.n1.tone(100),
      surfaceHeader: core.n1.tone(90),
      underSurface: core.n1.tone(0),
      offState: core.n1.tone(20),
      accentSurface: core.a2.tone(95),
      textPrimaryOnAccent: core.n1.tone(10),
      textSecondaryOnAccent: core.n2.tone(30),
      volumeBackground: core.n1.tone(25),
      scrim: core.n1.tone(80),
    });
  }

  /**
   * Dark scheme from core palette
   */
  static darkFromCorePalette(core: CorePalette): SchemeAndroid {
    return new SchemeAndroid({
      colorAccentPrimary: core.a1.tone(90),
      colorAccentPrimaryVariant: core.a1.tone(70),
      colorAccentSecondary: core.a2.tone(90),
      colorAccentSecondaryVariant: core.a2.tone(70),
      colorAccentTertiary: core.a3.tone(90),
      colorAccentTertiaryVariant: core.a3.tone(70),
      textColorPrimary: core.n1.tone(95),
      textColorSecondary: core.n2.tone(80),
      textColorTertiary: core.n2.tone(60),
      textColorPrimaryInverse: core.n1.tone(10),
      textColorSecondaryInverse: core.n1.tone(30),
      textColorTertiaryInverse: core.n1.tone(50),
      colorBackground: core.n1.tone(10),
      colorBackgroundFloating: core.n1.tone(10),
      colorSurface: core.n1.tone(20),
      colorSurfaceVariant: core.n1.tone(30),
      colorSurfaceHighlight: core.n1.tone(35),
      surfaceHeader: core.n1.tone(30),
      underSurface: core.n1.tone(0),
      offState: core.n1.tone(20),
      accentSurface: core.a2.tone(95),
      textPrimaryOnAccent: core.n1.tone(10),
      textSecondaryOnAccent: core.n2.tone(30),
      volumeBackground: core.n1.tone(25),
      scrim: core.n1.tone(80),
    });
  }

  private constructor(private readonly props: {
    colorAccentPrimary: number,
    colorAccentPrimaryVariant: number,
    colorAccentSecondary: number,
    colorAccentSecondaryVariant: number,
    colorAccentTertiary: number,
    colorAccentTertiaryVariant: number,
    textColorPrimary: number,
    textColorSecondary: number,
    textColorTertiary: number,
    textColorPrimaryInverse: number,
    textColorSecondaryInverse: number,
    textColorTertiaryInverse: number,
    colorBackground: number,
    colorBackgroundFloating: number,
    colorSurface: number,
    colorSurfaceVariant: number,
    colorSurfaceHighlight: number,
    surfaceHeader: number,
    underSurface: number,
    offState: number,
    accentSurface: number,
    textPrimaryOnAccent: number,
    textSecondaryOnAccent: number,
    volumeBackground: number,
    scrim: number
  }) { }

  toJSON() {
    return { ...this.props };
  }
}
// --- END FILE: scheme/scheme_android.ts ---


// --- BEGIN FILE: scheme/scheme_content.ts ---
/**
 * A scheme that places the source color in `Scheme.primaryContainer`.
 *
 * Primary Container is the source color, adjusted for color relativity.
 * It maintains constant appearance in light mode and dark mode.
 * This adds ~5 tone in light mode, and subtracts ~5 tone in dark mode.
 * Tertiary Container is the complement to the source color, using
 * `TemperatureCache`. It also maintains constant appearance.
 */
export class SchemeContent extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.CONTENT,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma),
      secondaryPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue,
        Math.max(sourceColorHct.chroma - 32.0, sourceColorHct.chroma * 0.5)),
      tertiaryPalette: TonalPalette.fromInt(
        DislikeAnalyzer
          .fixIfDisliked(
            new TemperatureCache(sourceColorHct).analogous(3, 6)[2])
          .toInt()),
      neutralPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma / 8.0),
      neutralVariantPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma / 8.0 + 4.0),
    });
  }
}
// --- END FILE: scheme/scheme_content.ts ---


// --- BEGIN FILE: scheme/scheme_expressive.ts ---
/**
 * A Dynamic Color theme that is intentionally detached from the source color.
 */
export class SchemeExpressive extends DynamicScheme {
  /**
   * Hues (in degrees) used at breakpoints such that designers can specify a
   * hue rotation that occurs at a given break point.
   */
  private static readonly hues: number[] = [
    0.0,
    21.0,
    51.0,
    121.0,
    151.0,
    191.0,
    271.0,
    321.0,
    360.0,
  ];

  /**
   * Hue rotations (in degrees) of the Secondary [TonalPalette],
   * corresponding to the breakpoints in [hues].
   */
  private static readonly secondaryRotations: number[] = [
    45.0,
    95.0,
    45.0,
    20.0,
    45.0,
    90.0,
    45.0,
    45.0,
    45.0,
  ];

  /**
   * Hue rotations (in degrees) of the Tertiary [TonalPalette],
   * corresponding to the breakpoints in [hues].
   */
  private static readonly tertiaryRotations: number[] = [
    120.0,
    120.0,
    20.0,
    45.0,
    20.0,
    15.0,
    20.0,
    120.0,
    120.0,
  ];

  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.EXPRESSIVE,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(
        math.sanitizeDegreesDouble(sourceColorHct.hue + 240.0), 40.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(
        DynamicScheme.getRotatedHue(
          sourceColorHct, SchemeExpressive.hues,
          SchemeExpressive.secondaryRotations),
        24.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(
        DynamicScheme.getRotatedHue(
          sourceColorHct, SchemeExpressive.hues,
          SchemeExpressive.tertiaryRotations),
        32.0),
      neutralPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue + 15, 8.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue + 15, 12.0),
    });
  }
}
// --- END FILE: scheme/scheme_expressive.ts ---


// --- BEGIN FILE: scheme/scheme_fidelity.ts ---
/**
 * A scheme that places the source color in `Scheme.primaryContainer`.
 *
 * Primary Container is the source color, adjusted for color relativity.
 * It maintains constant appearance in light mode and dark mode.
 * This adds ~5 tone in light mode, and subtracts ~5 tone in dark mode.
 * Tertiary Container is the complement to the source color, using
 * `TemperatureCache`. It also maintains constant appearance.
 */
export class SchemeFidelity extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.FIDELITY,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma),
      secondaryPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue,
        Math.max(sourceColorHct.chroma - 32.0, sourceColorHct.chroma * 0.5)),
      tertiaryPalette: TonalPalette.fromInt(
        DislikeAnalyzer
          .fixIfDisliked(new TemperatureCache(sourceColorHct).complement)
          .toInt()),
      neutralPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma / 8.0),
      neutralVariantPalette: TonalPalette.fromHueAndChroma(
        sourceColorHct.hue, sourceColorHct.chroma / 8.0 + 4.0),
    });
  }
}
// --- END FILE: scheme/scheme_fidelity.ts ---


// --- BEGIN FILE: scheme/scheme_fruit_salad.ts ---
/**
 * A playful theme - the source color's hue does not appear in the theme.
 */
export class SchemeFruitSalad extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.FRUIT_SALAD,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(
        math.sanitizeDegreesDouble(sourceColorHct.hue - 50.0), 48.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(
        math.sanitizeDegreesDouble(sourceColorHct.hue - 50.0), 36.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 36.0),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 10.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 16.0),
    });
  }
}
// --- END FILE: scheme/scheme_fruit_salad.ts ---


// --- BEGIN FILE: scheme/scheme_monochrome.ts ---
/** A Dynamic Color theme that is grayscale. */
export class SchemeMonochrome extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.MONOCHROME,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
    });
  }
}
// --- END FILE: scheme/scheme_monochrome.ts ---


// --- BEGIN FILE: scheme/scheme_neutral.ts ---
/** A Dynamic Color theme that is near grayscale. */
export class SchemeNeutral extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.NEUTRAL,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 12.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 8.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 16.0),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 2.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 2.0),
    });
  }
}
// --- END FILE: scheme/scheme_neutral.ts ---


// --- BEGIN FILE: scheme/scheme_rainbow.ts ---
/**
 * A playful theme - the source color's hue does not appear in the theme.
 */
export class SchemeRainbow extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.RAINBOW,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 48.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 16.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(
        math.sanitizeDegreesDouble(sourceColorHct.hue + 60.0), 24.0),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 0.0),
    });
  }
}
// --- END FILE: scheme/scheme_rainbow.ts ---


// --- BEGIN FILE: scheme/scheme_tonal_spot.ts ---
/**
 * A Dynamic Color theme with low to medium colorfulness and a Tertiary
 * TonalPalette with a hue related to the source color.
 *
 * The default Material You theme on Android 12 and 13.
 */
export class SchemeTonalSpot extends DynamicScheme {
  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.TONAL_SPOT,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 36.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 16.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(
        math.sanitizeDegreesDouble(sourceColorHct.hue + 60.0),
        24.0,
      ),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 6.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 8.0),
    });
  }
}
// --- END FILE: scheme/scheme_tonal_spot.ts ---


// --- BEGIN FILE: scheme/scheme_vibrant.ts ---
/**
 * A Dynamic Color theme that maxes out colorfulness at each position in the
 * Primary Tonal Palette.
 */
export class SchemeVibrant extends DynamicScheme {
  /**
   * Hues (in degrees) used at breakpoints such that designers can specify a
   * hue rotation that occurs at a given break point.
   */
  private static readonly hues = [
    0.0,
    41.0,
    61.0,
    101.0,
    131.0,
    181.0,
    251.0,
    301.0,
    360.0,
  ];

  /**
   * Hue rotations (in degrees) of the Secondary [TonalPalette],
   * corresponding to the breakpoints in [hues].
   */
  private static readonly secondaryRotations = [
    18.0,
    15.0,
    10.0,
    12.0,
    15.0,
    18.0,
    15.0,
    12.0,
    12.0,
  ];

  /**
   * Hue rotations (in degrees) of the Tertiary [TonalPalette],
   * corresponding to the breakpoints in [hues].
   */
  private static readonly tertiaryRotations = [
    35.0,
    30.0,
    20.0,
    25.0,
    30.0,
    35.0,
    30.0,
    25.0,
    25.0,
  ];

  constructor(sourceColorHct: Hct, isDark: boolean, contrastLevel: number) {
    super({
      sourceColorHct,
      variant: Variant.VIBRANT,
      contrastLevel,
      isDark,
      primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 200.0),
      secondaryPalette: TonalPalette.fromHueAndChroma(
        DynamicScheme.getRotatedHue(
          sourceColorHct, SchemeVibrant.hues,
          SchemeVibrant.secondaryRotations),
        24.0),
      tertiaryPalette: TonalPalette.fromHueAndChroma(
        DynamicScheme.getRotatedHue(
          sourceColorHct, SchemeVibrant.hues,
          SchemeVibrant.tertiaryRotations),
        32.0),
      neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 10.0),
      neutralVariantPalette:
        TonalPalette.fromHueAndChroma(sourceColorHct.hue, 12.0),
    });
  }
}
// --- END FILE: scheme/scheme_vibrant.ts ---


// --- BEGIN FILE: score/score.ts ---
/**
 * Default options for ranking colors based on usage counts.
 * desired: is the max count of the colors returned.
 * fallbackColorARGB: Is the default color that should be used if no
 *                    other colors are suitable.
 * filter: controls if the resulting colors should be filtered to not include
 *         hues that are not used often enough, and colors that are effectively
 *         grayscale.
 */
declare interface ScoreOptions {
  desired?: number;
  fallbackColorARGB?: number;
  filter?: boolean;
}

const SCORE_OPTION_DEFAULTS = {
  desired: 4,  // 4 colors matches what Android wallpaper picker.
  fallbackColorARGB: 0xff4285f4,  // Google Blue.
  filter: true,  // Avoid unsuitable colors.
};

export function compare(a: { hct: Hct, score: number }, b: { hct: Hct, score: number }): number {
  if (a.score > b.score) {
    return -1;
  } else if (a.score < b.score) {
    return 1;
  }
  return 0;
}

/**
 *  Given a large set of colors, remove colors that are unsuitable for a UI
 *  theme, and rank the rest based on suitability.
 *
 *  Enables use of a high cluster count for image quantization, thus ensuring
 *  colors aren't muddied, while curating the high cluster count to a much
 *  smaller number of appropriate choices.
 */
export class Score {
  private static readonly TARGET_CHROMA = 48.0;  // A1 Chroma
  private static readonly WEIGHT_PROPORTION = 0.7;
  private static readonly WEIGHT_CHROMA_ABOVE = 0.3;
  private static readonly WEIGHT_CHROMA_BELOW = 0.1;
  private static readonly CUTOFF_CHROMA = 5.0;
  private static readonly CUTOFF_EXCITED_PROPORTION = 0.01;

  private constructor() { }

  /**
   * Given a map with keys of colors and values of how often the color appears,
   * rank the colors based on suitability for being used for a UI theme.
   *
   * @param colorsToPopulation map with keys of colors and values of how often
   *     the color appears, usually from a source image.
   * @param {ScoreOptions} options optional parameters.
   * @return Colors sorted by suitability for a UI theme. The most suitable
   *     color is the first item, the least suitable is the last. There will
   *     always be at least one color returned. If all the input colors
   *     were not suitable for a theme, a default fallback color will be
   *     provided, Google Blue.
   */
  static score(
    colorsToPopulation: Map<number, number>, options?: ScoreOptions):
    number[] {
    const { desired, fallbackColorARGB, filter } = { ...SCORE_OPTION_DEFAULTS, ...options };
    // Get the HCT color for each Argb value, while finding the per hue count and
    // total count.
    const colorsHct: Hct[] = [];
    const huePopulation = new Array<number>(360).fill(0);
    let populationSum = 0;
    for (const [argb, population] of colorsToPopulation.entries()) {
      const hct = Hct.fromInt(argb);
      colorsHct.push(hct);
      const hue = Math.floor(hct.hue);
      huePopulation[hue] += population;
      populationSum += population;
    }

    // Hues with more usage in neighboring 30 degree slice get a larger number.
    const hueExcitedProportions = new Array<number>(360).fill(0.0);
    for (let hue = 0; hue < 360; hue++) {
      const proportion = huePopulation[hue] / populationSum;
      for (let i = hue - 14; i < hue + 16; i++) {
        const neighborHue = math.sanitizeDegreesInt(i);
        hueExcitedProportions[neighborHue] += proportion;
      }
    }

    // Scores each HCT color based on usage and chroma, while optionally
    // filtering out values that do not have enough chroma or usage.
    const scoredHct = new Array<{ hct: Hct, score: number }>();
    for (const hct of colorsHct) {
      const hue = math.sanitizeDegreesInt(Math.round(hct.hue));
      const proportion = hueExcitedProportions[hue];
      if (filter && (hct.chroma < Score.CUTOFF_CHROMA || proportion <= Score.CUTOFF_EXCITED_PROPORTION)) {
        continue;
      }

      const proportionScore = proportion * 100.0 * Score.WEIGHT_PROPORTION;
      const chromaWeight = hct.chroma < Score.TARGET_CHROMA ? Score.WEIGHT_CHROMA_BELOW : Score.WEIGHT_CHROMA_ABOVE;
      const chromaScore = (hct.chroma - Score.TARGET_CHROMA) * chromaWeight;
      const score = proportionScore + chromaScore;
      scoredHct.push({ hct, score });
    }
    // Sorted so that colors with higher scores come first.
    scoredHct.sort(compare);

    // Iterates through potential hue differences in degrees in order to select
    // the colors with the largest distribution of hues possible. Starting at
    // 90 degrees(maximum difference for 4 colors) then decreasing down to a
    // 15 degree minimum.
    const chosenColors: Hct[] = [];
    for (let differenceDegrees = 90; differenceDegrees >= 15; differenceDegrees--) {
      chosenColors.length = 0;
      for (const { hct } of scoredHct) {
        const duplicateHue = chosenColors.find(chosenHct => {
          return math.differenceDegrees(hct.hue, chosenHct.hue) < differenceDegrees;
        });
        if (!duplicateHue) {
          chosenColors.push(hct);
        }
        if (chosenColors.length >= desired) break;
      }
      if (chosenColors.length >= desired) break;
    }
    const colors: number[] = [];
    if (chosenColors.length === 0) {
      colors.push(fallbackColorARGB);
    }
    for (const chosenHct of chosenColors) {
      colors.push(chosenHct.toInt());
    }
    return colors;
  }
}
// --- END FILE: score/score.ts ---


// --- BEGIN FILE: temperature/temperature_cache.ts ---
// This file is automatically generated. Do not modify it.

/**
 * Design utilities using color temperature theory.
 *
 * Analogous colors, complementary color, and cache to efficiently, lazily,
 * generate data for calculations when needed.
 */
export class TemperatureCache {
  constructor(public input: Hct) { }

  hctsByTempCache: Hct[] = [];
  hctsByHueCache: Hct[] = [];
  tempsByHctCache = new Map<Hct, number>();
  inputRelativeTemperatureCache: number = -1.0;
  complementCache: Hct | null = null;

  get hctsByTemp(): Hct[] {
    if (this.hctsByTempCache.length > 0) {
      return this.hctsByTempCache;
    }

    const hcts = this.hctsByHue.concat([this.input]);
    const temperaturesByHct = this.tempsByHct;
    hcts.sort((a, b) => temperaturesByHct.get(a)! - temperaturesByHct.get(b)!);
    this.hctsByTempCache = hcts;
    return hcts;
  }

  get warmest(): Hct {
    return this.hctsByTemp[this.hctsByTemp.length - 1];
  }

  get coldest(): Hct {
    return this.hctsByTemp[0];
  }

  /**
   * A set of colors with differing hues, equidistant in temperature.
   *
   * In art, this is usually described as a set of 5 colors on a color wheel
   * divided into 12 sections. This method allows provision of either of those
   * values.
   *
   * Behavior is undefined when [count] or [divisions] is 0.
   * When divisions < count, colors repeat.
   *
   * [count] The number of colors to return, includes the input color.
   * [divisions] The number of divisions on the color wheel.
   */
  analogous(count = 5, divisions = 12): Hct[] {
    const startHue = Math.round(this.input.hue);
    const startHct = this.hctsByHue[startHue];
    let lastTemp = this.relativeTemperature(startHct);
    const allColors = [startHct];

    let absoluteTotalTempDelta = 0.0;
    for (let i = 0; i < 360; i++) {
      const hue = math.sanitizeDegreesInt(startHue + i);
      const hct = this.hctsByHue[hue];
      const temp = this.relativeTemperature(hct);
      const tempDelta = Math.abs(temp - lastTemp);
      lastTemp = temp;
      absoluteTotalTempDelta += tempDelta;
    }
    let hueAddend = 1;
    const tempStep = absoluteTotalTempDelta / divisions;
    let totalTempDelta = 0.0;
    lastTemp = this.relativeTemperature(startHct);
    while (allColors.length < divisions) {
      const hue = math.sanitizeDegreesInt(startHue + hueAddend);
      const hct = this.hctsByHue[hue];
      const temp = this.relativeTemperature(hct);
      const tempDelta = Math.abs(temp - lastTemp);
      totalTempDelta += tempDelta;

      const desiredTotalTempDeltaForIndex = allColors.length * tempStep;
      let indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex;
      let indexAddend = 1;
      // Keep adding this hue to the answers until its temperature is
      // insufficient. This ensures consistent behavior when there aren't
      // [divisions] discrete steps between 0 and 360 in hue with [tempStep]
      // delta in temperature between them.
      //
      // For example, white and black have no analogues: there are no other
      // colors at T100/T0. Therefore, they should just be added to the array
      // as answers.
      while (indexSatisfied && allColors.length < divisions) {
        allColors.push(hct);
        const desiredTotalTempDeltaForIndex =
          ((allColors.length + indexAddend) * tempStep);
        indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex;
        indexAddend++;
      }
      lastTemp = temp;
      hueAddend++;
      if (hueAddend > 360) {
        while (allColors.length < divisions) {
          allColors.push(hct);
        }
        break;
      }
    }

    const answers = [this.input];

    // First, generate analogues from rotating counter-clockwise.
    const increaseHueCount = Math.floor((count - 1) / 2.0);
    for (let i = 1; i < (increaseHueCount + 1); i++) {
      let index = 0 - i;
      while (index < 0) {
        index = allColors.length + index;
      }
      if (index >= allColors.length) {
        index = index % allColors.length;
      }
      answers.splice(0, 0, allColors[index]);
    }

    // Second, generate analogues from rotating clockwise.
    const decreaseHueCount = count - increaseHueCount - 1;
    for (let i = 1; i < (decreaseHueCount + 1); i++) {
      let index = i;
      while (index < 0) {
        index = allColors.length + index;
      }
      if (index >= allColors.length) {
        index = index % allColors.length;
      }
      answers.push(allColors[index]);
    }

    return answers;
  }

  /**
   * A color that complements the input color aesthetically.
   *
   * In art, this is usually described as being across the color wheel.
   * History of this shows intent as a color that is just as cool-warm as the
   * input color is warm-cool.
   */
  get complement(): Hct {
    if (this.complementCache != null) {
      return this.complementCache;
    }

    const coldestHue = this.coldest.hue;
    const coldestTemp = this.tempsByHct.get(this.coldest)!;

    const warmestHue = this.warmest.hue;
    const warmestTemp = this.tempsByHct.get(this.warmest)!;
    const range = warmestTemp - coldestTemp;
    const startHueIsColdestToWarmest =
      TemperatureCache.isBetween(this.input.hue, coldestHue, warmestHue);
    const startHue = startHueIsColdestToWarmest ? warmestHue : coldestHue;
    const endHue = startHueIsColdestToWarmest ? coldestHue : warmestHue;
    const directionOfRotation = 1.0;
    let smallestError = 1000.0;
    let answer = this.hctsByHue[Math.round(this.input.hue)];

    const complementRelativeTemp = 1.0 - this.inputRelativeTemperature;
    // Find the color in the other section, closest to the inverse percentile
    // of the input color. This is the complement.
    for (let hueAddend = 0.0; hueAddend <= 360.0; hueAddend += 1.0) {
      const hue = math.sanitizeDegreesDouble(
        startHue + directionOfRotation * hueAddend);
      if (!TemperatureCache.isBetween(hue, startHue, endHue)) {
        continue;
      }
      const possibleAnswer = this.hctsByHue[Math.round(hue)];
      const relativeTemp =
        (this.tempsByHct.get(possibleAnswer)! - coldestTemp) / range;
      const error = Math.abs(complementRelativeTemp - relativeTemp);
      if (error < smallestError) {
        smallestError = error;
        answer = possibleAnswer;
      }
    }
    this.complementCache = answer;
    return this.complementCache;
  }

  /**
   * Temperature relative to all colors with the same chroma and tone.
   * Value on a scale from 0 to 1.
   */
  relativeTemperature(hct: Hct): number {
    const range =
      this.tempsByHct.get(this.warmest)! - this.tempsByHct.get(this.coldest)!;
    const differenceFromColdest =
      this.tempsByHct.get(hct)! - this.tempsByHct.get(this.coldest)!;
    // Handle when there's no difference in temperature between warmest and
    // coldest: for example, at T100, only one color is available, white.
    if (range === 0.0) {
      return 0.5;
    }
    return differenceFromColdest / range;
  }

  /** Relative temperature of the input color. See [relativeTemperature]. */
  get inputRelativeTemperature(): number {
    if (this.inputRelativeTemperatureCache >= 0.0) {
      return this.inputRelativeTemperatureCache;
    }

    this.inputRelativeTemperatureCache = this.relativeTemperature(this.input);
    return this.inputRelativeTemperatureCache;
  }

  /** A Map with keys of HCTs in [hctsByTemp], values of raw temperature. */
  get tempsByHct(): Map<Hct, number> {
    if (this.tempsByHctCache.size > 0) {
      return this.tempsByHctCache;
    }
    const allHcts = this.hctsByHue.concat([this.input]);
    const temperaturesByHct = new Map<Hct, number>();
    for (const e of allHcts) {
      temperaturesByHct.set(e, TemperatureCache.rawTemperature(e));
    }
    this.tempsByHctCache = temperaturesByHct;
    return temperaturesByHct;
  }

  /**
   * HCTs for all hues, with the same chroma/tone as the input.
   * Sorted ascending, hue 0 to 360.
   */
  get hctsByHue(): Hct[] {
    if (this.hctsByHueCache.length > 0) {
      return this.hctsByHueCache;
    }
    const hcts: Hct[] = [];
    for (let hue = 0.0; hue <= 360.0; hue += 1.0) {
      const colorAtHue = Hct.from(hue, this.input.chroma, this.input.tone);
      hcts.push(colorAtHue);
    }
    this.hctsByHueCache = hcts;
    return this.hctsByHueCache;
  }

  /** Determines if an angle is between two other angles, rotating clockwise. */
  static isBetween(angle: number, a: number, b: number): boolean {
    if (a < b) {
      return a <= angle && angle <= b;
    }
    return a <= angle || angle <= b;
  }

  /**
   * Value representing cool-warm factor of a color.
   * Values below 0 are considered cool, above, warm.
   *
   * Color science has researched emotion and harmony, which art uses to select
   * colors. Warm-cool is the foundation of analogous and complementary colors.
   * See:
   * - Li-Chen Ou's Chapter 19 in Handbook of Color Psychology (2015).
   * - Josef Albers' Interaction of Color chapters 19 and 21.
   *
   * Implementation of Ou, Woodcock and Wright's algorithm, which uses
   * L*a*b* / LCH color space.
   * Return value has these properties:
   * - Values below 0 are cool, above 0 are warm.
   * - Lower bound: -0.52 - (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, -9.66.
   * - Upper bound: -0.52 + (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, 8.61.
   */
  static rawTemperature(color: Hct): number {
    const lab = utils.labFromArgb(color.toInt());
    const hue = math.sanitizeDegreesDouble(
      Math.atan2(lab[2], lab[1]) * 180.0 / Math.PI);
    const chroma = Math.sqrt((lab[1] * lab[1]) + (lab[2] * lab[2]));
    const temperature = -0.5 +
      0.02 * Math.pow(chroma, 1.07) *
      Math.cos(
        math.sanitizeDegreesDouble(hue - 50.0) * Math.PI / 180.0,
      );
    return temperature;
  }
}
// --- END FILE: temperature/temperature_cache.ts ---


// --- BEGIN FILE: utils/color_utils.ts ---
// This file is automatically generated. Do not modify it.


/**
 * Color science utilities.
 *
 * Utility methods for color science constants and color space
 * conversions that aren't HCT or CAM16.
 */

const SRGB_TO_XYZ = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478],
];

const XYZ_TO_SRGB = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053,
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061,
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335,
  ],
];

const WHITE_POINT_D65 = [95.047, 100.0, 108.883];

/**
 * Converts a color from RGB components to ARGB format.
 */
export function argbFromRgb(red: number, green: number, blue: number): number {
  return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>>
    0;
}

/**
 * Converts a color from linear RGB components to ARGB format.
 */
export function argbFromLinrgb(linrgb: number[]): number {
  const r = delinearized(linrgb[0]);
  const g = delinearized(linrgb[1]);
  const b = delinearized(linrgb[2]);
  return argbFromRgb(r, g, b);
}

/**
 * Returns the alpha component of a color in ARGB format.
 */
export function alphaFromArgb(argb: number): number {
  return argb >> 24 & 255;
}

/**
 * Returns the red component of a color in ARGB format.
 */
export function redFromArgb(argb: number): number {
  return argb >> 16 & 255;
}

/**
 * Returns the green component of a color in ARGB format.
 */
export function greenFromArgb(argb: number): number {
  return argb >> 8 & 255;
}

/**
 * Returns the blue component of a color in ARGB format.
 */
export function blueFromArgb(argb: number): number {
  return argb & 255;
}

/**
 * Returns whether a color in ARGB format is opaque.
 */
export function isOpaque(argb: number): boolean {
  return alphaFromArgb(argb) >= 255;
}

/**
 * Converts a color from ARGB to XYZ.
 */
export function argbFromXyz(x: number, y: number, z: number): number {
  const matrix = XYZ_TO_SRGB;
  const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
  const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
  const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
  const r = delinearized(linearR);
  const g = delinearized(linearG);
  const b = delinearized(linearB);
  return argbFromRgb(r, g, b);
}

/**
 * Converts a color from XYZ to ARGB.
 */
export function xyzFromArgb(argb: number): number[] {
  const r = linearized(redFromArgb(argb));
  const g = linearized(greenFromArgb(argb));
  const b = linearized(blueFromArgb(argb));
  return math.matrixMultiply([r, g, b], SRGB_TO_XYZ);
}

/**
 * Converts a color represented in Lab color space into an ARGB
 * integer.
 */
export function argbFromLab(l: number, a: number, b: number): number {
  const whitePoint = WHITE_POINT_D65;
  const fy = (l + 16.0) / 116.0;
  const fx = a / 500.0 + fy;
  const fz = fy - b / 200.0;
  const xNormalized = labInvf(fx);
  const yNormalized = labInvf(fy);
  const zNormalized = labInvf(fz);
  const x = xNormalized * whitePoint[0];
  const y = yNormalized * whitePoint[1];
  const z = zNormalized * whitePoint[2];
  return argbFromXyz(x, y, z);
}

/**
 * Converts a color from ARGB representation to L*a*b*
 * representation.
 *
 * @param argb the ARGB representation of a color
 * @return a Lab object representing the color
 */
export function labFromArgb(argb: number): number[] {
  const linearR = linearized(redFromArgb(argb));
  const linearG = linearized(greenFromArgb(argb));
  const linearB = linearized(blueFromArgb(argb));
  const matrix = SRGB_TO_XYZ;
  const x =
    matrix[0][0] * linearR + matrix[0][1] * linearG + matrix[0][2] * linearB;
  const y =
    matrix[1][0] * linearR + matrix[1][1] * linearG + matrix[1][2] * linearB;
  const z =
    matrix[2][0] * linearR + matrix[2][1] * linearG + matrix[2][2] * linearB;
  const whitePoint = WHITE_POINT_D65;
  const xNormalized = x / whitePoint[0];
  const yNormalized = y / whitePoint[1];
  const zNormalized = z / whitePoint[2];
  const fx = labF(xNormalized);
  const fy = labF(yNormalized);
  const fz = labF(zNormalized);
  const l = 116.0 * fy - 16;
  const a = 500.0 * (fx - fy);
  const b = 200.0 * (fy - fz);
  return [l, a, b];
}

/**
 * Converts an L* value to an ARGB representation.
 *
 * @param lstar L* in L*a*b*
 * @return ARGB representation of grayscale color with lightness
 * matching L*
 */
export function argbFromLstar(lstar: number): number {
  const y = yFromLstar(lstar);
  const component = delinearized(y);
  return argbFromRgb(component, component, component);
}

/**
 * Computes the L* value of a color in ARGB representation.
 *
 * @param argb ARGB representation of a color
 * @return L*, from L*a*b*, coordinate of the color
 */
export function lstarFromArgb(argb: number): number {
  const y = xyzFromArgb(argb)[1];
  return 116.0 * labF(y / 100.0) - 16.0;
}

/**
 * Converts an L* value to a Y value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 *
 * @param lstar L* in L*a*b*
 * @return Y in XYZ
 */
export function yFromLstar(lstar: number): number {
  return 100.0 * labInvf((lstar + 16.0) / 116.0);
}

/**
 * Converts a Y value to an L* value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 *
 * @param y Y in XYZ
 * @return L* in L*a*b*
 */
export function lstarFromY(y: number): number {
  return labF(y / 100.0) * 116.0 - 16.0;
}

/**
 * Linearizes an RGB component.
 *
 * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
 * channel
 * @return 0.0 <= output <= 100.0, color channel converted to
 * linear RGB space
 */
export function linearized(rgbComponent: number): number {
  const normalized = rgbComponent / 255.0;
  if (normalized <= 0.040449936) {
    return normalized / 12.92 * 100.0;
  } else {
    return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
  }
}

/**
 * Delinearizes an RGB component.
 *
 * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
 * linear R/G/B channel
 * @return 0 <= output <= 255, color channel converted to regular
 * RGB space
 */
export function delinearized(rgbComponent: number): number {
  const normalized = rgbComponent / 100.0;
  let delinearized = 0.0;
  if (normalized <= 0.0031308) {
    delinearized = normalized * 12.92;
  } else {
    delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
  }
  return math.clampInt(0, 255, Math.round(delinearized * 255.0));
}

/**
 * Returns the standard white point; white on a sunny day.
 *
 * @return The white point
 */
export function whitePointD65(): number[] {
  return WHITE_POINT_D65;
}

export function labF(t: number): number {
  const e = 216.0 / 24389.0;
  const kappa = 24389.0 / 27.0;
  if (t > e) {
    return Math.pow(t, 1.0 / 3.0);
  } else {
    return (kappa * t + 16) / 116;
  }
}

export function labInvf(ft: number): number {
  const e = 216.0 / 24389.0;
  const kappa = 24389.0 / 27.0;
  const ft3 = ft * ft * ft;
  if (ft3 > e) {
    return ft3;
  } else {
    return (116 * ft - 16) / kappa;
  }
}
// --- END FILE: utils/color_utils.ts ---


// --- BEGIN FILE: utils/image_utils.ts ---
/**
 * Get the source color from an image.
 *
 * @param image The image element
 * @return Source color - the color most suitable for creating a UI theme
 */
export async function sourceColorFromImage(image: HTMLImageElement) {
  // Convert Image data to Pixel Array
  const imageBytes = await new Promise<Uint8ClampedArray>((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    if (!context) {
      reject(new Error('Could not get canvas context'));
      return;
    }
    const loadCallback = () => {
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      let rect = [0, 0, image.width, image.height];
      const area = image.dataset['area'];
      if (area && /^\d+(\s*,\s*\d+){3}$/.test(area)) {
        rect = area.split(/\s*,\s*/).map(s => {
          // tslint:disable-next-line:ban
          return parseInt(s, 10);
        });
      }
      const [sx, sy, sw, sh] = rect;
      resolve(context.getImageData(sx, sy, sw, sh).data);
    };
    const errorCallback = () => {
      reject(new Error('Image load failed'));
    };
    if (image.complete) {
      loadCallback();
    } else {
      image.onload = loadCallback;
      image.onerror = errorCallback;
    }
  });

  return sourceColorFromImageBytes(imageBytes);
}

/**
 * Get the source color from image bytes.
 *
 * @param imageBytes The image bytes
 * @return Source color - the color most suitable for creating a UI theme
 */
export function sourceColorFromImageBytes(imageBytes: Uint8ClampedArray) {
  // Convert Image data to Pixel Array
  const pixels: number[] = [];
  for (let i = 0; i < imageBytes.length; i += 4) {
    const r = imageBytes[i];
    const g = imageBytes[i + 1];
    const b = imageBytes[i + 2];
    const a = imageBytes[i + 3];
    if (a < 255) {
      continue;
    }
    const argb = argbFromRgb(r, g, b);
    pixels.push(argb);
  }

  // Convert Pixels to Material Colors
  const result = QuantizerCelebi.quantize(pixels, 128);
  const ranked = Score.score(result);
  const top = ranked[0];
  return top;
}
// --- END FILE: utils/image_utils.ts ---


// --- BEGIN FILE: utils/math_utils.ts ---
// This file is automatically generated. Do not modify it.

/**
 * Utility methods for mathematical operations.
 */

/**
 * The signum function.
 *
 * @return 1 if num > 0, -1 if num < 0, and 0 if num = 0
 */
export function signum(num: number): number {
  if (num < 0) {
    return -1;
  } else if (num === 0) {
    return 0;
  } else {
    return 1;
  }
}

/**
 * The linear interpolation function.
 *
 * @return start if amount = 0 and stop if amount = 1
 */
export function lerp(start: number, stop: number, amount: number): number {
  return (1.0 - amount) * start + amount * stop;
}

/**
 * Clamps an integer between two integers.
 *
 * @return input when min <= input <= max, and either min or max
 * otherwise.
 */
export function clampInt(min: number, max: number, input: number): number {
  if (input < min) {
    return min;
  } else if (input > max) {
    return max;
  }

  return input;
}

/**
 * Clamps an integer between two floating-point numbers.
 *
 * @return input when min <= input <= max, and either min or max
 * otherwise.
 */
export function clampDouble(min: number, max: number, input: number): number {
  if (input < min) {
    return min;
  } else if (input > max) {
    return max;
  }

  return input;
}

/**
 * Sanitizes a degree measure as an integer.
 *
 * @return a degree measure between 0 (inclusive) and 360
 * (exclusive).
 */
export function sanitizeDegreesInt(degrees: number): number {
  degrees = degrees % 360;
  if (degrees < 0) {
    degrees = degrees + 360;
  }
  return degrees;
}

/**
 * Sanitizes a degree measure as a floating-point number.
 *
 * @return a degree measure between 0.0 (inclusive) and 360.0
 * (exclusive).
 */
export function sanitizeDegreesDouble(degrees: number): number {
  degrees = degrees % 360.0;
  if (degrees < 0) {
    degrees = degrees + 360.0;
  }
  return degrees;
}

/**
 * Sign of direction change needed to travel from one angle to
 * another.
 *
 * For angles that are 180 degrees apart from each other, both
 * directions have the same travel distance, so either direction is
 * shortest. The value 1.0 is returned in this case.
 *
 * @param from The angle travel starts from, in degrees.
 * @param to The angle travel ends at, in degrees.
 * @return -1 if decreasing from leads to the shortest travel
 * distance, 1 if increasing from leads to the shortest travel
 * distance.
 */
export function rotationDirection(from: number, to: number): number {
  const increasingDifference = sanitizeDegreesDouble(to - from);
  return increasingDifference <= 180.0 ? 1.0 : -1.0;
}

/**
 * Distance of two points on a circle, represented using degrees.
 */
export function differenceDegrees(a: number, b: number): number {
  return 180.0 - Math.abs(Math.abs(a - b) - 180.0);
}

/**
 * Multiplies a 1x3 row vector with a 3x3 matrix.
 */
export function matrixMultiply(row: number[], matrix: number[][]): number[] {
  const a =
    row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
  const b =
    row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
  const c =
    row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
  return [a, b, c];
}
// --- END FILE: utils/math_utils.ts ---


// --- BEGIN FILE: utils/string_utils.ts ---
/**
 * Utility methods for hexadecimal representations of colors.
 */

/**
 * @param argb ARGB representation of a color.
 * @return Hex string representing color, ex. #ff0000 for red.
 */
export function hexFromArgb(argb: number) {
  const r = utils.redFromArgb(argb);
  const g = utils.greenFromArgb(argb);
  const b = utils.blueFromArgb(argb);
  const outParts = [r.toString(16), g.toString(16), b.toString(16)];

  // Pad single-digit output values
  for (const [i, part] of outParts.entries()) {
    if (part.length === 1) {
      outParts[i] = '0' + part;
    }
  }

  return '#' + outParts.join('');
}

/**
 * @param hex String representing color as hex code. Accepts strings with or
 *     without leading #, and string representing the color using 3, 6, or 8
 *     hex characters.
 * @return ARGB representation of color.
 */
export function argbFromHex(hex: string) {
  hex = hex.replace('#', '');
  const isThree = hex.length === 3;
  const isSix = hex.length === 6;
  const isEight = hex.length === 8;
  if (!isThree && !isSix && !isEight) {
    throw new Error('unexpected hex ' + hex);
  }
  let r = 0;
  let g = 0;
  let b = 0;
  if (isThree) {
    r = parseIntHex(hex.slice(0, 1).repeat(2));
    g = parseIntHex(hex.slice(1, 2).repeat(2));
    b = parseIntHex(hex.slice(2, 3).repeat(2));
  } else if (isSix) {
    r = parseIntHex(hex.slice(0, 2));
    g = parseIntHex(hex.slice(2, 4));
    b = parseIntHex(hex.slice(4, 6));
  } else if (isEight) {
    r = parseIntHex(hex.slice(2, 4));
    g = parseIntHex(hex.slice(4, 6));
    b = parseIntHex(hex.slice(6, 8));
  }

  return (
    ((255 << 24) | ((r & 0x0ff) << 16) | ((g & 0x0ff) << 8) | (b & 0x0ff)) >>>
    0);
}

function parseIntHex(value: string) {
  // tslint:disable-next-line:ban
  return parseInt(value, 16);
}
// --- END FILE: utils/string_utils.ts ---


// --- BEGIN FILE: utils/theme_utils.ts ---
/**
 * Custom color used to pair with a theme
 */
export interface CustomColor {
  value: number;
  name: string;
  blend: boolean;
}

/**
 * Color group
 */
export interface ColorGroup {
  color: number;
  onColor: number;
  colorContainer: number;
  onColorContainer: number;
}

/**
 * Custom Color Group
 */
export interface CustomColorGroup {
  color: CustomColor;
  value: number;
  light: ColorGroup;
  dark: ColorGroup;
}

/**
 * Theme
 */
export interface Theme {
  source: number;
  schemes: { light: Scheme; dark: Scheme; };
  palettes: {
    primary: TonalPalette; secondary: TonalPalette; tertiary: TonalPalette;
    neutral: TonalPalette;
    neutralVariant: TonalPalette;
    error: TonalPalette;
  };
  customColors: CustomColorGroup[];
}

/**
 * Generate a theme from a source color
 *
 * @param source Source color
 * @param customColors Array of custom colors
 * @return Theme object
 */
export function themeFromSourceColor(
  source: number, customColors: CustomColor[] = []): Theme {
  const palette = CorePalette.of(source);
  return {
    source,
    schemes: {
      light: Scheme.light(source),
      dark: Scheme.dark(source),
    },
    palettes: {
      primary: palette.a1,
      secondary: palette.a2,
      tertiary: palette.a3,
      neutral: palette.n1,
      neutralVariant: palette.n2,
      error: palette.error,
    },
    customColors: customColors.map((c) => customColor(source, c)),
  };
}

/**
 * Generate a theme from an image source
 *
 * @param image Image element
 * @param customColors Array of custom colors
 * @return Theme object
 */
export async function themeFromImage(
  image: HTMLImageElement, customColors: CustomColor[] = []) {
  const source = await sourceColorFromImage(image);
  return themeFromSourceColor(source, customColors);
}

/**
 * Generate custom color group from source and target color
 *
 * @param source Source color
 * @param color Custom color
 * @return Custom color group
 *
 * @link https://m3.material.io/styles/color/the-color-system/color-roles
 */
export function customColor(
  source: number, color: CustomColor): CustomColorGroup {
  let value = color.value;
  const from = value;
  const to = source;
  if (color.blend) {
    value = Blend.harmonize(from, to);
  }
  const palette = CorePalette.of(value);
  const tones = palette.a1;
  return {
    color,
    value,
    light: {
      color: tones.tone(40),
      onColor: tones.tone(100),
      colorContainer: tones.tone(90),
      onColorContainer: tones.tone(10),
    },
    dark: {
      color: tones.tone(80),
      onColor: tones.tone(20),
      colorContainer: tones.tone(30),
      onColorContainer: tones.tone(90),
    },
  };
}

/**
 * Apply a theme to an element
 *
 * @param theme Theme object
 * @param options Options
 */
export function applyTheme(theme: Theme, options?: {
  dark?: boolean,
  target?: HTMLElement,
  brightnessSuffix?: boolean,
  paletteTones?: number[],
}) {
  const target = options?.target || document.body;
  const isDark = options?.dark ?? false;
  const scheme = isDark ? theme.schemes.dark : theme.schemes.light;
  setSchemeProperties(target, scheme);
  if (options?.brightnessSuffix) {
    setSchemeProperties(target, theme.schemes.dark, '-dark');
    setSchemeProperties(target, theme.schemes.light, '-light');
  }
  if (options?.paletteTones) {
    const tones = options?.paletteTones ?? [];
    for (const [key, palette] of Object.entries(theme.palettes)) {
      const paletteKey = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      for (const tone of tones) {
        const token = `--md-ref-palette-${paletteKey}-${paletteKey}${tone}`;
        const color = hexFromArgb(palette.tone(tone));
        target.style.setProperty(token, color);
      }
    }
  }
}

export function setSchemeProperties(
  target: HTMLElement,
  scheme: Scheme,
  suffix: string = '',
) {
  for (const [key, value] of Object.entries(scheme.toJSON())) {
    const token = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const color = hexFromArgb(value);
    target.style.setProperty(`--md-sys-color-${token}${suffix}`, color);
  }
}
// --- END FILE: utils/theme_utils.ts ---
